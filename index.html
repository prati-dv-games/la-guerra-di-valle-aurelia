<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>La Guerra di Valle Aurelia</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { background: #1a1a2e; width: 100%; height: 100%; overflow: hidden; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
body { display: flex; justify-content: center; align-items: center; font-family: monospace; }
canvas { border: 3px solid #e94560; image-rendering: pixelated; max-width: 100vw; max-height: 100dvh; width: auto; height: auto; }
@media (min-width: 1000px) and (min-height: 700px) and (hover: hover) {
  canvas { min-width: min(95vw, 160vh); }
}
@supports (padding: env(safe-area-inset-bottom)) {
  canvas { max-height: calc(100dvh - env(safe-area-inset-bottom)); }
}
#ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); pointer-events: none; }
#freestyle-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; display: none; justify-content: center; align-items: center; flex-direction: column; }
#freestyle-overlay.active { display: flex; }
#freestyle-video { max-width: 100%; max-height: 90vh; }
#freestyle-hint { color: #555; font-family: monospace; font-size: 12px; margin-top: 8px; }
</style>
</head>
<body>
<div id="freestyle-overlay">
  <video id="freestyle-video" src="prati_freestyle.mp4" preload="none"></video>
  <div id="freestyle-hint">ESC per tornare</div>
</div>
<canvas id="game" width="900" height="550"></canvas>
<script>
// ==========================================
// LA GUERRA DI VALLE AURELIA
// A game about il Conte vs the gang
// ==========================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 900, H = 550;

// Input
const keys = {};
const keysJustPressed = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) keysJustPressed[e.code] = true;
  keys[e.code] = true;
  e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });
let mouseX = 0, mouseY = 0, mouseClick = false;
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = (e.clientX - r.left) * (W / r.width);
  mouseY = (e.clientY - r.top) * (H / r.height);
});
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  mouseX = (e.clientX - r.left) * (W / r.width);
  mouseY = (e.clientY - r.top) * (H / r.height);
  mouseClick = true;
});
// Touch device detection
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
// When inside mobile.html iframe, the HTML overlay handles all controls — disable canvas touch buttons
const inMobileWrapper = (window.self !== window.top);

// Virtual button definitions
const touchButtons = {
  // Left side: movement + Q (ultra) on top
  left:    { x: 10,  y: H - 80, w: 60, h: 55, key: 'KeyA', label: '\u25C0', color: '#888', justPress: false },
  right:   { x: 80,  y: H - 80, w: 60, h: 55, key: 'KeyD', label: '\u25B6', color: '#888', justPress: false },
  ultra:   { x: 30,  y: H - 142, w: 80, h: 48, key: 'KeyQ', label: 'Q', color: '#ffd700', justPress: true },
  // Right side: X and W on top, ATK at bottom
  dodge:   { x: W - 170, y: H - 142, w: 70, h: 48, key: 'KeyX', label: 'X', color: '#2196f3', justPress: true },
  jump:    { x: W - 90,  y: H - 142, w: 70, h: 48, key: 'KeyW', label: 'W', color: '#4caf50', justPress: false },
  attack:  { x: W - 140, y: H - 80, w: 70, h: 55, key: 'KeyZ', label: 'ATK', color: '#e94560', justPress: true },
  // Helpers (invisible hit areas — overlay on helper bar drawn by HUD)
  helper1: { x: 14,  y: H - 175, w: 48, h: 30, key: 'Digit1', label: '', color: 'transparent', justPress: true, hidden: true },
  helper2: { x: 68,  y: H - 175, w: 48, h: 30, key: 'Digit2', label: '', color: 'transparent', justPress: true, hidden: true },
  helper3: { x: 122, y: H - 175, w: 48, h: 30, key: 'Digit3', label: '', color: 'transparent', justPress: true, hidden: true },
  helper4: { x: 176, y: H - 175, w: 48, h: 30, key: 'Digit4', label: '', color: 'transparent', justPress: true, hidden: true },
  // Utility
  tab:     { x: W - 95, y: 36, w: 38, h: 28, key: 'Tab', label: 'TAB', color: '#555', justPress: true },
  enter:   { x: W/2 - 40, y: H - 45, w: 80, h: 32, key: 'Enter', label: 'OK', color: '#4caf50', justPress: true },
  pause:   { x: W - 52, y: 36, w: 38, h: 28, key: 'Escape', label: 'II', color: '#666', justPress: true }
};

const activeTouches = {};
const touchBtnState = {}; // track which button each touch is pressing

function hitTestButton(tx, ty) {
  const validBtns = getTouchButtonsForState();
  for (const name of validBtns) {
    const b = touchButtons[name];
    if (tx >= b.x && tx <= b.x + b.w && ty >= b.y && ty <= b.y + b.h) {
      return name;
    }
  }
  return null;
}

function getTouchButtonsForState() {
  if (state === 'level') return ['attack', 'dodge', 'jump', 'left', 'right', 'ultra', 'helper1', 'helper2', 'helper3', 'helper4', 'tab', 'pause'];
  if (state === 'tutorial') return ['attack', 'dodge', 'jump', 'left', 'right', 'enter'];
  if (state === 'sabi') return ['left', 'right', 'pause'];
  if (state === 'hub' || state === 'shop' || state === 'upgrade') return ['enter', 'tab', 'pause'];
  if (state === 'dialogue') return ['enter'];
  if (state === 'menu' || state === 'difficultySelect' || state === 'weaponSelect' || state === 'helperSelect') return ['enter'];
  if (state === 'gameover' || state === 'victory') return ['enter'];
  return [];
}

function handleTouchDown(tx, ty, id) {
  const btnName = hitTestButton(tx, ty);
  if (btnName) {
    const b = touchButtons[btnName];
    touchBtnState[id] = btnName;
    keys[b.key] = true;
    if (b.justPress) keysJustPressed[b.key] = true;
  } else {
    // No button hit — treat as mouse for UI
    mouseX = tx;
    mouseY = ty;
    mouseClick = true;
  }
}

function handleTouchUp(id) {
  const btnName = touchBtnState[id];
  if (btnName) {
    const b = touchButtons[btnName];
    keys[b.key] = false;
    delete touchBtnState[id];
  }
  delete activeTouches[id];
}

function handleTouchMove(tx, ty, id) {
  const oldBtn = touchBtnState[id];
  const newBtn = hitTestButton(tx, ty);
  if (oldBtn !== newBtn) {
    // Released old button
    if (oldBtn) {
      keys[touchButtons[oldBtn].key] = false;
      delete touchBtnState[id];
    }
    // Pressed new button
    if (newBtn) {
      const b = touchButtons[newBtn];
      touchBtnState[id] = newBtn;
      keys[b.key] = true;
      if (b.justPress) keysJustPressed[b.key] = true;
    }
  }
  // Always update mouse position for UI hover
  mouseX = tx;
  mouseY = ty;
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  for (const t of e.changedTouches) {
    const tx = (t.clientX - r.left) * (W / r.width);
    const ty = (t.clientY - r.top) * (H / r.height);
    activeTouches[t.identifier] = { x: tx, y: ty };
    handleTouchDown(tx, ty, t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  for (const t of e.changedTouches) {
    const tx = (t.clientX - r.left) * (W / r.width);
    const ty = (t.clientY - r.top) * (H / r.height);
    activeTouches[t.identifier] = { x: tx, y: ty };
    handleTouchMove(tx, ty, t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    handleTouchUp(t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    handleTouchUp(t.identifier);
  }
}, { passive: false });

// ==========================================
// MUSIC & SOUND ENGINE (Web Audio API)
// ==========================================
let audioCtx = null;
let musicGain = null;
let sfxGain = null;
let currentTrack = null;
let musicPlaying = false;
let musicEnabled = true;
let audioStarted = false;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.25;
  musicGain.connect(audioCtx.destination);
  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.3;
  sfxGain.connect(audioCtx.destination);
  audioStarted = true;
}

// Start audio on first user interaction (browser policy)
function tryInitAudio() {
  if (!audioStarted) {
    initAudio();
  }
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
  // Auto-play menu music as soon as audio is available
  if (audioStarted && !musicPlaying && state === 'menu') {
    playTrack('menu');
  }
}
// Try immediately (some browsers allow it)
try { initAudio(); } catch(e) {}
window.addEventListener('keydown', tryInitAudio, { once: false });
canvas.addEventListener('click', tryInitAudio, { once: false });
canvas.addEventListener('touchstart', tryInitAudio, { once: false });

// Note frequencies
const NOTE = {
  E2:82.41,A2:110.00,Bb2:116.54,
  C3:130.81,D3:146.83,Eb3:155.56,E3:164.81,F3:174.61,Fs3:185.00,G3:196.00,Ab3:207.65,A3:220.00,Bb3:233.08,B3:246.94,
  C4:261.63,Cs4:277.18,D4:293.66,Eb4:311.13,E4:329.63,F4:349.23,Fs4:369.99,G4:392.00,Ab4:415.30,A4:440.00,Bb4:466.16,B4:493.88,
  C5:523.25,Cs5:554.37,D5:587.33,Eb5:622.25,E5:659.26,F5:698.46,Fs5:739.99,G5:783.99,Ab5:830.61,A5:880.00,Bb5:932.33,B5:987.77,
  C6:1046.50,R:0
};

// Sound effects
// Create a self-cleaning oscillator+gain pair that disconnects after playing
let activeSFXCount = 0;
const MAX_CONCURRENT_SFX = 20;
function createSFXNode(wave, dest) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = wave;
  o.connect(g); g.connect(dest);
  activeSFXCount++;
  o.onended = () => { try { g.disconnect(); o.disconnect(); } catch(e) {} activeSFXCount--; };
  return { o, g };
}

function playSFX(type) {
  if (!audioCtx || !audioStarted) return;
  if (activeSFXCount >= MAX_CONCURRENT_SFX) return; // prevent audio node buildup
  const now = audioCtx.currentTime;

  switch(type) {
    case 'hit': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.1);
      g.gain.setValueAtTime(0.3, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      o.start(now); o.stop(now + 0.15);
      break;
    }
    case 'hurt': {
      const { o, g } = createSFXNode('sawtooth', sfxGain);
      o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.2);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
      o.start(now); o.stop(now + 0.25);
      break;
    }
    case 'coin': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(NOTE.E5, now);
      o.frequency.setValueAtTime(NOTE.A5, now + 0.08);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o.start(now); o.stop(now + 0.2);
      break;
    }
    case 'dodge': {
      const { o, g } = createSFXNode('sine', sfxGain);
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
      o.start(now); o.stop(now + 0.12);
      break;
    }
    case 'boss_appear': {
      for (let i = 0; i < 4; i++) {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.setValueAtTime([NOTE.C4, NOTE.E4, NOTE.G4, NOTE.C5][i], now + i * 0.12);
        g.gain.setValueAtTime(0.2, now + i * 0.12);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.2);
      }
      break;
    }
    case 'death': {
      for (let i = 0; i < 5; i++) {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.setValueAtTime(300 - i * 40, now + i * 0.15);
        g.gain.setValueAtTime(0.2, now + i * 0.15);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
        o.start(now + i * 0.15); o.stop(now + i * 0.15 + 0.25);
      }
      break;
    }
    case 'victory_jingle': {
      const melody = [NOTE.C5, NOTE.E5, NOTE.G5, NOTE.C6, NOTE.G5, NOTE.C6];
      melody.forEach((f, i) => {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.2, now + i * 0.12);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.2);
      });
      break;
    }
    case 'helper': {
      const { o, g } = createSFXNode('triangle', sfxGain);
      o.frequency.setValueAtTime(NOTE.G4, now);
      o.frequency.setValueAtTime(NOTE.C5, now + 0.08);
      o.frequency.setValueAtTime(NOTE.E5, now + 0.16);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      o.start(now); o.stop(now + 0.3);
      break;
    }
    case 'perfect_dodge': {
      const { o, g } = createSFXNode('sine', sfxGain);
      o.frequency.setValueAtTime(NOTE.C5, now);
      o.frequency.setValueAtTime(NOTE.E5, now + 0.06);
      o.frequency.setValueAtTime(NOTE.G5, now + 0.12);
      o.frequency.setValueAtTime(NOTE.C6, now + 0.18);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      o.start(now); o.stop(now + 0.3);
      break;
    }
    case 'stomp': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(120, now);
      o.frequency.exponentialRampToValueAtTime(50, now + 0.15);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o.start(now); o.stop(now + 0.2);
      break;
    }
  }
}

// ==========================================
// MUSIC TRACKS - Chiptune style
// ==========================================

// Each track: array of { melody, bass, tempo (BPM) }
// Melody/bass: arrays of [note, duration_in_beats]

const TRACKS = {
  // Menu: Roman saltarello - dramatic minor, Mediterranean ornaments
  menu: {
    tempo: 125,
    melody: [
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],[NOTE.E4,1],
      [NOTE.F4,1],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.C4,1],[NOTE.D4,1],
      [NOTE.E4,1],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,2],[NOTE.R,1],[NOTE.D4,1],
      [NOTE.A4,1],[NOTE.C5,1],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.F4,1],[NOTE.E4,1],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.D4,1],[NOTE.E4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.E3,1],[NOTE.A3,1],[NOTE.D3,2],[NOTE.A3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.D3,2],[NOTE.E3,2],
      [NOTE.A3,1],[NOTE.E3,1],[NOTE.A3,2],[NOTE.F3,2],[NOTE.E3,2],
      [NOTE.D3,2],[NOTE.E3,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Hub (Bar Vanni): warm mandolin arpeggios, relaxed Italian bar
  hub: {
    tempo: 105,
    melody: [
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.E4,0.5],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.B4,0.5],[NOTE.G4,0.5],[NOTE.D4,0.5],[NOTE.G4,1],
      [NOTE.F4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.F4,0.5],[NOTE.C4,0.5],[NOTE.F4,1],
      [NOTE.E4,0.5],[NOTE.Ab4,0.5],[NOTE.B4,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],
      [NOTE.G4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.E4,1],
      [NOTE.F4,0.5],[NOTE.A4,0.5],[NOTE.C5,1],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.E3,2],[NOTE.G3,2],[NOTE.D3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.E3,2],[NOTE.B3,2],
      [NOTE.A3,2],[NOTE.E3,2],[NOTE.G3,2],[NOTE.D3,2],
      [NOTE.F3,2],[NOTE.E3,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'triangle',
    bassWave: 'sine'
  },

  // Level (goon fight): fast tarantella, driving rhythm
  level: {
    tempo: 165,
    melody: [
      [NOTE.A4,0.5],[NOTE.B4,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,1],[NOTE.C5,0.5],[NOTE.D5,0.5],
      [NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.A5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,1],
      [NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,1],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.D5,1],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.B4,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.R,1],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,1],
      [NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],[NOTE.F3,1],
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,1],
      [NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'square',
    bassWave: 'square'
  },

  // Boss: LaFed (rugby rapper) - swaggering rhythm, cocky melody
  boss_lafed: {
    tempo: 150,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.G4,0.5],[NOTE.A4,1],[NOTE.R,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.E4,0.5],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.D5,1],[NOTE.C5,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.E4,1],[NOTE.R,1],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,1],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.E4,1],[NOTE.D4,1],
      [NOTE.E4,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,1],[NOTE.G4,0.5],[NOTE.E4,0.5],
      [NOTE.D4,1],[NOTE.E4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.G3,1],[NOTE.R,0.5],[NOTE.G3,0.5],
      [NOTE.F3,1],[NOTE.R,0.5],[NOTE.F3,0.5],[NOTE.E3,1],[NOTE.R,0.5],[NOTE.E3,0.5],
      [NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.D3,1],[NOTE.R,0.5],[NOTE.D3,0.5],
      [NOTE.E3,1],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'square'
  },

  // Boss: Gioacchino (pub brawler) - dark, menacing waltz-like, heavy
  boss_gioacchino: {
    tempo: 140,
    melody: [
      [NOTE.D4,1],[NOTE.F4,1],[NOTE.A4,1],[NOTE.D5,1],[NOTE.Cs5,0.5],[NOTE.D5,0.5],
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.F4,1],
      [NOTE.E4,1],[NOTE.F4,0.5],[NOTE.G4,0.5],[NOTE.A4,1],[NOTE.Bb4,1],
      [NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.D4,2],
      [NOTE.D5,1],[NOTE.Cs5,0.5],[NOTE.D5,0.5],[NOTE.F5,1],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.Cs5,1],[NOTE.A4,1],[NOTE.Bb4,1],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.F4,1],
      [NOTE.E4,1],[NOTE.D4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.D3,2],[NOTE.A3,2],[NOTE.Bb3,2],[NOTE.A3,2],
      [NOTE.G3,2],[NOTE.D3,2],[NOTE.E3,2],[NOTE.A3,2],
      [NOTE.D3,2],[NOTE.F3,2],[NOTE.Bb3,2],[NOTE.A3,2],
      [NOTE.G3,2],[NOTE.A3,2],[NOTE.D3,2],[NOTE.R,2],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Boss: Il Dale (dumb brute) - slow, heavy stomps, simple but crushing
  boss_dale: {
    tempo: 120,
    melody: [
      [NOTE.E4,2],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,2],
      [NOTE.R,1],[NOTE.A3,0.5],[NOTE.E4,0.5],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.A4,2],[NOTE.R,1],[NOTE.A4,0.5],[NOTE.Bb4,0.5],
      [NOTE.A4,1],[NOTE.G4,1],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.D4,2],[NOTE.R,1],[NOTE.D4,0.5],[NOTE.E4,0.5],
      [NOTE.F4,1],[NOTE.E4,1],[NOTE.D4,1],[NOTE.C4,1],
      [NOTE.E4,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.F4,1],
      [NOTE.E4,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.R,2],[NOTE.A3,2],[NOTE.R,2],
      [NOTE.F3,2],[NOTE.R,2],[NOTE.E3,2],[NOTE.R,2],
      [NOTE.D3,2],[NOTE.R,2],[NOTE.D3,2],[NOTE.R,2],
      [NOTE.E3,2],[NOTE.R,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Boss: Ciccio Ruver (fiery pizzaiolo) - fast, fiery tarantella, aggressive
  boss_ciccio: {
    tempo: 180,
    melody: [
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.A5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],
      [NOTE.D5,0.5],[NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.F5,0.5],[NOTE.D5,0.5],[NOTE.A4,0.5],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,1],
      [NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,0.5],[NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,1],[NOTE.R,1],
      [NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.A5,1],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.R,1],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],
      [NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],
      [NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,1],
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],
      [NOTE.A3,1],[NOTE.E3,1],[NOTE.A3,1],[NOTE.D3,1],
      [NOTE.F3,1],[NOTE.E3,1],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'square'
  },

  // Boss: Pisellino (final boss) - chaotic, manic, shifting tempo feel, unhinged
  boss_pisellino: {
    tempo: 185,
    melody: [
      [NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],
      [NOTE.A4,1],[NOTE.R,0.5],[NOTE.C4,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],
      [NOTE.B4,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.Ab4,0.5],[NOTE.B4,0.5],
      [NOTE.C5,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],
      [NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],
      [NOTE.A4,1],[NOTE.R,0.5],[NOTE.C4,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],
      [NOTE.B4,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.B4,0.5],
      [NOTE.A4,1],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.A4,0.5],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],
      [NOTE.F3,0.5],[NOTE.R,0.5],[NOTE.F3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'sawtooth'
  },

  // LaFed buildup: cocky swagger, rhythmic hip-hop drums feel
  boss_buildup_0: {
    tempo: 90,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.R,1.5],[NOTE.G4,0.5],[NOTE.R,0.5],
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.A4,1],[NOTE.R,1],[NOTE.G4,0.5],[NOTE.E4,0.5],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.Bb4,1],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.E4,0.5],[NOTE.A4,2],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A2,1],[NOTE.R,1],[NOTE.E3,1],[NOTE.R,1],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.A2,1],[NOTE.R,1],
    ],
    melodyWave: 'square',
    bassWave: 'square'
  },

  // Gioacchino buildup: dark prison march, heavy stomps
  boss_buildup_1: {
    tempo: 70,
    melody: [
      [NOTE.D4,2],[NOTE.R,2],[NOTE.D4,1],[NOTE.F4,1],[NOTE.R,2],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.Bb3,1],[NOTE.A3,1],[NOTE.R,2],[NOTE.D4,2],
      [NOTE.F4,1],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.Cs4,2],[NOTE.D4,2],
      [NOTE.A3,1],[NOTE.D4,1],[NOTE.F4,1],[NOTE.A4,1],[NOTE.R,2],[NOTE.D4,2],
    ],
    bass: [
      [NOTE.D3,2],[NOTE.R,2],[NOTE.D3,2],[NOTE.R,2],
      [NOTE.A2,2],[NOTE.R,2],[NOTE.D3,1],[NOTE.R,1],[NOTE.D3,1],[NOTE.R,1],
      [NOTE.D3,1],[NOTE.R,0.5],[NOTE.D3,0.5],[NOTE.R,1],[NOTE.A2,1],[NOTE.D3,1],[NOTE.R,1],
      [NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.A2,1],[NOTE.D3,1],[NOTE.R,2],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Dale buildup: exotic capoeira percussion, rhythmic and tense
  boss_buildup_2: {
    tempo: 80,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.D4,0.5],[NOTE.R,0.5],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.G4,0.5],[NOTE.F4,0.5],[NOTE.E4,1],[NOTE.R,1],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,1],
    ],
    melodyWave: 'triangle',
    bassWave: 'square'
  },

  // Ciccio buildup: furnace inferno, rising heat, heavy tremolo
  boss_buildup_3: {
    tempo: 95,
    melody: [
      [NOTE.A3,1],[NOTE.R,1],[NOTE.A3,0.5],[NOTE.Bb3,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],
      [NOTE.C4,1],[NOTE.R,1],[NOTE.C4,0.5],[NOTE.D4,0.5],[NOTE.C4,0.5],[NOTE.R,0.5],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.E4,1],[NOTE.A4,1],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'sawtooth'
  },

  // Pisellino buildup: manic chaos, unhinged tritones, building dread
  boss_buildup_4: {
    tempo: 85,
    melody: [
      [NOTE.A3,2],[NOTE.R,2],[NOTE.Bb3,1],[NOTE.A3,1],[NOTE.R,2],
      [NOTE.E4,1],[NOTE.R,1],[NOTE.F4,1],[NOTE.E4,0.5],[NOTE.Eb4,0.5],[NOTE.E4,2],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.Eb4,2],[NOTE.R,1],[NOTE.A3,1],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.A4,2],[NOTE.Bb4,1],[NOTE.A4,1],
    ],
    bass: [
      [NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.E3,1],[NOTE.R,1],[NOTE.E3,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.A2,1],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,1],[NOTE.E3,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Victory: triumphant Roman fanfare, major key celebration
  victory: {
    tempo: 140,
    melody: [
      [NOTE.C5,1],[NOTE.E5,1],[NOTE.G5,1],[NOTE.C6,2],
      [NOTE.B5,0.5],[NOTE.A5,0.5],[NOTE.G5,1],[NOTE.E5,1],
      [NOTE.F5,1],[NOTE.G5,1],[NOTE.A5,1],[NOTE.G5,1],
      [NOTE.E5,1],[NOTE.C5,1],[NOTE.D5,1],[NOTE.E5,1],
      [NOTE.C5,1],[NOTE.E5,1],[NOTE.G5,1],[NOTE.C6,1],
      [NOTE.A5,1],[NOTE.G5,1],[NOTE.E5,1],[NOTE.C5,1],
      [NOTE.D5,1],[NOTE.E5,1],[NOTE.G5,2],
      [NOTE.C5,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.C3,2],[NOTE.G3,2],[NOTE.C3,2],[NOTE.E3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.G3,2],[NOTE.C3,2],
      [NOTE.C3,2],[NOTE.G3,2],[NOTE.A3,2],[NOTE.E3,2],
      [NOTE.F3,2],[NOTE.G3,2],[NOTE.C3,4],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Game over: somber Roman lament
  gameover: {
    tempo: 75,
    melody: [
      [NOTE.A4,2],[NOTE.Ab4,1],[NOTE.A4,1],[NOTE.G4,2],[NOTE.F4,2],
      [NOTE.E4,2],[NOTE.D4,2],[NOTE.C4,2],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A3,4],[NOTE.R,4],
    ],
    bass: [
      [NOTE.A3,4],[NOTE.F3,4],[NOTE.D3,4],[NOTE.E3,2],[NOTE.A3,2],
      [NOTE.R,4],
    ],
    melodyWave: 'triangle',
    bassWave: 'sine'
  },

  // Sabi mode: cute, warm, playful Animal Crossing / Stardew Valley vibe
  sabi: {
    tempo: 110,
    melody: [
      // Playful C major arpeggios — bouncy and cheerful
      [NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.G5,0.5],[NOTE.C6,0.5],
      [NOTE.B5,0.5],[NOTE.G5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.C6,0.5],[NOTE.A5,0.5],
      [NOTE.G5,1],[NOTE.E5,0.5],[NOTE.C5,0.5],
      [NOTE.D5,0.5],[NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.G5,0.5],
      [NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,0.5],
      [NOTE.C5,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.B4,0.5],
      [NOTE.C5,1],[NOTE.E5,0.5],[NOTE.G5,0.5],
    ],
    bass: [
      // Gentle bouncy bass
      [NOTE.C3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
      [NOTE.E3,1],[NOTE.G3,0.5],[NOTE.E3,0.5],
      [NOTE.F3,1],[NOTE.C3,0.5],[NOTE.F3,0.5],
      [NOTE.G3,1],[NOTE.C3,0.5],[NOTE.G3,0.5],
      [NOTE.A3,1],[NOTE.E3,0.5],[NOTE.A3,0.5],
      [NOTE.F3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
      [NOTE.D3,1],[NOTE.G3,0.5],[NOTE.D3,0.5],
      [NOTE.C3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  }
};

// Music player
let melodyTimeout = null;
let bassTimeout = null;
let activeMelodyOsc = null;
let activeBassOsc = null;
let activeMelodyGain = null;
let activeBassGain = null;
let currentTrackName = '';
let musicHeartbeat = 0; // frames since last melody note scheduled
let lastMusicCheckTime = 0;
let musicGeneration = 0; // incremented on each playTrack call to kill old scheduler chains

function stopMusic() {
  musicPlaying = false;
  currentTrackName = '';
  clearTimeout(melodyTimeout);
  clearTimeout(bassTimeout);
  try {
    if (activeMelodyOsc) { activeMelodyOsc.onended = null; activeMelodyOsc.stop(); activeMelodyOsc.disconnect(); activeMelodyOsc = null; }
    if (activeBassOsc) { activeBassOsc.onended = null; activeBassOsc.stop(); activeBassOsc.disconnect(); activeBassOsc = null; }
    if (activeMelodyGain) { activeMelodyGain.disconnect(); activeMelodyGain = null; }
    if (activeBassGain) { activeBassGain.disconnect(); activeBassGain = null; }
  } catch(e) {}
}

function playTrack(name) {
  if (!audioCtx || !audioStarted || !musicEnabled) return;
  // If same track and playing, check heartbeat for stalled music
  if (currentTrackName === name && musicPlaying) {
    musicHeartbeat++;
    if (musicHeartbeat > 300) { // ~5 seconds without a note = stalled
      musicPlaying = false; // force restart
    } else {
      return;
    }
  }

  stopMusic();
  const track = TRACKS[name];
  if (!track) return;

  currentTrackName = name;
  musicPlaying = true;
  musicGeneration++; // kill any old scheduler chains
  const gen = musicGeneration;

  const beatLen = 60 / track.tempo;

  // Play melody voice
  function scheduleMelody(noteIndex) {
    if (gen !== musicGeneration) return; // old chain from previous playTrack — die
    if (!musicPlaying || currentTrackName !== name) return;
    if (noteIndex >= track.melody.length) noteIndex = 0;
    musicHeartbeat = 0; // reset heartbeat on each note

    const [freq, dur] = track.melody[noteIndex];
    const durMs = dur * beatLen * 1000;

    try {
      if (activeMelodyOsc) { activeMelodyOsc.stop(); activeMelodyOsc.disconnect(); }
      if (activeMelodyGain) { activeMelodyGain.disconnect(); }
    } catch(e) {}

    if (freq > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = track.melodyWave || 'square';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime + dur * beatLen * 0.3);
      gain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + dur * beatLen * 0.95);
      osc.connect(gain);
      gain.connect(musicGain);
      osc.start();
      osc.onended = () => { try { gain.disconnect(); osc.disconnect(); } catch(e) {} };
      activeMelodyOsc = osc;
      activeMelodyGain = gain;
      setTimeout(() => { try { osc.stop(); } catch(e) {} }, durMs + 50);
    }

    melodyTimeout = setTimeout(() => scheduleMelody(noteIndex + 1), durMs);
  }

  // Play bass voice
  function scheduleBass(noteIndex) {
    if (gen !== musicGeneration) return; // old chain from previous playTrack — die
    if (!musicPlaying || currentTrackName !== name) return;
    if (noteIndex >= track.bass.length) noteIndex = 0;

    const [freq, dur] = track.bass[noteIndex];
    const durMs = dur * beatLen * 1000;

    try {
      if (activeBassOsc) { activeBassOsc.stop(); activeBassOsc.disconnect(); }
      if (activeBassGain) { activeBassGain.disconnect(); }
    } catch(e) {}

    if (freq > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = track.bassWave || 'triangle';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.14, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + dur * beatLen * 0.9);
      osc.connect(gain);
      gain.connect(musicGain);
      osc.start();
      osc.onended = () => { try { gain.disconnect(); osc.disconnect(); } catch(e) {} };
      activeBassOsc = osc;
      activeBassGain = gain;
      setTimeout(() => { try { osc.stop(); } catch(e) {} }, durMs + 50);
    }

    bassTimeout = setTimeout(() => scheduleBass(noteIndex + 1), durMs);
  }

  scheduleMelody(0);
  scheduleBass(0);
}

// Toggle music with M key
window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    musicEnabled = !musicEnabled;
    if (!musicEnabled) stopMusic();
  }
});

// ==========================================
// GAME STATE
// ==========================================
let state = 'menu'; // menu, difficultySelect, tutorial, weaponSelect, hub, dialogue, level, shop, upgrade, gameover, victory
let difficulty = 'medium'; // 'easy', 'medium', 'hard'
const DIFF_HP = { easy: 0.7, medium: 0.9, hard: 1.0 };
const DIFF_DMG = { easy: 0.6, medium: 0.85, hard: 0.935 };
let tutorialStep = 0;
let tutorialDummy = null;
let tutorialTimer = 0;
let firstTime = true;
let cheatBuffer = '';
let showCredits = false;
let codeInput = '';
let freestylePlaying = false;
const freestyleOverlay = document.getElementById('freestyle-overlay');
const freestyleVideo = document.getElementById('freestyle-video');

function startFreestyleVideo() {
  freestylePlaying = true;
  freestyleOverlay.classList.add('active');
  freestyleVideo.currentTime = 0;
  freestyleVideo.play();
  stopMusic();
}

function stopFreestyleVideo() {
  freestylePlaying = false;
  freestyleOverlay.classList.remove('active');
  freestyleVideo.pause();
  freestyleVideo.currentTime = 0;
}

// Close video on ESC
document.addEventListener('keydown', function(e) {
  if (e.code === 'Escape' && freestylePlaying) {
    stopFreestyleVideo();
    e.preventDefault();
  }
});

// When video ends, return to game
freestyleVideo.addEventListener('ended', function() {
  stopFreestyleVideo();
});
let currentLevel = 0;
let coins = 0;
let lives = 3;
let totalKills = 0;
let dialogueLines = [];
let dialogueIndex = 0;
let dialogueCallback = null;
let screenShake = 0;
let screenFlash = 0;
let flashColor = '#fff';
let gameTime = 0;
let helperCooldowns = [0, 0, 0, 0];
let bossDefeated = [false, false, false, false, false];
let particles = [];
let projectiles = [];
let goons = [];
let boss = null;
let bossPhase = 0;
let reginaActive = false;
let regina = null;
let mariusoActive = false;
let mariuso = null;

// Sabi mode state
let sabiTimer = 0;
let sabiCicca = null;
let sabiSabi = null;
let sabiTotti = null;
let sabiMessages = [];
let sabiPreviousState = 'menu';
let sabiDialogueCount = 0;
let sabiSwordUnlocked = false;

// Upgrade system
let upgradeChoices = []; // 3 choices shown after level victory
let levelScore = 0;
let stylePoints = 0;
let levelDamageTaken = 0;
let levelStartTime = 0;
let lastLevelGrade = '';
let lastLevelBreakdown = null;

const UPGRADE_POOL = [
  // Statistiche
  { name: '+15% Danno', cat: 'stat', desc: 'Tutti gli attacchi fanno 15% danno in piu\'', effect: 'dmg15', icon: '!' },
  { name: '+20 HP Max', cat: 'stat', desc: 'Aumenta la vita massima di 20', effect: 'hp20', icon: '+' },
  { name: '+20 Stamina Max', cat: 'stat', desc: 'Aumenta la stamina massima di 20', effect: 'st20', icon: 'S' },
  { name: '+25% Regen Stamina', cat: 'stat', desc: 'La stamina si ricarica 25% piu\' veloce', effect: 'stregen', icon: 'R' },
  { name: '+10% Velocita\'', cat: 'stat', desc: 'Ti muovi 10% piu\' veloce', effect: 'spd10', icon: '>' },
  { name: '+15% Critico', cat: 'stat', desc: 'Tutte le armi +15% chance critico', effect: 'crit15', icon: 'C' },
  // Mosse Nuove
  { name: 'Scatto Aereo', cat: 'mossa', desc: 'Schiva in aria (X in volo)', effect: 'airdash', icon: 'A' },
  { name: 'Schianto a Terra', cat: 'mossa', desc: 'Giu\'+Attacco in aria schianta giu\'', effect: 'groundslam', icon: 'G' },
  { name: 'Parata', cat: 'mossa', desc: 'Schiva al momento giusto = stagger gratis', effect: 'parry', icon: 'P' },
  { name: 'Combo Extra', cat: 'mossa', desc: '+1 colpo a tutte le combo', effect: 'comboext', icon: 'E' },
  // Potenziamenti Ultra — attivi solo durante modalita' Ultra (Q)
  { name: 'Ultra Fuoco', cat: 'mod', desc: 'Ultra: ogni colpo brucia il nemico (3s)', effect: 'ultraFire', icon: 'F' },
  { name: 'Ultra Ghiaccio', cat: 'mod', desc: 'Ultra: ogni colpo rallenta il nemico del 30% (3s)', effect: 'ultraIce', icon: 'I' },
  { name: 'Ultra Fulmine', cat: 'mod', desc: 'Ultra: ogni colpo fulmina un nemico vicino', effect: 'ultraShock', icon: 'Z' },
  { name: 'Ultra Vampiro', cat: 'mod', desc: 'Ultra: cura 8% del danno inflitto', effect: 'ultraVampire', icon: 'V' },
];
let levelTimer = 0;
let comboCount = 0;
let comboTimer = 0;
let damageNumbers = [];
let selectedHelper = -1;
let hitstopFrames = 0;
let dodgeCounter = 0;
let phaseTransitionTimer = 0;
let phaseTransitionText = '';
let phaseTransitionColor = '#e94560';
let waveClearTimer = 0;
let currentWave = 0;
let waveBreatherTimer = 0;
let waveConfig = []; // array of enemy counts per wave

// ==========================================
// PLAYER
// ==========================================
const player = {
  x: 100, y: 400, w: 36, h: 56,
  vx: 0, vy: 0,
  hp: 120, maxHp: 120,
  stamina: 100, maxStamina: 100,
  speed: 4.0,
  weapon: 0, // always 0 — weapons[0] is current weapon
  facing: 1, // 1 right, -1 left
  attacking: false,
  attackTimer: 0,
  attackCooldown: 0,
  dodging: false,
  dodgeTimer: 0,
  dodgeCooldown: 0,
  invincible: 0,
  grounded: true,
  animFrame: 0,
  animTimer: 0,
  stunTimer: 0,
  speedBoost: 0,
  dead: false,
  // Combo chain state
  comboStep: 0,        // current hit in chain (0 = not attacking)
  comboWindowTimer: 0, // frames left in combo window to chain next hit
  endLagTimer: 0,      // frames of end-lag after combo finishes/drops
  attackBuffered: false,// input buffer for next combo hit
  attackActiveTimer: 0, // frames left of active hitbox
  comboChainCount: 0,  // number of full combo chains completed without getting hit (for coin bonus)
  jumpAttacking: false, // aerial attack flag
  // Stamina
  staminaRegenDelay: 0, // frames until stamina starts regenerating
  exhaustedTimer: 0, // can't attack while exhausted
  sameTargetHits: 0, // same-target damage penalty
  sameTargetTimer: 0, // frames since last hit on same target
  lastHitTarget: null,
  reloadTimer: 0, // ammo reload countdown for ranged weapons
  consumables: [],
  consumableTimers: {},
  // Grab system
  grabbing: false,
  grabbedEnemy: null,
  grabTimer: 0,
  // Combo counter (scoring)
  comboHitCount: 0,
  comboHitTimer: 0,
  scoreMultiplier: 1,
  // Upgrades
  upgrades: [],
  // Ultra system
  ultraCharge: 0, ultraMaxCharge: 100, ultraActive: false,
  ultraTimer: 0, ultraDuration: 300, ultraAvailable: false
};

// Weapons — each has a unique feel via combo count, poise damage, and a special mechanic
// comboHits: number of hits in combo chain
// poise: poise damage per hit
// activeFrames: frames the hitbox is out per hit
// comboWindow: frames after active ends where you can chain
// endLag: frames of end-lag after last hit (dropped combo = 8-12)
// special: unique mechanic identifier

// 4 starter weapons — player picks one at game start
const starterWeapons = [
  { name: 'Sanpietrino',    damage: 16, range: 50,  speed: 7,  crit: 18,
    comboHits: 4, poise: 8, activeFrames: 6, comboWindow: 13, endLag: 13,
    special: 'critCombo', desc: 'Veloce, 4 colpi. Crit cresce nel combo.',
    color: '#9e9e9e', icon: 'S' },
  { name: 'Cacciavite',     damage: 16, range: 48,  speed: 10, crit: 10,
    comboHits: 3, poise: 8, activeFrames: 7, comboWindow: 13, endLag: 18,
    special: 'bleed', desc: 'Bilanciato. Ultra: sanguinamento.',
    color: '#ff8a65', icon: 'C' },
  { name: 'Spranga',        damage: 22, range: 65,  speed: 14, crit: 5,
    comboHits: 3, poise: 14, activeFrames: 8, comboWindow: 13, endLag: 22,
    special: 'reachControl', desc: 'Pesante, lungo raggio. Colpo doppio.',
    color: '#795548', icon: 'P' },
  { name: 'Fionda',         damage: 10, range: 180, speed: 16, crit: 8,
    comboHits: 3, poise: 2, activeFrames: 6, comboWindow: 10, endLag: 20,
    special: 'pierce', desc: 'Ranged. Il 3o colpo perfora.', ranged: true,
    color: '#a1887f', icon: 'F', maxAmmo: 5, reloadFrames: 90 }
];

// Rare weapons (from gacha)
const rareWeapons = [
  { name: 'Machete',        damage: 24, range: 55,  speed: 12, crit: 10,
    comboHits: 3, poise: 12, activeFrames: 7, comboWindow: 16, endLag: 20,
    special: 'executioner', desc: 'Ultra: 2x danno su nemici sotto 25% HP.',
    color: '#b0bec5', icon: 'M' },
  { name: 'Catena',         damage: 20, range: 85,  speed: 18, crit: 8,
    comboHits: 3, poise: 15, activeFrames: 10, comboWindow: 18, endLag: 22,
    special: 'crowdPull', desc: 'Sempre AoE. Ultra: attira nemici vicini.',
    color: '#757575', icon: 'K' },
  { name: 'Bottiglia Rotta',damage: 20, range: 38,  speed: 6,  crit: 25,
    comboHits: 3, poise: 6, activeFrames: 5, comboWindow: 12, endLag: 18,
    special: 'bleed', desc: 'Rapidissima, alta crit. Ultra: sanguinamento.',
    color: '#4caf50', icon: 'B' }
];

// Legendary weapons (from gacha, very rare)
const legendaryWeapons = [
  { name: 'La Lupa',        damage: 38, range: 65,  speed: 10, crit: 30,
    comboHits: 3, poise: 18, activeFrames: 8, comboWindow: 16, endLag: 20,
    special: 'legendaryShockwave', desc: 'Ultra: onda d\'urto devastante.',
    color: '#ffd700', icon: 'L' },
  { name: 'Pistola del Nonno', damage: 30, range: 300, speed: 20, crit: 20,
    comboHits: 3, poise: 5, activeFrames: 6, comboWindow: 14, endLag: 20,
    special: 'pierce', desc: 'Ranged leggendaria. Tutti i colpi perforano.', ranged: true,
    color: '#333', icon: 'G', maxAmmo: 4, reloadFrames: 75 }
];

// Active weapon — single-element array, weapons[0] is always current weapon
let weapons = [starterWeapons[0]]; // default, replaced at weapon select

// Weapon selection state
let weaponSelectIndex = 0;
let weaponSelectReady = false;
let weaponSelectTimer = 0;
let helperSelectIndex = 0;
let helperSelectReady = false;
let helperSelectTimer = 0;

// Weapon upgrade tier (0-3)
let weaponTier = 0;
const WEAPON_UPGRADE_COSTS = [150, 300, 500];

// Player stat upgrade tiers (0-3 each), purchased in shop tab 3
let jumpTier = 0, dodgeTier = 0, speedTier = 0;
const STAT_UPGRADE_COSTS = [150, 300, 550];
const JUMP_FORCES = [-13.0, -14.2, -15.4, -16.5];
const DODGE_COOLDOWNS = [48, 40, 33, 26];
const SPEED_VALUES = [4.0, 4.4, 4.8, 5.3];

// Shop tab: 0 = Potenzia Arma, 1 = Potenzia Helper, 2 = La Ruota, 3 = Potenzia Stats
let shopTab = 0;

// Gacha state
let gachaSpinning = false;
let gachaSpinTimer = 0;
let gachaResult = null;
let gachaResultTimer = 0;
const GACHA_COST = 120;

const gachaJokes = [
  '"Aho, ma che te credevi? T\'hanno fregato!"',
  '"Niente, come la Roma in Champions."',
  '"Vanni: \'Riprova, va\'... tanto li sordi so\' mia.\'"',
  '"Hai vinto... \'na bella presa per culo."',
  '"Gira gira... e niente. Come er 64 ar capolinea."',
  '"Ma che giri a vuoto come \'na lavatrice!"',
  '"Vanni se sta a ride... de te."',
  '"Hai beccato l\'aria de Roma Nord. Congratulazioni."',
  '"Come dice mi nonna: chi nun risica, perde lo stesso."',
  '"Jackpot de niente! Come trovà posto ar Pigneto er sabato."'
];

// Consumable items
const consumableItems = [
  { name: 'Supplì', desc: '+30 HP', color: '#ff8f00', effect: 'heal', value: 30, icon: 'S' },
  { name: 'Caffè', desc: 'Stamina gratis 10s', color: '#4e342e', effect: 'freeStamina', value: 600, icon: 'E' },
  { name: 'Cornetto', desc: '+30% danno 15s', color: '#ffcc80', effect: 'dmgBoost', value: 900, icon: 'O' }
];

const helpers = [
  { name: 'Pirox', desc: 'STUN tutti 2s', cooldown: 720, color: '#e040fb', icon: 'P', tier: 0, unlocked: false, unlockCost: 80,
    tiers: [
      { cost: 100, desc: 'Stun +50%, area piu\' grande' },
      { cost: 200, desc: 'Spacca poise: 3x danno poise' },
      { cost: 350, desc: 'Raduno: nemici stunnati -30% poise' }
    ]},
  { name: 'Tommy', desc: 'Coltellata al boss', cooldown: 900, color: '#ff6e40', icon: 'T', tier: 0, unlocked: false, unlockCost: 80,
    tiers: [
      { cost: 100, desc: 'Danno +50%, attacca piu\' spesso' },
      { cost: 200, desc: 'Combo assist: attacca staggerati' },
      { cost: 350, desc: 'Grido: +30% danno per 4s ogni 30s' }
    ]},
  { name: 'Cicca', desc: 'Cura +35 HP', cooldown: 540, color: '#212121', icon: 'C', tier: 0, unlocked: false, unlockCost: 80,
    tiers: [
      { cost: 100, desc: 'Cura +50%' },
      { cost: 200, desc: 'Buff attacco: +20% danno per 5s' },
      { cost: 350, desc: 'Revive: auto-cura se muori (1x)' }
    ]},
  { name: 'Il Mostro', desc: 'Speed x2 8sec', cooldown: 720, color: '#76ff03', icon: 'M', tier: 0, unlocked: false, unlockCost: 80,
    tiers: [
      { cost: 100, desc: 'Durata speed +50%' },
      { cost: 200, desc: 'Speed +20% velocita\' attacco' },
      { cost: 350, desc: 'Scia: lasci danno quando boost' }
    ]},
];
let helperReviveUsed = false; // Cicca tier 3 one-time per level
let warCryTimer = 0; // Tommy tier 3 buff timer
let warCryCooldown = 0; // Tommy tier 3 cooldown

// ==========================================
// LEVEL DATA
// ==========================================
const levels = [
  {
    name: 'Via Plava',
    boss: 'LaFed',
    bossColor: '#ffd54f',
    bossHp: 300,
    subtitle: 'Il rugbista narcisista',
    bgColor: '#1a1a30',
    groundColor: '#3a3a4a',
    goonCount: 3,
    music: 'level1',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 1.25, spranga: 0.85, fionda: 0.7 },
    bossLines: [
      '"Ao\', ma lo sai chi so\' io?"',
      '"Sono pazzo... sono pazzo di te..."',
      '"Sei la mia musa e per questo che resto!"',
      '"Preparate Conte, che te asfarto!"'
    ],
    defeatLines: [
      '"No... i miei capelli... il mio gel..."',
      '"Aspetta che me rifaccio la riga..."'
    ]
  },
  {
    name: 'Down Under Pub',
    boss: 'Gioacchino',
    bossColor: '#6d4c41',
    bossHp: 440,
    subtitle: 'Il bastone e la sorella',
    bgColor: '#1b2631',
    groundColor: '#2c3e50',
    goonCount: 4,
    music: 'level2',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 0.85, spranga: 1.3, fionda: 1.0 },
    bossLines: [
      '"Ao\' Conte, in gabbia c\'ho imparato a mena\'!"',
      '"REGINAAAA! Famme \'n pezzo de carneeee!"',
      '"Te faccio vede\' come se gioca ar quartiere!"',
      '"So\' stato in gabbia 3 anni, nun me fai paura!"'
    ],
    defeatLines: [
      '"Regina... me rimanneno in gabbia..."',
      '"Torno ar pub a beve\'... o forse in cella..."'
    ]
  },
  {
    name: 'Piazza Bainsizza',
    boss: 'Il Dale',
    bossColor: '#90a4ae',
    bossHp: 530,
    subtitle: 'La capoeira de Piazza Bainsizza',
    bgColor: '#263238',
    groundColor: '#37474f',
    goonCount: 5,
    music: 'level3',
    weaponMatchups: { sanpietrino: 1.25, cacciavite: 1.0, spranga: 0.85, fionda: 0.75 },
    bossLines: [
      '"Te faccio vede\' er giro der Dale!"',
      '"Capoeira de strada, Conte! Rimbalzo sui muri!"',
      '"Dale! Dale! DALEEEE! Nun te fermi mai!"'
    ],
    defeatLines: [
      '"Ma... so\' caduto dar muro..."',
      '"Vabbè me ne torno a gira\' in piazza..."'
    ]
  },
  {
    name: 'Pizzarium',
    boss: 'Ciccio Ruver',
    bossColor: '#ff7043',
    bossHp: 620,
    subtitle: 'Il pizzaiolo col mohawk',
    bgColor: '#3e2723',
    groundColor: '#4e342e',
    goonCount: 5,
    music: 'level4',
    weaponMatchups: { sanpietrino: 0.85, cacciavite: 1.0, spranga: 1.0, fionda: 1.2 },
    bossLines: [
      '"A\' Conte! Te faccio na pizza speciale!"',
      '"Margherita in faccia, offering del giorno!"',
      '"Col mohawk ce spacco, col forno pure!"'
    ],
    defeatLines: [
      '"La pizza... fredda... come il mio cuore..."',
      '"Chi gestisce er Pizzarium mo\'?!"'
    ]
  },
  {
    name: 'Piazza Mazzini',
    boss: 'Pisellino',
    bossColor: '#b0bec5',
    bossHp: 920,
    subtitle: 'Il fantasma di Valle Aurelia',
    bgColor: '#0d0d1a',
    groundColor: '#1a1a2e',
    goonCount: 6,
    music: 'level5',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 1.1, spranga: 1.1, fionda: 0.6 },
    bossLines: [
      '"Yo Conte... you think you\'re ready? Nun ce crede manco te..."',
      '"I\'m the final boss bro, er Pisellino non perdona"',
      '"MARIUSOOO! Uncle! Come help me destroy this kid!"',
      '"This is MY piazza, capito? Piazza Mazzini is MINE"'
    ],
    defeatLines: [
      '"No way bro... impossible... ma come..."',
      '"Uncle Mariuso... we lost... it\'s over zio..."',
      '"GG Conte... you earned Piazza Mazzini... for now..."'
    ]
  }
];

// Weapon matchup system: maps weapon name → matchup category
function getWeaponMatchupKey(weaponName) {
  const n = weaponName.toLowerCase();
  if (n === 'sanpietrino') return 'sanpietrino';
  if (n === 'cacciavite' || n === 'machete' || n === 'bottiglia rotta') return 'cacciavite';
  if (n === 'spranga' || n === 'catena' || n === 'la lupa') return 'spranga';
  if (n === 'fionda' || n === 'pistola del nonno') return 'fionda';
  return 'sanpietrino'; // fallback
}

function getBossMatchupMult() {
  const lvl = levels[currentLevel];
  if (!lvl || !lvl.weaponMatchups) return 1;
  const key = getWeaponMatchupKey(weapons[player.weapon].name);
  return lvl.weaponMatchups[key] || 1;
}

// ==========================================
// ENVIRONMENTAL HAZARDS (one per level)
// ==========================================
let hazards = [];
const HAZARD_DEFS = [
  // L0: Puddle — slows movement 30%
  { type: 'puddle', x: 450, y: 426, w: 100, h: 8, color: '#1565c0', label: 'PUDDLE' },
  // L1: No hazard
  null,
  // L2: Dumpster fire — periodic fire burst
  { type: 'fire', x: 350, y: 410, w: 40, h: 20, color: '#bf360c', label: 'FIRE', timer: 0 },
  // L3: Ledge — enemies near edge can be knocked off
  { type: 'ledge', x: 850, y: 430, w: 50, h: 10, color: '#ff5722', label: 'LEDGE' },
  // L4: Electrical panel — interactable AoE shock
  { type: 'panel', x: 200, y: 395, w: 30, h: 35, color: '#ffeb3b', label: 'PANEL', cooldown: 0 }
];

function initHazards(levelIdx) {
  const def = HAZARD_DEFS[levelIdx];
  if (!def) { hazards = []; return; }
  hazards = [Object.assign({}, def)];
  if (def.type === 'cart') hazards[0].hp = def.maxHp;
  if (def.type === 'panel') hazards[0].cooldown = 0;
  if (def.type === 'fire') hazards[0].timer = 0;
}

function updateHazards() {
  hazards.forEach(h => {
    if (h.type === 'puddle') {
      // Slow anyone inside
      if (Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 15) {
        player.speedBoost = Math.min(player.speedBoost, 0); // cancel speed boost
        player.x += (player.x > h.x + h.w/2 ? 1 : -1) * 0; // no push, just slow
        // Apply slow via temporary flag
        player.hazardSlow = true;
      } else {
        player.hazardSlow = false;
      }
      // Goons are not affected by puddles
      goons.forEach(g => { g.hazardSlow = false; });
    }
    if (h.type === 'cart') {
      if (h.hp <= 0) return; // already destroyed
      // Player melee can destroy it
      if (player.attackActiveTimer > 0 && Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 30) {
        h.hp -= 10;
        spawnParticles(h.x + h.w/2, h.y, '#8d6e63', 4, 2);
        if (h.hp <= 0) {
          // Drop health pickup
          spawnParticles(h.x + h.w/2, h.y, '#4caf50', 10, 4);
          player.hp = Math.min(player.maxHp, player.hp + 25);
          spawnDamageNumber(h.x + h.w/2, h.y - 20, '+25 HP', '#4caf50');
          showQuickText('Cart destroyed! +25 HP', '#4caf50');
        }
      }
      // Block movement
      if (h.hp > 0) {
        if (Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 15 && player.y >= GROUND_Y - 5) {
          player.x = player.x < h.x + h.w/2 ? h.x - 16 : h.x + h.w + 16;
        }
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < h.w/2 + 10) {
            g.x = g.x < h.x + h.w/2 ? h.x - 11 : h.x + h.w + 11;
          }
        });
      }
    }
    if (h.type === 'fire') {
      h.timer++;
      if (h.timer % 300 === 0) { // Every 5 seconds
        // Fire burst — damage anyone nearby
        const burstRange = 70;
        spawnParticles(h.x + h.w/2, h.y - 10, '#ff6f00', 20, 6);
        spawnParticles(h.x + h.w/2, h.y - 20, '#f44336', 12, 4);
        if (Math.abs(player.x - (h.x + h.w/2)) < burstRange) {
          hurtPlayer(8);
          spawnDamageNumber(player.x, player.y - 50, 'BURN!', '#ff6f00');
        }
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < burstRange) {
            g.hp -= 15;
            g.hitFlash = 10;
            spawnDamageNumber(g.x, g.y - 40, 'BURN!', '#ff6f00');
            if (g.hp <= 0 && !g.isBoss) { g.dead = true; totalKills++; }
          }
        });
      }
      // Ambient fire particles
      if (h.timer % 10 === 0) {
        spawnParticles(h.x + h.w/2 + (Math.random()-0.5)*20, h.y - 5, '#ff6f00', 2, 2);
      }
    }
    if (h.type === 'ledge') {
      // Check if any entity is knocked into the ledge area
      goons.forEach(g => {
        if (!g.dead && g.x > h.x && Math.abs(g.knockbackVx || 0) > 2) {
          g.dead = true;
          totalKills++;
          spawnParticles(g.x, g.y - 20, '#ff5722', 15, 5);
          spawnDamageNumber(g.x, g.y - 50, 'FALL!', '#ff5722');
          spawnCoinPickup(g.x - 20, g.y - 30, 10);
          playSFX('coin');
        }
      });
      // Player warning
      if (player.x > h.x - 20 && Math.abs(player.knockbackVx || 0) > 3) {
        hurtPlayer(30);
        player.x = h.x - 30;
        spawnDamageNumber(player.x, player.y - 50, 'EDGE!', '#ff5722');
      }
    }
    if (h.type === 'panel') {
      h.cooldown = Math.max(0, h.cooldown - 1);
      // Player activates with attack when near
      if (h.cooldown === 0 && player.attackActiveTimer > 0 && Math.abs(player.x - (h.x + h.w/2)) < 40) {
        h.cooldown = 1800; // 30 seconds
        // Shock all enemies in range
        const shockRange = 150;
        spawnParticles(h.x + h.w/2, h.y - 10, '#ffeb3b', 25, 8);
        screenShake = 10;
        screenFlash = 8;
        flashColor = '#ffeb3b';
        showQuickText('ELECTRIC SHOCK!', '#ffeb3b');
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < shockRange) {
            g.hp -= 25;
            g.stunTimer = Math.max(g.stunTimer || 0, 60);
            g.hitFlash = 15;
            spawnDamageNumber(g.x, g.y - 40, 'SHOCK!', '#ffeb3b');
            if (g.hp <= 0 && !g.isBoss) { g.dead = true; totalKills++; }
          }
        });
        if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0 && Math.abs(boss.x - (h.x + h.w/2)) < shockRange) {
          boss.hp -= 25;
          boss.hitFlash = 15;
          spawnDamageNumber(boss.x, boss.y - 60, 'SHOCK!', '#ffeb3b');
        }
      }
    }
  });
}

function drawHazards() {
  hazards.forEach(h => {
    if (h.type === 'puddle') {
      ctx.globalAlpha = 0.4;
      drawRect(h.x, h.y, h.w, h.h, '#1565c0');
      // Ripple effect
      ctx.globalAlpha = 0.2;
      const ripple = Math.sin(gameTime * 0.05) * 3;
      drawRect(h.x + ripple, h.y - 1, h.w - ripple * 2, 2, '#42a5f5');
      ctx.globalAlpha = 1;
    }
    if (h.type === 'cart' && h.hp > 0) {
      drawRect(h.x, h.y, h.w, h.h, '#8d6e63');
      drawRect(h.x + 2, h.y + 2, h.w - 4, 8, '#4caf50'); // fruit
      drawRect(h.x + 5, h.y + 5, 8, 6, '#f44336'); // apple
      drawRect(h.x + 18, h.y + 4, 10, 7, '#fdd835'); // banana
      drawRect(h.x + 35, h.y + 5, 8, 6, '#ff9800'); // orange
      // HP bar
      const hpPct = h.hp / h.maxHp;
      drawRect(h.x, h.y - 6, h.w, 4, '#333');
      drawRect(h.x, h.y - 6, h.w * hpPct, 4, '#4caf50');
    }
    if (h.type === 'fire') {
      drawRect(h.x, h.y, h.w, h.h, '#4e342e'); // dumpster
      drawRect(h.x + 3, h.y + 3, h.w - 6, 4, '#6d4c41');
      // Warning glow when burst is near
      const untilBurst = 300 - (h.timer % 300);
      if (untilBurst < 60) {
        ctx.globalAlpha = 0.3 + (1 - untilBurst / 60) * 0.5;
        drawRect(h.x - 20, h.y - 30, h.w + 40, h.h + 30, '#ff6f00');
        ctx.globalAlpha = 1;
      }
    }
    if (h.type === 'ledge') {
      // Danger stripes at edge
      ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.1) * 0.2;
      for (let i = 0; i < 5; i++) {
        drawRect(h.x + i * 10, GROUND_Y - 2 - i * 3, 8, 3, i % 2 ? '#ff5722' : '#ffeb3b');
      }
      ctx.globalAlpha = 1;
      drawText('DANGER', h.x + 15, GROUND_Y - 20, '#ff5722', 8, 'center');
    }
    if (h.type === 'panel') {
      drawRect(h.x, h.y, h.w, h.h, '#37474f');
      // Lightning bolt icon
      const ready = h.cooldown === 0;
      const panelColor = ready ? '#ffeb3b' : '#666';
      drawRect(h.x + 8, h.y + 5, 14, 25, panelColor);
      drawText('!', h.x + h.w/2, h.y + h.h/2 + 4, '#000', 16, 'center');
      if (!ready) {
        drawText(Math.ceil(h.cooldown / 60) + 's', h.x + h.w/2, h.y - 6, '#aaa', 8, 'center');
      } else {
        drawText('HIT', h.x + h.w/2, h.y - 6, '#ffeb3b', 8, 'center');
      }
    }
  });
}

// ==========================================
// PISELLINO DEATH TAUNTS (romanesco + english)
// ==========================================
const piselloTaunts = [
  '"Lol bro, you died? Ma sei scarso forte..."',
  '"Game over amico, torna a Vanni a piagne\'"',
  '"You call yourself il Conte? More like il Pollo hahaha"',
  '"Daje Conte retry... oh wait, sei morto again"',
  '"Bro honestly just uninstall, nun fa per te"',
  '"Rest in pepperoni Conte, aahahah get it?"',
  '"Ma che stai a fa\'? Go back to school bro"',
  '"Easy clap, too easy, er Pisellino colpisce ancora"',
  '"You thought this was gonna be easy? Welcome to Valle Aurelia baby"',
  '"Mariuso says ciao ciao, e pure io"'
];

// ==========================================
// DRAWING FUNCTIONS
// ==========================================

function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

function drawText(text, x, y, color, size, align) {
  ctx.fillStyle = color || '#fff';
  ctx.font = (size || 16) + 'px monospace';
  ctx.textAlign = align || 'left';
  ctx.fillText(text, x, y);
}

function drawPixelChar(x, y, w, h, bodyColor, headColor, features) {
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(x - 2, y + h - 4, w + 4, 6);
  // Dark outline for contrast against backgrounds
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(x + 1, y - 1, w - 2, h + 2);
  // Legs
  drawRect(x + 6, y + h - 16, 8, 16, '#333');
  drawRect(x + w - 14, y + h - 16, 8, 16, '#333');
  // Body
  drawRect(x + 2, y + 20, w - 4, h - 36, bodyColor);
  // Head
  drawRect(x + 4, y, w - 8, 22, headColor);
  // Eyes
  drawRect(x + 8, y + 8, 5, 5, '#fff');
  drawRect(x + w - 13, y + 8, 5, 5, '#fff');
  drawRect(x + 10, y + 10, 2, 2, '#111');
  drawRect(x + w - 11, y + 10, 2, 2, '#111');
  // Extra features
  if (features) features(x, y, w, h);
}

function drawConte(p) {
  const bx = p.x - p.w/2, by = p.y - p.h;
  const flip = p.facing;

  // Dodge effect
  if (p.dodging) {
    ctx.globalAlpha = 0.5;
  }
  // Invincibility flash
  if (p.invincible > 0 && Math.floor(gameTime / 4) % 2 === 0) {
    ctx.globalAlpha = 0.3;
  }

  // Bob animation
  const bob = p.grounded ? Math.sin(p.animTimer * 0.1) * 2 : -4;

  drawPixelChar(bx, by + bob, p.w, p.h, '#1a1a1a', '#ffcc80', (x, y, w, h) => {
    // AS Roma hat (dark red with gold trim)
    drawRect(x, y - 6, w, 5, '#8b0000');
    drawRect(x - 2, y - 2, w + 4, 4, '#8b0000');
    drawRect(x + 2, y - 8, 6, 3, '#ffc107'); // Roma lupetto badge
    // Hair peeking out
    drawRect(x + 2, y, w - 4, 3, '#3e2723');
    // Stone Island shirt - dark navy/black
    drawRect(x + 2, y + 20, w - 4, h - 36, '#1a1a2e');
    // Stone Island compass badge on arm
    drawRect(x + w - 6, y + 22, 8, 8, '#81c784'); // green badge
    drawRect(x + w - 4, y + 24, 4, 4, '#fff');     // compass center
    // Jacket arms
    drawRect(x - 2, y + 22, 5, 18, '#1a1a2e');
    drawRect(x + w - 3, y + 22, 5, 18, '#1a1a2e');

    // Weapon in hand
    if (p.attacking && p.attackTimer > 0) {
      const wx = flip === 1 ? x + w : x - 20;
      const wy = y + 25;
      const weap = weapons[p.weapon];
      const tier = weaponTier;
      ctx.fillStyle = getWeaponColor(p.weapon);
      if (weap && weap.ranged) { // Ranged weapon — unique per weapon
        drawRangedInHand(ctx, weap, wx, wy, flip, tier, p.attackTimer);
      } else {
        const swingAngle = (p.attackTimer / 12) * Math.PI;
        ctx.save();
        ctx.translate(wx + 5 * flip, wy);
        ctx.rotate(swingAngle * flip * -1);
        drawWeaponInHand(ctx, weap, weap.range * 0.6, flip, tier);
        // Tier 1+: orange outline glow on swing
        if (tier >= 1) {
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = '#ff8a65';
          ctx.lineWidth = 2;
          ctx.strokeRect(-2 * flip, -5, (weap.range * 0.6 + 4) * flip, 10);
          ctx.globalAlpha = 1;
        }
        // Tier 2+: spark particles trail
        if (tier >= 2) {
          for (let sp = 0; sp < 3; sp++) {
            const spx = Math.random() * weap.range * 0.5 * flip;
            const spy = (Math.random() - 0.5) * 14;
            ctx.fillStyle = ['#ffeb3b', '#ff8a65', '#fff'][sp % 3];
            ctx.fillRect(spx, spy, 2, 2);
          }
        }
        // Tier 3: golden afterimage trail
        if (tier >= 3) {
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = '#ffd700';
          const prevAngle = ((p.attackTimer + 2) / 12) * Math.PI;
          ctx.save();
          ctx.rotate((prevAngle - swingAngle) * flip * -1);
          ctx.fillRect(0, -4, weap.range * 0.6 * flip, 8);
          ctx.restore();
          ctx.globalAlpha = 1;
        }
        ctx.restore();
        // Sbombo sword sparkle trail
        if (weap.special === 'sbombo') {
          ctx.fillStyle = '#ff69b4';
          for (let s = 0; s < 4; s++) {
            const sx = Math.random() * weap.range * 0.8 * flip;
            const sy = (Math.random() - 0.5) * 20;
            ctx.fillRect(wx + sx, wy + sy, 3, 3);
          }
        }
      }
    }
  });

  // Sbombo sword floating hearts aura
  if (weapons[p.weapon] && weapons[p.weapon].special === 'sbombo') {
    for (let h = 0; h < 3; h++) {
      const hAngle = gameTime * 0.04 + h * (Math.PI * 2 / 3);
      const hx = p.x + Math.cos(hAngle) * 22;
      const hy = p.y - p.h / 2 + Math.sin(hAngle * 1.5) * 10 + bob;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#ff69b4';
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u2665', hx, hy);
      ctx.globalAlpha = 1;
    }
  }

  // Ultra golden glow aura
  if (p.ultraActive) {
    const ultraGlow = 0.25 + Math.sin(gameTime * 0.12) * 0.15;
    ctx.globalAlpha = ultraGlow;
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(p.x, p.y - p.h/2 + bob, 34, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
  }
  // Weapon glow effect (tier 3 upgrade)
  if (weapons[p.weapon] && weapons[p.weapon].glow) {
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.08) * 0.1;
    ctx.fillStyle = weapons[p.weapon].color || '#ffd700';
    ctx.beginPath();
    ctx.arc(p.x, p.y - p.h/2 + bob, 28, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;

  // HP bar above head
  const barW = 40;
  const hpRatio = p.hp / p.maxHp;
  drawRect(bx - 2, by - 14 + bob, barW, 6, '#333');
  drawRect(bx - 2, by - 14 + bob, barW * hpRatio, 6, hpRatio > 0.3 ? '#4caf50' : '#f44336');
  drawText('IL CONTE', bx - 5, by - 18 + bob, '#ffc107', 9, 'left');
}

function getWeaponColor(idx) {
  const w = weapons[idx];
  return w && w.color ? w.color : '#ffcc80';
}

// Draw unique melee weapon shape in hand during swing
function drawWeaponInHand(ctx, weap, length, flip, tier) {
  const col = weap.color || '#ffcc80';
  ctx.fillStyle = col;
  ctx.strokeStyle = col;
  ctx.lineWidth = 2;
  const f = flip;
  switch (weap.name) {
    case 'Sanpietrino': {
      // Chunky irregular cobblestone on short handle
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(0, -2, 12 * f, 4); // short handle
      ctx.fillStyle = '#9e9e9e';
      ctx.beginPath();
      ctx.moveTo(12 * f, -7);
      ctx.lineTo(18 * f, -9);
      ctx.lineTo(24 * f, -6);
      ctx.lineTo(26 * f, 0);
      ctx.lineTo(23 * f, 7);
      ctx.lineTo(16 * f, 8);
      ctx.lineTo(12 * f, 5);
      ctx.closePath();
      ctx.fill();
      // Highlight chip
      ctx.fillStyle = '#bdbdbd';
      ctx.fillRect(16 * f, -4, 5 * f, 4);
      break;
    }
    case 'Cacciavite': {
      // Wide handle then thin shaft
      ctx.fillStyle = '#ff8a65';
      // Handle (wide, rounded)
      ctx.fillRect(0, -5, 10 * f, 10);
      ctx.fillRect(2 * f, -6, 6 * f, 12);
      // Metal shaft (thin)
      ctx.fillStyle = '#cfd8dc';
      ctx.fillRect(10 * f, -2, length * 0.5 * f, 4);
      // Tip
      ctx.fillStyle = '#90a4ae';
      ctx.fillRect((10 + length * 0.5) * f, -1, 4 * f, 2);
      break;
    }
    case 'Spranga': {
      // Long thick iron pipe with slight bend
      ctx.fillStyle = '#795548';
      const pipeLen = length * 0.6;
      ctx.fillRect(0, -4, pipeLen * 0.6 * f, 8);
      // Slight bend
      ctx.save();
      ctx.translate(pipeLen * 0.6 * f, 0);
      ctx.rotate(0.15 * f);
      ctx.fillRect(0, -4, pipeLen * 0.5 * f, 8);
      ctx.restore();
      // Highlight stripe
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(4 * f, -4, pipeLen * 0.5 * f, 2);
      break;
    }
    case 'Machete': {
      // Wide curved blade tapering to point
      ctx.fillStyle = '#455a64';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      ctx.fillStyle = '#b0bec5';
      ctx.beginPath();
      ctx.moveTo(8 * f, -5);
      ctx.lineTo(20 * f, -7);
      ctx.lineTo(32 * f, -4);
      ctx.lineTo(38 * f, 0);
      ctx.lineTo(32 * f, 3);
      ctx.lineTo(8 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Edge highlight
      ctx.strokeStyle = '#eceff1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(10 * f, -6);
      ctx.lineTo(34 * f, -3);
      ctx.stroke();
      break;
    }
    case 'Catena': {
      // Series of linked oval chain segments
      ctx.fillStyle = '#757575';
      const links = 6;
      for (let i = 0; i < links; i++) {
        const lx = (i * 9 + 2) * f;
        ctx.beginPath();
        ctx.ellipse(lx, (i % 2 === 0 ? -1 : 1), 5, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        // Inner hole
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.ellipse(lx, (i % 2 === 0 ? -1 : 1), 2, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#757575';
      }
      break;
    }
    case 'Bottiglia Rotta': {
      // Bottle neck + jagged glass top
      ctx.fillStyle = '#2e7d32';
      // Bottle neck (grip)
      ctx.fillRect(0, -3, 10 * f, 6);
      ctx.fillRect(2 * f, -4, 6 * f, 8);
      // Broken glass shards
      ctx.fillStyle = '#4caf50';
      ctx.beginPath();
      ctx.moveTo(10 * f, -5);
      ctx.lineTo(16 * f, -8);
      ctx.lineTo(14 * f, -2);
      ctx.lineTo(20 * f, -6);
      ctx.lineTo(18 * f, 0);
      ctx.lineTo(22 * f, -3);
      ctx.lineTo(19 * f, 4);
      ctx.lineTo(15 * f, 6);
      ctx.lineTo(10 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Glass highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(12 * f, -5, 3 * f, 3);
      break;
    }
    case 'La Lupa': {
      // Ornate golden sword with crossguard
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      // Crossguard
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(7 * f, -8, 4 * f, 16);
      // Blade
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(11 * f, -4);
      ctx.lineTo(40 * f, -2);
      ctx.lineTo(44 * f, 0);
      ctx.lineTo(40 * f, 2);
      ctx.lineTo(11 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Blade center line
      ctx.strokeStyle = '#fff8e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(12 * f, 0);
      ctx.lineTo(42 * f, 0);
      ctx.stroke();
      // Pommel gem
      ctx.fillStyle = '#c62828';
      ctx.beginPath();
      ctx.arc(-2 * f, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
    }
    case 'Spada dello Sbombo': {
      // Pink sparkle sword with heart pommel
      ctx.fillStyle = '#e91e63';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      // Crossguard (hearts)
      ctx.fillStyle = '#ff69b4';
      ctx.fillRect(7 * f, -7, 4 * f, 14);
      // Blade
      ctx.fillStyle = '#ff69b4';
      ctx.beginPath();
      ctx.moveTo(11 * f, -5);
      ctx.lineTo(48 * f, -2);
      ctx.lineTo(54 * f, 0);
      ctx.lineTo(48 * f, 2);
      ctx.lineTo(11 * f, 5);
      ctx.closePath();
      ctx.fill();
      // Sparkle center
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(14 * f, 0);
      ctx.lineTo(50 * f, 0);
      ctx.stroke();
      // Heart pommel
      ctx.fillStyle = '#ff69b4';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u2665', -4 * f, 4);
      break;
    }
    default: {
      // Fallback rectangle
      ctx.fillRect(0, -3, length * f, 6);
      break;
    }
  }
}

// Draw unique ranged weapon in hand
function drawRangedInHand(ctx, weap, wx, wy, flip, tier, attackTimer) {
  const f = flip;
  switch (weap.name) {
    case 'Fionda': {
      // Y-shaped slingshot fork
      ctx.fillStyle = '#8d6e63';
      // Handle
      ctx.fillRect(wx, wy, 8 * f, 8);
      // Fork prongs
      ctx.strokeStyle = '#795548';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(wx + 8 * f, wy + 2);
      ctx.lineTo(wx + 18 * f, wy - 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(wx + 8 * f, wy + 6);
      ctx.lineTo(wx + 18 * f, wy + 14);
      ctx.stroke();
      // Elastic band
      ctx.strokeStyle = '#ff8a65';
      ctx.lineWidth = 1.5;
      const pullBack = attackTimer > 3 ? -6 : 0;
      ctx.beginPath();
      ctx.moveTo(wx + 18 * f, wy - 6);
      ctx.lineTo(wx + (12 + pullBack) * f, wy + 4);
      ctx.lineTo(wx + 18 * f, wy + 14);
      ctx.stroke();
      break;
    }
    case 'Pistola del Nonno': {
      // Revolver silhouette
      ctx.fillStyle = '#333';
      // Barrel
      ctx.fillRect(wx + 6 * f, wy, 20 * f, 5);
      // Body
      ctx.fillRect(wx, wy, 14 * f, 8);
      // Cylinder (round)
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.arc(wx + 10 * f, wy + 3, 4, 0, Math.PI * 2);
      ctx.fill();
      // Grip (angled down)
      ctx.fillStyle = '#5d4037';
      ctx.save();
      ctx.translate(wx + 4 * f, wy + 8);
      ctx.rotate(0.3 * f);
      ctx.fillRect(0, 0, 6 * f, 10);
      ctx.restore();
      // Muzzle flash
      if (attackTimer > 3) {
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(wx + 28 * f, wy - 4, 12 * f, 14);
      }
      break;
    }
    default: {
      // Fallback generic gun
      ctx.fillStyle = weap.color || '#ffcc80';
      ctx.fillRect(wx, wy, 25 * f, 6);
      if (attackTimer > 3) {
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(wx + 28 * f, wy - 4, 12 * f, 14);
      }
      break;
    }
  }
}

// Draw mobile touch buttons overlay
function drawTouchButtons() {
  if (!isTouchDevice || inMobileWrapper) return;
  const btns = getTouchButtonsForState();
  if (btns.length === 0) return;
  ctx.save();
  for (const name of btns) {
    // Skip ultra button if ultra not available
    if (name === 'ultra' && !(player.ultraCharge >= 100 && !player.ultraActive)) continue;
    const b = touchButtons[name];
    // Hidden buttons are hit areas only (e.g. helper bar overlay)
    if (b.hidden) continue;
    const pressed = Object.values(touchBtnState).includes(name);
    const alpha = pressed ? 0.55 : 0.3;
    ctx.globalAlpha = alpha;
    // Rounded rect background
    const r = 8;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.moveTo(b.x + r, b.y);
    ctx.lineTo(b.x + b.w - r, b.y);
    ctx.quadraticCurveTo(b.x + b.w, b.y, b.x + b.w, b.y + r);
    ctx.lineTo(b.x + b.w, b.y + b.h - r);
    ctx.quadraticCurveTo(b.x + b.w, b.y + b.h, b.x + b.w - r, b.y + b.h);
    ctx.lineTo(b.x + r, b.y + b.h);
    ctx.quadraticCurveTo(b.x, b.y + b.h, b.x, b.y + b.h - r);
    ctx.lineTo(b.x, b.y + r);
    ctx.quadraticCurveTo(b.x, b.y, b.x + r, b.y);
    ctx.closePath();
    ctx.fill();
    // Border
    ctx.globalAlpha = pressed ? 0.8 : 0.5;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Label
    ctx.globalAlpha = pressed ? 1 : 0.7;
    ctx.fillStyle = '#fff';
    ctx.font = (b.w >= 50 ? '14' : '11') + 'px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2);
  }
  ctx.globalAlpha = 1;
  ctx.textBaseline = 'alphabetic';
  ctx.restore();
}

// Draw on-screen keyboard for credits code entry (mobile)
function drawCreditsKeyboard(baseY) {
  if (!isTouchDevice) return;
  const rows = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['Z','X','C','V','B','N','M','DEL']
  ];
  const kw = 30, kh = 26, gap = 2;
  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];
    const totalW = row.length * (kw + gap) - gap;
    const startX = W / 2 - totalW / 2;
    const ky = baseY + r * (kh + gap);
    for (let c = 0; c < row.length; c++) {
      const kx = startX + c * (kw + gap);
      const letter = row[c];
      const isDelKey = letter === 'DEL';
      const keyW = isDelKey ? kw + 10 : kw;
      const hov = mouseX >= kx && mouseX <= kx + keyW && mouseY >= ky && mouseY <= ky + kh;
      drawRect(kx, ky, keyW, kh, hov ? 'rgba(255,255,255,0.25)' : 'rgba(255,255,255,0.1)');
      drawText(letter, kx + keyW / 2, ky + 18, hov ? '#fff' : '#aaa', isDelKey ? 8 : 10, 'center');
      if (mouseClick && hov) {
        if (isDelKey) {
          codeInput = codeInput.slice(0, -1);
        } else {
          if (codeInput.length < 12) codeInput += letter;
        }
        mouseClick = false;
      }
    }
  }
}

function drawBossChar(b, level) {
  if (!b || b.dead) return;
  const bx = b.x - b.w/2, by = b.y - b.h;
  const flash = b.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0;
  const telegraphing = b.bossState === 'telegraph';

  if (flash) ctx.globalAlpha = 0.5;
  // Telegraph warning — red pulsing tint
  if (telegraphing) {
    const telPulse = Math.sin(gameTime * 0.25) * 0.15 + 0.75;
    ctx.globalAlpha = telPulse;
  }
  // Recovery visual cue — green pulsing (safe to punish)
  if (b.bossState === 'recovery') {
    const recPulse = Math.sin(gameTime * 0.2) * 0.15 + 0.75;
    ctx.globalAlpha = recPulse;
  }

  switch(currentLevel) {
    case 0: drawLaFed(bx, by, b); break;
    case 1: drawGioacchino(bx, by, b); break;
    case 2: drawDale(bx, by, b); break;
    case 3: drawCiccioRuver(bx, by, b); break;
    case 4: drawPisellino(bx, by, b); break;
  }

  ctx.globalAlpha = 1.0;

  // Telegraph warning overlay — thick red pulsing border + red circle "!"
  if (telegraphing) {
    const telPulse = Math.sin(gameTime * 0.25) * 0.2 + 0.7;
    ctx.globalAlpha = telPulse;
    ctx.strokeStyle = '#f44336';
    ctx.lineWidth = 4;
    ctx.strokeRect(bx - 4, by - 4, b.w + 8, b.h + 8);
    ctx.lineWidth = 1;
    // Red circle with "!" above boss
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath();
    ctx.arc(b.x, by - 18, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
    drawText('!', b.x, by - 12, '#fff', 22, 'center');
  }
  // Recovery overlay — green glow + border + "PUNISCI!" text
  if (b.bossState === 'recovery') {
    const recPulse = Math.sin(gameTime * 0.2) * 0.15 + 0.55;
    // Green glow around boss
    ctx.globalAlpha = recPulse * 0.5;
    ctx.fillStyle = '#4caf50';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 0.9, 0, Math.PI * 2);
    ctx.fill();
    // Green border
    ctx.globalAlpha = recPulse;
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 3;
    ctx.strokeRect(bx - 3, by - 3, b.w + 6, b.h + 6);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 1.0;
    // "PUNISCI!" text above boss
    const textPulse = Math.sin(gameTime * 0.15) * 0.2 + 0.8;
    ctx.globalAlpha = textPulse;
    drawText('PUNISCI!', b.x, by - 16, '#4caf50', 16, 'center');
    ctx.globalAlpha = 1.0;
  }
  // Super armor glow during charge attacks (orange/red pulsing aura)
  if (b.bossState === 'attack' && b.currentMove && b.currentMove.superArmor) {
    const armorPulse = 0.35 + Math.sin(gameTime * 0.15) * 0.15;
    ctx.globalAlpha = armorPulse;
    ctx.fillStyle = '#ff6f00';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 1.0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#f44336';
    ctx.fillRect(bx - 3, by - 3, b.w + 6, b.h + 6);
    ctx.globalAlpha = 1.0;
  }

  // Ciccio tank mode fire aura (phase 3)
  if (b.ciccioTank) {
    const firePulse = 0.15 + Math.sin(gameTime * 0.1) * 0.08;
    ctx.globalAlpha = firePulse;
    ctx.fillStyle = '#ff6f00';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 0.9, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
    // Fire particles constantly
    if (gameTime % 4 === 0) spawnParticles(b.x + (Math.random()-0.5)*b.w, b.y - Math.random()*b.h, '#f44336', 1, 2);
  }

  // Boss HP bar with phase markers — only show once boss intro has started
  if (bossIntro) {
    const barW = 260;
    const hpRatio = b.hp / b.maxHp;
    const barX = W/2 - barW/2;
    drawRect(barX - 4, 6, barW + 8, 36, 'rgba(0,0,0,0.85)');
    drawRect(barX - 4, 6, barW + 8, 2, '#e94560');
    drawText(levels[currentLevel].boss.toUpperCase(), W/2, 22, '#ff8a80', 12, 'center');
    if (b.bossPhase > 1) drawText('PHASE ' + b.bossPhase, W/2 + 100, 22, '#ffd700', 9, 'center');
    drawRect(barX, 28, barW, 10, '#333');
    drawRect(barX, 28, barW * hpRatio, 10, hpRatio > 0.3 ? '#e53935' : '#ff6f00');
    // Boss poise bar
    if (b.poise !== undefined && b.poise < b.maxPoise) {
      const poiseR = Math.max(0, b.poise / b.maxPoise);
      drawRect(barX, 39, barW, 3, '#555');
      drawRect(barX, 39, barW * poiseR, 3, b.staggerTimer > 0 ? '#ff9800' : '#ffeb3b');
    }
    // Phase markers at 60% and 30% HP
    [0.6, 0.3].forEach(t => {
      drawRect(barX + barW * t - 1, 26, 2, 14, '#ffd700');
    });
  }
}

function drawLaFed(x, y, b) {
  drawPixelChar(x, y, b.w, b.h, '#fff', '#ffe0b2', (px, py, w, h) => {
    // Blond hair
    drawRect(px + 2, py - 4, w - 4, 10, '#ffd54f');
    // Rugby jersey stripes
    drawRect(px + 4, py + 28, w - 8, 4, '#1565c0');
    drawRect(px + 4, py + 36, w - 8, 4, '#1565c0');
    // Muscular arms
    drawRect(px - 6, py + 22, 10, 18, '#ffe0b2');
    drawRect(px + w - 4, py + 22, 10, 18, '#ffe0b2');
    // Blue eyes
    drawRect(px + 10, py + 10, 2, 2, '#2196f3');
    drawRect(px + w - 11, py + 10, 2, 2, '#2196f3');
    // Smirk
    drawRect(px + 10, py + 16, w - 20, 2, '#e65100');
  });
}

function drawGioacchino(x, y, b) {
  drawPixelChar(x, y, b.w, b.h, '#424242', '#5d4037', (px, py, w, h) => {
    // Short hair
    drawRect(px + 4, py - 2, w - 8, 6, '#212121');
    // Baton in hand
    drawRect(px + w, py + 22, 30, 5, '#795548');
    // Tough expression
    drawRect(px + 8, py + 16, 6, 2, '#d32f2f');
  });
}

function drawDale(x, y, b) {
  // Dale is TALL
  drawPixelChar(x, y, b.w, b.h, '#607d8b', '#ffcc80', (px, py, w, h) => {
    // Messy hair
    drawRect(px + 2, py - 5, w - 4, 8, '#8d6e63');
    drawRect(px + 8, py - 8, 6, 6, '#8d6e63');
    // Dumb expression - mouth open
    drawRect(px + 10, py + 15, w - 20, 6, '#111');
    // Crossed eyes
    drawRect(px + 11, py + 10, 2, 2, '#111');
    drawRect(px + w - 12, py + 9, 2, 2, '#111');
  });
}

function drawCiccioRuver(x, y, b) {
  const scale = b.w / 52; // scale factor based on phase 3 growth
  drawPixelChar(x, y, b.w + Math.floor(8 * scale), b.h, '#fff', '#ffcc80', (px, py, w, h) => {
    // Mohawk
    for (let i = 0; i < 7; i++) {
      const sx = Math.floor(10 * scale + i * 3 * scale);
      const spikeH = Math.floor((12 + i * 2) * scale);
      drawRect(px + sx, py - Math.floor(10 * scale) - Math.floor(i * 2 * scale), Math.floor(4 * scale), spikeH, '#d32f2f');
      // Phase 3: orange flame tips on mohawk spikes
      if (b.bossPhase >= 3) {
        const flicker = Math.sin(gameTime * 0.3 + i) * 2;
        drawRect(px + sx, py - Math.floor(10 * scale) - Math.floor(i * 2 * scale) - Math.floor(4 * scale) + flicker, Math.floor(4 * scale), Math.floor(4 * scale), '#ff6f00');
      }
    }
    // Pizza apron
    drawRect(px + Math.floor(2 * scale), py + Math.floor(22 * scale), w - Math.floor(4 * scale), Math.floor(25 * scale), '#fff');
    drawRect(px + Math.floor(8 * scale), py + Math.floor(26 * scale), w - Math.floor(16 * scale), Math.floor(2 * scale), '#f44336');
    // Slightly wider body (overweight)
    drawRect(px - Math.floor(4 * scale), py + Math.floor(24 * scale), Math.floor(8 * scale), Math.floor(16 * scale), '#fff');
    drawRect(px + w - Math.floor(4 * scale), py + Math.floor(24 * scale), Math.floor(8 * scale), Math.floor(16 * scale), '#fff');
    // Flour on face
    drawRect(px + Math.floor(6 * scale), py + Math.floor(6 * scale), Math.floor(4 * scale), Math.floor(3 * scale), '#fafafa');
  });
}

function drawPisellino(x, y, b) {
  // Ghost-like, tall and skinny
  const ghostAlpha = 0.85 + Math.sin(gameTime * 0.05) * 0.15;
  ctx.globalAlpha *= ghostAlpha;

  // Extra tall, skinny body
  drawRect(x + 8, y + 22, b.w - 16, b.h - 22, '#37474f');
  // Skinny legs
  drawRect(x + 10, y + b.h - 18, 5, 18, '#263238');
  drawRect(x + b.w - 15, y + b.h - 18, 5, 18, '#263238');
  // Head - pale
  drawRect(x + 6, y, b.w - 12, 24, '#cfd8dc');
  // Dark eyes
  drawRect(x + 10, y + 8, 6, 6, '#111');
  drawRect(x + b.w - 16, y + 8, 6, 6, '#111');
  drawRect(x + 12, y + 10, 2, 2, '#f44336');
  drawRect(x + b.w - 14, y + 10, 2, 2, '#f44336');
  // Thin mouth - sinister grin
  drawRect(x + 10, y + 18, b.w - 20, 2, '#b71c1c');
  // Hood
  drawRect(x + 2, y - 4, b.w - 4, 10, '#263238');
  drawRect(x, y - 2, 6, 14, '#263238');
  drawRect(x + b.w - 6, y - 2, 6, 14, '#263238');

  // Moped nearby
  if (b.onMoped) {
    drawRect(b.x - 30, b.y - 20, 60, 15, '#616161');
    drawRect(b.x - 35, b.y - 10, 12, 12, '#333');
    drawRect(b.x + 23, b.y - 10, 12, 12, '#333');
    drawRect(b.x - 20, b.y - 30, 8, 15, '#757575');
  }
}

function drawRegina(r) {
  if (!r || r.dead) return;
  const x = r.x - r.w/2, y = r.y - r.h;
  drawPixelChar(x, y, r.w, r.h, '#e91e63', '#6d4c41', (px, py, w, h) => {
    // Long hair
    drawRect(px, py - 2, 6, 20, '#212121');
    drawRect(px + w - 6, py - 2, 6, 20, '#212121');
    // Angry expression
    drawRect(px + 8, py + 6, 8, 2, '#fff');
    drawRect(px + w - 16, py + 6, 8, 2, '#fff');
  });
  // HP bar
  const hpR = r.hp / r.maxHp;
  drawRect(x, y - 10, 30, 4, '#333');
  drawRect(x, y - 10, 30 * hpR, 4, '#e91e63');
  drawText('REGINA', x, y - 14, '#e91e63', 8);
}

function drawMariuso(m) {
  if (!m || m.dead) return;
  const x = m.x - m.w/2, y = m.y - m.h;
  // Mariuso - big, angry uncle
  drawPixelChar(x, y, m.w + 10, m.h, '#4a148c', '#ffcc80', (px, py, w, h) => {
    // Bald with stubble
    drawRect(px + 4, py - 2, w - 8, 6, '#5d4037');
    // Angry brows
    drawRect(px + 6, py + 5, 8, 3, '#333');
    drawRect(px + w - 14, py + 5, 8, 3, '#333');
    // Big fists
    drawRect(px - 8, py + 22, 12, 12, '#ffcc80');
    drawRect(px + w - 4, py + 22, 12, 12, '#ffcc80');
    // Scar
    drawRect(px + 6, py + 12, 2, 8, '#b71c1c');
  });
  // HP bar
  const hpR = m.hp / m.maxHp;
  drawRect(x, y - 10, 40, 5, '#333');
  drawRect(x, y - 10, 40 * hpR, 5, '#7b1fa2');
  drawText('MARIUSO', x - 5, y - 15, '#ce93d8', 9);
}

// ==========================================
// PARTICLE SYSTEM
// ==========================================
const MAX_PARTICLES = 200;
const MAX_DAMAGE_NUMBERS = 30;

function spawnParticles(x, y, color, count, speed) {
  // If near cap, reduce spawn count
  const headroom = MAX_PARTICLES - particles.length;
  const actualCount = Math.min(count, Math.max(1, headroom));
  for (let i = 0; i < actualCount; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * (speed || 4),
      vy: (Math.random() - 0.8) * (speed || 4),
      life: 30 + Math.random() * 30,
      color: color,
      size: 2 + Math.random() * 4
    });
  }
  // Hard cap: drop oldest if over limit
  if (particles.length > MAX_PARTICLES) {
    particles.splice(0, particles.length - MAX_PARTICLES);
  }
}

function spawnArmorSpark(x, y) {
  if (particles.length >= MAX_PARTICLES) return;
  for (let i = 0; i < 5; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.8) * 5,
      life: 8,
      color: '#fff',
      size: 1 + Math.random() * 2
    });
  }
}

function spawnDamageNumber(x, y, dmg, color) {
  if (damageNumbers.length >= MAX_DAMAGE_NUMBERS) damageNumbers.shift();
  damageNumbers.push({ x, y, vy: -2, text: dmg.toString(), life: 40, color: color || '#ff0' });
}

function updateParticles() {
  // Swap-and-pop removal for O(1) per particle
  let i = 0;
  while (i < particles.length) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) {
      particles[i] = particles[particles.length - 1];
      particles.pop();
    } else {
      i++;
    }
  }
  let j = 0;
  while (j < damageNumbers.length) {
    const d = damageNumbers[j];
    d.y += d.vy;
    d.life--;
    if (d.life <= 0) {
      damageNumbers[j] = damageNumbers[damageNumbers.length - 1];
      damageNumbers.pop();
    } else {
      j++;
    }
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 60;
    drawRect(p.x, p.y, p.size, p.size, p.color);
  });
  ctx.globalAlpha = 1;
  damageNumbers.forEach(d => {
    ctx.globalAlpha = d.life / 40;
    drawText(d.text, d.x, d.y, d.color, 16, 'center');
  });
  ctx.globalAlpha = 1;
}

// ==========================================
// COIN PICKUP SYSTEM
// ==========================================
let coinPickups = [];

function spawnCoinPickup(x, y, value) {
  // Chain bonus multiplier based on player's combo chain count
  const chainMult = Math.min(2.0, 1.0 + player.comboChainCount * 0.5);
  const finalValue = Math.floor(value * chainMult);
  // Scatter into multiple physical coins
  const numCoins = Math.min(8, Math.max(1, Math.floor(finalValue / 4)));
  const perCoin = Math.floor(finalValue / numCoins);
  for (let i = 0; i < numCoins; i++) {
    coinPickups.push({
      x: x + (Math.random() - 0.5) * 20,
      y: y,
      vx: (Math.random() - 0.5) * 6,
      vy: -3 - Math.random() * 4,
      value: perCoin + (i === 0 ? finalValue % numCoins : 0),
      life: 300, // 5 seconds at 60fps
      grounded: false,
      size: Math.min(6, 3 + Math.floor(perCoin / 5))
    });
  }
}

function updateCoinPickups() {
  for (let i = coinPickups.length - 1; i >= 0; i--) {
    const c = coinPickups[i];
    c.life--;
    if (c.life <= 0) { coinPickups.splice(i, 1); continue; }

    if (!c.grounded) {
      c.vy += 0.3;
      c.x += c.vx;
      c.y += c.vy;
      if (c.y >= GROUND_Y - 2) {
        c.y = GROUND_Y - 2;
        c.vy *= -0.4; // bounce
        c.vx *= 0.7;
        if (Math.abs(c.vy) < 0.5) c.grounded = true;
      }
    }

    // Player pickup (30px radius)
    if (!player.dead && Math.abs(c.x - player.x) < 30 && Math.abs(c.y - player.y + 20) < 30) {
      // Replay penalty: replaying beaten levels gives 40% coins
      const replayMult = isReplayLevel ? 0.4 : 1.0;
      const coinValue = Math.floor(c.value * player.scoreMultiplier * replayMult);
      coins += coinValue;
      levelScore += coinValue * 2;
      playSFX('coin');
      spawnParticles(c.x, c.y, '#ffd700', 3, 2);
      coinPickups.splice(i, 1);
    }
  }
}

function drawCoinPickups() {
  coinPickups.forEach(c => {
    // Flash warning in last second (60 frames)
    if (c.life < 60 && Math.floor(c.life / 6) % 2 === 0) {
      ctx.globalAlpha = 0.4;
    } else {
      ctx.globalAlpha = 1;
    }
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    ctx.arc(c.x - 1, c.y - 1, c.size * 0.5, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// ==========================================
// PROJECTILE SYSTEM
// ==========================================
function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (p.gravity) p.vy += 0.15;
    p.life--;

    // Check if it hits player
    if (p.hostile && !player.dead && player.invincible <= 0 && !isDodgeInvincible()) {
      if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y + 20) < 30) {
        hurtPlayer(p.damage || 10);
        spawnParticles(p.x, p.y, '#f44336', 5);
        projectiles.splice(i, 1);
        continue;
      }
    }

    if (p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y > H + 50) {
      projectiles.splice(i, 1);
    }
  }
}

function drawProjectiles() {
  projectiles.forEach(p => {
    if (p.type === 'meat') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate((120 - p.life) * 0.15);
      drawRect(-7, -5, 14, 10, '#6d4c41');
      drawRect(-5, -3, 10, 6, '#d32f2f');
      drawRect(-3, -2, 3, 3, '#ffcdd2');
      drawRect(1, 0, 3, 2, '#ffcdd2');
      drawRect(5, -2, 4, 3, '#eee');
      ctx.restore();
    } else if (p.type === 'pizza') {
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f44336';
      ctx.beginPath();
      ctx.arc(p.x - 2, p.y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x + 3, p.y + 2, 2, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'scarf') {
      drawRect(p.x - 8, p.y - 3, 16, 6, '#64b5f6');
      drawRect(p.x - 6, p.y - 1, 12, 2, '#fff');
    } else if (p.type === 'bullet') {
      drawRect(p.x - 3, p.y - 1, 6, 3, '#ffeb3b');
    } else if (p.type === 'shockwave') {
      ctx.globalAlpha = p.life / 45;
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (p.type === 'sbombo_wave') {
      ctx.globalAlpha = p.life / 40;
      // Pink heart-shaped shockwave
      ctx.fillStyle = '#ff69b4';
      ctx.beginPath();
      ctx.arc(p.x - 5, p.y - 3, 10, 0, Math.PI * 2);
      ctx.arc(p.x + 5, p.y - 3, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(p.x - 14, p.y);
      ctx.lineTo(p.x, p.y + 14);
      ctx.lineTo(p.x + 14, p.y);
      ctx.fill();
      // Inner glow
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath();
      ctx.arc(p.x, p.y - 2, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else {
      drawRect(p.x - 4, p.y - 4, 8, 8, p.color || '#fff');
    }
  });
}

// ==========================================
// HELPER EFFECTS
// ==========================================
function activateHelper(idx) {
  if (!helpers[idx].unlocked) return;
  if (helperCooldowns[idx] > 0) return;
  helperCooldowns[idx] = helpers[idx].cooldown;
  playSFX('helper');

  const tier = helpers[idx].tier;
  switch(idx) {
    case 0: { // Pirox DJ Drop (CC)
      screenShake = 20;
      screenFlash = 10;
      flashColor = '#e040fb';
      spawnParticles(W/2, H/2, '#e040fb', 30, 8);
      spawnHelperVisual(0, W/2, GROUND_Y);
      const stunDur = tier >= 1 ? 180 : 120; // +50% at tier 1
      if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) { boss.stunTimer = stunDur; }
      goons.forEach(g => {
        if (!g.dead) {
          g.stunTimer = stunDur;
          if (tier >= 2 && g.poise !== undefined) g.poise = Math.max(0, g.poise - g.maxPoise * 0.5); // poise shatter
          if (tier >= 3) { // Rally: nearby enemies lose 30% poise
            goons.forEach(o => { if (!o.dead && o !== g && Math.abs(o.x - g.x) < 150 && o.poise !== undefined) o.poise *= 0.7; });
          }
        }
      });
      if (reginaActive && regina) regina.stunTimer = stunDur;
      if (mariusoActive && mariuso) mariuso.stunTimer = stunDur;
      showQuickText('PIROX DJ DROP! Tutti storditi!', '#e040fb');
      break;
    }
    case 1: { // Tommy knife rush (Damage)
      spawnHelperVisual(1, (boss && bossIntro && bossIntroTimer <= 0) ? boss.x : player.x + player.facing * 80, GROUND_Y);
      const baseDmg = tier >= 1 ? (52 + Math.random() * 38) : (35 + Math.random() * 25); // +50% at tier 1
      if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) {
        boss.hp -= baseDmg;
        boss.hitFlash = 10;
        spawnDamageNumber(boss.x, boss.y - boss.h, Math.floor(baseDmg), '#ff6e40');
        spawnParticles(boss.x, boss.y - boss.h/2, '#ff6e40', 15);
        showQuickText('Tommy col coltello! SLASH!', '#ff6e40');
      }
      // Tier 2: auto-attack staggered enemies
      if (tier >= 2) {
        goons.forEach(g => {
          if (!g.dead && g.staggerTimer > 0) {
            g.hp -= baseDmg * 0.5;
            g.hitFlash = 10;
            spawnDamageNumber(g.x, g.y - (g.h || 50), Math.floor(baseDmg * 0.5), '#ff6e40');
            if (g.hp <= 0) { g.dead = true; totalKills++; spawnCoinPickup(g.x, g.y - 20, 7); }
          }
        });
      }
      // Tier 3: war cry buff
      if (tier >= 3) { warCryTimer = 240; showQuickText('WAR CRY! +30% DMG 4s!', '#ff6e40'); }
      break;
    }
    case 2: { // Cicca the cat (Heal)
      const healAmt = tier >= 1 ? 52 : 35; // +50% at tier 1
      player.hp = Math.min(player.maxHp, player.hp + healAmt);
      spawnParticles(player.x, player.y - 30, '#76ff03', 10);
      spawnHelperVisual(2, player.x, GROUND_Y);
      // Tier 2: attack buff
      if (tier >= 2) { warCryTimer = Math.max(warCryTimer, 300); showQuickText('Cicca cura +' + healAmt + ' HP + ATK buff!', '#76ff03'); }
      else showQuickText('Cicca miagola e ti cura! +' + healAmt + ' HP', '#76ff03');
      break;
    }
    case 3: { // Il Mostro speed boost — arrives on moped
      const boostDur = tier >= 1 ? 720 : 480; // +50% at tier 1
      player.speedBoost = boostDur;
      spawnParticles(player.x, player.y - 30, '#76ff03', 15);
      spawnHelperVisual(3, player.x, GROUND_Y);
      showQuickText('"Danie\' Balduina Prati, panoramica in 3 minuti dajeeee!"', '#76ff03');
      break;
    }
  }
}

let quickText = '';
let quickTextColor = '#fff';
let quickTextTimer = 0;

// Active helper visuals on screen
let activeHelperVisuals = []; // {type, x, y, timer, maxTimer, facing}

function spawnHelperVisual(type, targetX, targetY) {
  activeHelperVisuals.push({
    type: type,
    x: type === 2 ? -30 : (type === 3 ? W + 40 : player.x + (Math.random() > 0.5 ? -60 : 60)),
    y: GROUND_Y,
    targetX: targetX,
    timer: 0,
    maxTimer: type === 0 ? 150 : type === 1 ? 100 : type === 2 ? 120 : 90,
    facing: 1,
    phase: 0
  });
}

function updateHelperVisuals() {
  for (let i = activeHelperVisuals.length - 1; i >= 0; i--) {
    const h = activeHelperVisuals[i];
    h.timer++;
    h.facing = h.targetX > h.x ? 1 : -1;

    switch(h.type) {
      case 0: // Pirox DJ - walks to center, drops bass, walks away
        if (h.timer < 40) h.x += (W/2 - h.x) * 0.08;
        else if (h.timer === 40) h.phase = 1;
        else if (h.timer > 110) h.x += h.facing * 4;
        break;
      case 1: // Tommy - stumbles in drunk, slashes, might fall
        if (h.timer < 30) {
          h.x += (h.targetX - h.x) * 0.1;
          h.y = GROUND_Y + Math.sin(h.timer * 0.5) * 3; // wobble
        }
        else if (h.timer === 30) h.phase = 1;
        else if (h.timer > 60) {
          h.x += h.facing * -3; // stumble away
          h.y = GROUND_Y + Math.sin(h.timer * 0.3) * 5;
        }
        break;
      case 2: // Cicca - black cat runs across screen
        h.x += 5;
        h.y = GROUND_Y + Math.sin(h.timer * 0.3) * 2;
        // Drop healing sparkles near player
        if (Math.abs(h.x - player.x) < 60 && h.timer % 5 === 0) {
          spawnParticles(h.x, h.y - 10, '#76ff03', 2, 2);
        }
        break;
      case 3: // Il Mostro - arrives on moped behind player, roars, rides off
        if (h.timer < 20) {
          h.x = player.x - 80 + h.timer * 2;
        } else if (h.timer === 20) {
          h.phase = 1;
          screenShake = 8;
        } else if (h.timer > 60) {
          h.x += 6; // rides off to the right on moped
        }
        break;
    }

    if (h.timer >= h.maxTimer) activeHelperVisuals.splice(i, 1);
  }
}

function drawHelperVisuals() {
  activeHelperVisuals.forEach(h => {
    const alpha = h.timer > h.maxTimer - 20 ? (h.maxTimer - h.timer) / 20 : 1;
    ctx.globalAlpha = alpha;

    switch(h.type) {
      case 0: // Pirox DJ
        drawPixelChar(h.x - 18, h.y - 52, 36, 52, '#9c27b0', '#ffcc80', (px, py, w, hh) => {
          // Headphones
          drawRect(px, py - 2, w, 4, '#e040fb');
          drawRect(px - 3, py + 2, 6, 8, '#e040fb');
          drawRect(px + w - 3, py + 2, 6, 8, '#e040fb');
          // Sunglasses
          drawRect(px + 6, py + 8, w - 12, 5, '#111');
        });
        // Turntable
        if (h.phase === 1) {
          drawRect(h.x - 25, h.y - 25, 50, 8, '#333');
          ctx.fillStyle = '#e040fb';
          ctx.beginPath();
          ctx.arc(h.x, h.y - 22, 12, 0, Math.PI * 2);
          ctx.fill();
          // Bass waves
          for (let w = 0; w < 3; w++) {
            ctx.strokeStyle = '#e040fb';
            ctx.globalAlpha = alpha * (0.5 - w * 0.15);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(h.x, h.y - 30, 30 + w * 20 + (h.timer - 40) * 2, -0.5, 0.5);
            ctx.stroke();
          }
          drawText('BASS DROP!', h.x, h.y - 60, '#e040fb', 14, 'center');
        }
        break;

      case 1: // Tommy drunk
        drawPixelChar(h.x - 16, h.y - 50, 32, 50, '#8d6e63', '#ffcc80', (px, py, w, hh) => {
          // Messy hair
          drawRect(px + 2, py - 4, w - 4, 8, '#5d4037');
          drawRect(px + w - 6, py - 6, 8, 6, '#5d4037');
          // Drunk blush
          drawRect(px + 4, py + 12, 6, 4, '#e57373');
          drawRect(px + w - 10, py + 12, 6, 4, '#e57373');
          // Bottle in other hand
          drawRect(px - 6, py + 20, 5, 14, '#4caf50');
        });
        // Knife
        if (h.phase === 1) {
          const kx = h.x + h.facing * 25;
          drawRect(kx, h.y - 35, 4, 20, '#bdbdbd');
          drawRect(kx - 1, h.y - 18, 6, 8, '#795548');
          spawnParticles(kx, h.y - 35, '#ff6e40', 2, 3);
        }
        // Drunk text
        if (h.timer % 40 < 20) drawText('*hic*', h.x, h.y - 58, '#ff6e40', 10, 'center');
        break;

      case 2: // Cicca black cat
        // Cat body
        drawRect(h.x - 10, h.y - 14, 20, 10, '#212121');
        // Head
        drawRect(h.x - 7, h.y - 20, 12, 10, '#212121');
        // Ears
        drawRect(h.x - 7, h.y - 24, 4, 5, '#212121');
        drawRect(h.x + 3, h.y - 24, 4, 5, '#212121');
        // Eyes
        drawRect(h.x - 4, h.y - 17, 3, 3, '#76ff03');
        drawRect(h.x + 2, h.y - 17, 3, 3, '#76ff03');
        // Tail
        const tailWave = Math.sin(h.timer * 0.3) * 8;
        drawRect(h.x + 10, h.y - 18 + tailWave, 3, 12, '#212121');
        // Legs running
        const legOff = Math.sin(h.timer * 0.8) * 3;
        drawRect(h.x - 6, h.y - 4, 3, 4 + legOff, '#212121');
        drawRect(h.x + 4, h.y - 4, 3, 4 - legOff, '#212121');
        drawText('Miao!', h.x, h.y - 30, '#76ff03', 9, 'center');
        break;

      case 3: // Il Mostro on moped
        // Moped
        drawRect(h.x - 30, h.y - 18, 60, 14, '#616161');
        drawRect(h.x - 35, h.y - 8, 12, 12, '#333'); // back wheel
        drawRect(h.x + 23, h.y - 8, 12, 12, '#333'); // front wheel
        drawRect(h.x - 20, h.y - 28, 8, 14, '#757575'); // handlebar
        drawRect(h.x + 15, h.y - 24, 12, 8, '#f44336'); // headlight
        // Big hulking figure on moped
        drawPixelChar(h.x - 24, h.y - 68, 48, 50, '#33691e', '#ffcc80', (px, py, w, hh) => {
          // Massive arms gripping handlebars
          drawRect(px - 10, py + 14, 14, 20, '#33691e');
          drawRect(px + w - 4, py + 14, 14, 20, '#33691e');
          // Angry face
          drawRect(px + 8, py + 6, 10, 4, '#fff');
          drawRect(px + w - 18, py + 6, 10, 4, '#fff');
          drawRect(px + 10, py + 8, 3, 2, '#111');
          drawRect(px + w - 14, py + 8, 3, 2, '#111');
        });
        if (h.phase === 1 && h.timer < 50) {
          drawText('DAJEEEE!', h.x, h.y - 78, '#76ff03', 16, 'center');
          // Speed lines
          for (let s = 0; s < 5; s++) {
            ctx.globalAlpha = alpha * 0.3;
            drawRect(h.x - 50 - s * 15, h.y - 50 + s * 8, 30 + s * 10, 2, '#76ff03');
          }
        }
        break;
    }
    ctx.globalAlpha = 1;
  });
}

function showQuickText(text, color) {
  quickText = text;
  quickTextColor = color || '#fff';
  quickTextTimer = 120;
}

// ==========================================
// COMBAT
// ==========================================
function isDodgeInvincible() {
  // i-frames only during frames 3-9 of dodge (dodgeTimer 4-10 out of 12)
  return player.dodging && player.dodgeTimer >= 4 && player.dodgeTimer <= 10;
}

function hurtPlayer(dmg) {
  if (player.invincible > 0 || isDodgeInvincible() || player.dead) return;
  dmg *= DIFF_DMG[difficulty];
  player.hp -= dmg;
  player.invincible = 20;
  levelDamageTaken += dmg;
  player.comboChainCount = 0; // reset chain bonus on hit
  player.comboHitCount = 0; // reset combo counter on hit
  player.comboHitTimer = 0;
  player.scoreMultiplier = 1;
  // Ultra charge drain on taking damage (reduced penalty)
  if (!player.ultraActive) {
    player.ultraCharge = Math.max(0, player.ultraCharge - 12);
    if (player.ultraCharge < player.ultraMaxCharge) player.ultraAvailable = false;
  }
  screenShake = 8;
  spawnParticles(player.x, player.y - 30, '#f44336', 8);
  spawnDamageNumber(player.x, player.y - player.h, Math.floor(dmg), '#f44336');
  playSFX('hurt');
  if (player.hp <= 0) {
    // Cicca tier 3: emergency revive (once per level)
    if (helpers[2].tier >= 3 && !helperReviveUsed) {
      helperReviveUsed = true;
      player.hp = Math.floor(player.maxHp * 0.3);
      player.invincible = 90;
      screenFlash = 15;
      flashColor = '#76ff03';
      spawnParticles(player.x, player.y - 30, '#76ff03', 20, 5);
      showQuickText('CICCA EMERGENCY REVIVE!', '#76ff03');
      playSFX('helper');
      return;
    }
    player.hp = 0;
    player.dead = true;
    screenFlash = 20;
    flashColor = '#f44336';
    playSFX('death');
  }
}

// Combo damage multipliers per step: balanced scaling, no single hit dominates
const COMBO_DMG_MULT = [0.8, 0.9, 1.0, 1.15]; // rewards completing combos without overpowered finisher
const DROPPED_END_LAG = 10; // 8-12 average

// Start or continue a combo chain hit
function playerAttack() {
  if (player.dead || player.stunTimer > 0 || player.endLagTimer > 0) return;
  if (player.reloadTimer > 0) return; // can't attack while reloading

  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;

  // If currently in active frames, buffer input
  if (player.attackActiveTimer > 0) {
    player.attackBuffered = true;
    return;
  }

  // If in combo window, advance to next hit (allowed even when exhausted — finish what you started)
  if (player.comboWindowTimer > 0 && player.comboStep > 0 && player.comboStep < maxHits) {
    launchComboHit(player.comboStep);
    return;
  }

  // Exhaustion blocks starting NEW combos only
  if (player.exhaustedTimer > 0) return;

  // Start fresh combo if not in one
  if (player.comboStep === 0) {
    player.comboStep = 1;
    launchComboHit(0);
  }
}

function launchComboHit(stepIndex) {
  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;

  // Stamina cost: all hits cost 12 (7 during Ultra), free if Caffè active
  let staminaPenalty = false;
  const freeStamina = player.consumableTimers.freeStamina > 0;
  const staminaCost = player.ultraActive ? 7 : 12;
  if (!freeStamina) {
    if (player.stamina < staminaCost) {
      staminaPenalty = true; // low stamina: 30% damage, 50% more end-lag
    }
    player.stamina = Math.max(0, player.stamina - staminaCost);
    player.staminaRegenDelay = Math.max(player.staminaRegenDelay, 20);
  }
  // Exhaustion check
  if (!freeStamina && player.stamina <= 0 && player.exhaustedTimer <= 0) {
    player.exhaustedTimer = 60;
    showQuickText('ESAUSTO!', '#ff8f00');
  }

  player.attacking = true;
  player.attackActiveTimer = weap.activeFrames;
  player.attackTimer = weap.activeFrames;
  player.comboWindowTimer = 0;
  player.attackBuffered = false;
  player.comboStep = stepIndex + 1;

  // Calculate damage
  const dmgMult = COMBO_DMG_MULT[Math.min(stepIndex, 3)];
  // Crit: Sanpietrino critCombo special grows crit chance per step
  let critBonus = 0;
  if (weap.special === 'critCombo') {
    critBonus = stepIndex === 1 ? 15 : stepIndex >= 2 ? 35 : 0;
  }
  const upgCrit = player.upgrades.some(u => u.effect === 'crit15') ? 15 : 0;
  const isCrit = Math.random() * 100 < ((weap.crit || 0) + critBonus + upgCrit);
  const dcMult = dodgeCounter > 0 ? 1.5 : 1;
  const staminaMult = staminaPenalty ? 0.3 : 1;
  const upgDmg = player.upgrades.some(u => u.effect === 'dmg15') ? 1.15 : 1;
  const consumableDmg = (player.consumableTimers.dmgBoost > 0) ? 1.3 : 1;
  const ultraMult = player.ultraActive ? 1.5 : 1;
  let dmg = weap.damage * dmgMult * (isCrit ? 2 : 1) * dcMult * staminaMult * upgDmg * consumableDmg * ultraMult;

  // Executioner special: 2.0x on enemies <25% HP during Ultra
  const isExecutioner = weap.special === 'executioner' && player.ultraActive;

  // Range modifiers for Bastone reachControl
  let range = weap.range;
  let hitBothSides = false;
  if (weap.special === 'reachControl') {
    if (stepIndex === 0) range = weap.range * 1.3; // hit 1 extended range
    if (stepIndex === 1) hitBothSides = true;       // hit 2 sweeps both sides
  }

  // Catena crowdPull: always AoE (already hits all in range), Ultra pulls enemies in
  const isCrowdPull = weap.special === 'crowdPull' && player.ultraActive;

  // Ranged weapon shoots projectile(s) — uses ammo system
  if (weap.ranged) {
    // Ammo check: decrement and trigger reload if empty
    if (weap.maxAmmo) {
      if (weap.currentAmmo === undefined) weap.currentAmmo = weap.maxAmmo;
      if (weap.currentAmmo <= 0) return; // shouldn't happen, but safety
      weap.currentAmmo--;
      if (weap.currentAmmo <= 0) {
        player.reloadTimer = weap.reloadFrames || 90;
      }
    }
    const isPiercing = weap.special === 'pierce' ? (weap.name === 'Pistola del Nonno' || stepIndex >= 2) : false;
    projectiles.push({
      x: player.x + player.facing * 20,
      y: player.y - 28,
      vx: player.facing * 8,
      vy: 0,
      life: 40,
      damage: dmg,
      hostile: false,
      type: 'bullet',
      piercing: isPiercing,
      poiseDmg: weap.poise
    });
    playSFX('hit');
    return;
  }

  // Melee hit detection
  const attackX = player.x + player.facing * range * 0.5;
  const hitTargets = [];

  const checkTarget = (t, extraW) => {
    if (!t || t.dead) return;
    const tw = extraW || (t.w || 30) / 2;
    const forwardHit = Math.abs(attackX - t.x) < range * 0.7 + tw && Math.abs(player.y - t.y) < 50;
    // Both-sides hit for Bastone
    let reverseHit = false;
    if (hitBothSides) {
      const reverseX = player.x - player.facing * range * 0.5;
      reverseHit = Math.abs(reverseX - t.x) < range * 0.7 + tw && Math.abs(player.y - t.y) < 50;
    }
    if (forwardHit || reverseHit) hitTargets.push(t);
  };

  // Goon dodge: non-staggered, non-winding-up goons have 10% chance to sidestep melee attacks
  goons.forEach(g => {
    if (!g.dead) {
      if (!g.isBoss && g.staggerTimer <= 0 && g.windupTimer <= 0 && g.launched <= 0 && Math.random() < 0.10) {
        // Dodge! Sidestep away from player
        g.x += Math.sign(g.x - player.x) * 35;
        g.x = Math.max(30, Math.min(W - 30, g.x));
        spawnParticles(g.x, g.y - 20, '#aaa', 3, 2);
        spawnDamageNumber(g.x, g.y - (g.h || 50), 'SCHIVATA!', '#aaa');
      } else {
        checkTarget(g);
      }
    }
  });
  if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) checkTarget(boss, boss.w / 2);
  if (reginaActive && regina && !regina.dead) checkTarget(regina);
  if (mariusoActive && mariuso && !mariuso.dead) checkTarget(mariuso);

  hitTargets.forEach(t => {
    // === SUPER ARMOR CHECK: boss charging with armor deflects hits ===
    if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
      // Boss absorbs hit: reduced damage, no poise damage, reflects pain back
      const reflectDmg = Math.floor(dmg * 0.25);
      t.hp -= dmg * 0.3; // boss takes only 30% damage
      t.hitFlash = 5;
      // Player gets hurt by reflect
      hurtPlayer(reflectDmg);
      // Visuals: armor sparks + bounce-back
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 8, 4);
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'SUPER ARMOR!', '#ff6f00');
      spawnDamageNumber(player.x, player.y - player.h, '-' + reflectDmg, '#f44336');
      screenShake = 6;
      playSFX('stomp');
      player.vx = -player.facing * 5; // knockback the player
      return; // skip normal hit processing for this target
    }

    // Same-target damage penalty: -20% per consecutive hit, floor 30%
    if (t === player.lastHitTarget) {
      player.sameTargetHits++;
      player.sameTargetTimer = 0;
    } else {
      player.sameTargetHits = 1;
      player.lastHitTarget = t;
      player.sameTargetTimer = 0;
    }
    const sameTargetMult = Math.max(0.3, 1 - (player.sameTargetHits - 1) * 0.2);
    let finalDmg = dmg * sameTargetMult;
    // Boss weapon matchup multiplier
    let matchupMult = 1;
    if (t.isBoss) {
      matchupMult = getBossMatchupMult();
      finalDmg *= matchupMult;
    }
    // Ciccio tank mode: 50% damage reduction in phase 3
    if (t.isBoss && t.ciccioTank) {
      finalDmg *= 0.5;
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 2, 1);
    }
    // Executioner: 2.0x on enemies below 25% HP
    if (isExecutioner && t.hp < (t.maxHp || 100) * 0.25) {
      finalDmg *= 2.0;
    }

    let didStagger = false;
    let didKnockdown = false;

    // Poise system: reduce poise instead of applying knockback/recovery
    if (t.poise !== undefined) {
      t.lastHitTimer = 0; // reset poise recovery timer
      // Track consecutive hits for auto-knockdown
      if (t.consecutiveHitCount !== undefined) {
        t.consecutiveHitCount++;
        t.lastHitByPlayerTimer = 0;
      }

      // Auto-knockdown: 12 consecutive hits forces hard knockdown
      if (t.consecutiveHitCount >= 12) {
        t.staggerTimer = 30;
        t.poise = t.maxPoise; // full poise reset
        t.consecutiveHitCount = 0;
        t.poiseBreakCooldown = 0;
        t.knockbackVx = (t.knockbackVx || 0) + player.facing * 8;
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 12, 6);
        spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'KNOCKDOWN!', '#ffeb3b');
        screenShake = 10;
        playSFX('stomp');
        didKnockdown = true;
      } else if (t.poiseBreakCooldown > 0) {
        // During poise break cooldown: hits deal damage but can't reduce poise below 1
        t.poise = Math.max(1, t.poise - weap.poise);
        spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
      } else {
        t.poise -= weap.poise;
        if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
          // POISE BREAK → stagger
          t.staggerTimer = 28;
          t.poise = 0;
          t.poiseBreakCooldown = 70; // 90 frame cooldown before next poise break
          t.consecutiveHitCount = 0;
          finalDmg *= 1.3; // stagger bonus damage
          t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
          spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff9800', 10, 5);
          spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
          screenShake = 8;
          playSFX('stomp');
          // Style bonus coins for stagger break
          spawnCoinPickup(t.x, t.y - 20, 3);
          didStagger = true;
        } else if (t.poise > 0) {
          // Poise held — armor spark, no hitFlash
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        }
      }

      // Warning flash at consecutive hit 5-6 (approaching knockdown)
      if (t.consecutiveHitCount >= 5 && t.consecutiveHitCount < 7 && !didKnockdown) {
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 4, 3);
      }
    } else {
      // Fallback for entities without poise (e.g. old bosses)
      if (!t.isBoss) {
        t.knockbackVx = (t.knockbackVx || 0) + player.facing * (isCrit ? 8 : 5);
      }
    }

    t.hp -= finalDmg;
    // Only set hitFlash on stagger/knockdown, not on armored hits
    if (didStagger || didKnockdown || t.poise === undefined || t.staggerTimer > 0) {
      t.hitFlash = 10;
    }

    // Hitstop
    hitstopFrames = isCrit ? 5 : 3;

    if (isCrit) {
      const label = (dodgeCounter > 0 ? 'COUNTER! ' : 'CRIT! ') + Math.floor(finalDmg);
      spawnDamageNumber(t.x, t.y - (t.h || 50), label, '#ff5722');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff5722', 12, 5);
      screenShake = 8;
      screenFlash = 4;
      flashColor = '#ff5722';
    } else if (dodgeCounter > 0) {
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'COUNTER ' + Math.floor(finalDmg), '#64b5f6');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#64b5f6', 8, 4);
      screenShake = 5;
    } else {
      spawnDamageNumber(t.x, t.y - (t.h || 50), Math.floor(finalDmg), '#ffeb3b');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 6);
      screenShake = Math.max(screenShake, 3);
    }
    playSFX('hit');

    // Weapon matchup visual feedback on boss
    if (t.isBoss && matchupMult >= 1.2) {
      spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'EFFICACE!', '#4caf50');
    } else if (t.isBoss && matchupMult <= 0.75) {
      spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'RESISTE...', '#888');
    }

    // Combo counter
    player.comboHitCount++;
    player.comboHitTimer = 0;
    levelScore += Math.floor(finalDmg * player.scoreMultiplier);
    if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
    else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
    else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
    else player.scoreMultiplier = 1;

    // Ultra charge accumulation
    if (!player.ultraActive) {
      let chargeGain = 5; // base per hit
      if (isCrit) chargeGain = 8;
      if (didStagger) chargeGain = 15;
      player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + chargeGain);
      if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
    }

    // Bleed DoT: Bottiglia/Cacciavite Ultra applies bleed
    if (weap.special === 'bleed' && player.ultraActive) {
      t.bleedTimer = 180;
      t.bleedDmg = 2;
    }

    // Ultra upgrade mods — trigger during Ultra mode
    if (player.ultraActive) {
      if (player.upgrades.some(u => u.effect === 'ultraFire')) {
        t.bleedTimer = Math.max(t.bleedTimer || 0, 180);
        t.bleedDmg = Math.max(t.bleedDmg || 0, 3);
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 6, 3);
      }
      if (player.upgrades.some(u => u.effect === 'ultraIce')) {
        t.slowTimer = 180; // 3 seconds of 30% slow
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#80d8ff', 6, 3);
      }
      if (player.upgrades.some(u => u.effect === 'ultraShock')) {
        // Chain lightning to nearest other enemy
        const others = goons.filter(g => !g.dead && g !== t && Math.abs(g.x - t.x) < 120);
        if (others.length > 0) {
          const chainTarget = others[0];
          chainTarget.hp -= dmg * 0.4;
          chainTarget.hitFlash = 10;
          spawnParticles(chainTarget.x, chainTarget.y - 25, '#ffeb3b', 8, 4);
          spawnDamageNumber(chainTarget.x, chainTarget.y - (chainTarget.h || 50), 'SHOCK ' + Math.floor(dmg * 0.4), '#ffeb3b');
          if (chainTarget.hp <= 0) { chainTarget.dead = true; totalKills++; spawnCoinPickup(chainTarget.x, chainTarget.y - 20, 8); }
        }
      }
      if (player.upgrades.some(u => u.effect === 'ultraVampire')) {
        const heal = Math.floor(finalDmg * 0.08);
        player.hp = Math.min(player.maxHp, player.hp + heal);
        spawnDamageNumber(player.x, player.y - player.h, '+' + heal, '#4caf50');
      }
    }

    // Crowd pull: last hit/Ultra pulls enemies toward player
    if (isCrowdPull) {
      t.knockbackVx = (t.knockbackVx || 0) + Math.sign(player.x - t.x) * 5;
    }

    if (t.hp <= 0 && !t.isBoss) {
      t.dead = true;
      totalKills++;
      spawnParticles(t.x, t.y - 25, '#ffd700', 12);
      // Coin drops (physical pickups)
      const baseDrop = (t.type === 'tank') ? 14 + Math.floor(Math.random() * 6) : 8 + Math.floor(Math.random() * 4);
      spawnCoinPickup(t.x, t.y - 20, baseDrop);
      playSFX('coin');
    }
  });

  // Sbombo Sword: shockwave + heal + particles on every hit
  if (weap.special === 'sbombo') {
    projectiles.push({
      x: player.x + player.facing * 30,
      y: player.y - 28,
      vx: player.facing * 7,
      vy: 0,
      life: 40,
      damage: dmg * 0.6,
      hostile: false,
      type: 'sbombo_wave',
      poiseDmg: 15,
      piercing: true
    });
    player.hp = Math.min(player.maxHp, player.hp + 5);
    screenShake = 4;
    spawnParticles(player.x + player.facing * 40, player.y - 30, '#ff69b4', 8, 5);
    // Ultra: massive AoE every 3rd hit
    if (player.ultraActive && stepIndex % 3 === 2) {
      projectiles.push({ x: player.x, y: player.y - 28, vx: -10, vy: 0, life: 50, damage: dmg, hostile: false, type: 'sbombo_wave', poiseDmg: 25, piercing: true });
      projectiles.push({ x: player.x, y: player.y - 28, vx: 10, vy: 0, life: 50, damage: dmg, hostile: false, type: 'sbombo_wave', poiseDmg: 25, piercing: true });
      screenShake = 12;
      spawnParticles(player.x, player.y - 30, '#ffd700', 20, 8);
    }
  }

  // La Lupa legendaryShockwave: shockwave during Ultra
  if (weap.special === 'legendaryShockwave' && player.ultraActive) {
    projectiles.push({
      x: player.x + player.facing * 30,
      y: player.y - 28,
      vx: player.facing * 8,
      vy: 0,
      life: 45,
      damage: weap.damage * 1.5,
      hostile: false,
      type: 'shockwave',
      poiseDmg: weap.poise * 2,
      piercing: true
    });
    screenShake = 10;
    spawnParticles(player.x, player.y - 30, '#ffd700', 15, 6);
  }
}

// Overhead: Up + Attack — slow overhead slam, 2x poise damage
function playerOverhead() {
  if (player.dead || player.stunTimer > 0 || player.endLagTimer > 0 || player.grabbing || player.exhaustedTimer > 0) return;
  player.stamina = Math.max(0, player.stamina - 28);
  player.staminaRegenDelay = 30;
  player.attacking = true;
  player.attackActiveTimer = 12;
  player.attackTimer = 12;
  player.endLagTimer = 18;

  const weap = weapons[player.weapon];
  const dmg = weap.damage * 1.4;
  const range = weap.range * 0.9;
  const attackX = player.x + player.facing * range * 0.5;

  const targets = [...goons.filter(g => !g.dead)];
  if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) targets.push(boss);

  targets.forEach(t => {
    if (Math.abs(attackX - t.x) < range * 0.7 + (t.w || 30) / 2 && Math.abs(player.y - t.y) < 50) {
      t.hp -= dmg;
      // 2x poise damage
      if (t.poise !== undefined) {
        t.lastHitTimer = 0;
        if (t.consecutiveHitCount !== undefined) {
          t.consecutiveHitCount++;
          t.lastHitByPlayerTimer = 0;
        }
        const poiseDmg = weap.poise * 2;
        if (t.poiseBreakCooldown > 0) {
          t.poise = Math.max(1, t.poise - poiseDmg);
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        } else {
          t.poise -= poiseDmg;
          if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
            t.staggerTimer = 28;
            t.poise = 0;
            t.poiseBreakCooldown = 70;
            t.consecutiveHitCount = 0;
            t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
            spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
            spawnCoinPickup(t.x, t.y - 20, 3);
            t.hitFlash = 10;
          } else {
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          }
        }
      }
      t.hitFlash = 10;
      t.knockbackVx = (t.knockbackVx || 0) + player.facing * 3;
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'OVERHEAD! ' + Math.floor(dmg), '#ff9800');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff9800', 12, 5);
      screenShake = 10;
      playSFX('stomp');
      player.comboHitCount++;
      player.comboHitTimer = 0;
      levelScore += Math.floor(dmg * player.scoreMultiplier);
      if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
      else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
      else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
      else player.scoreMultiplier = 1;
      // Ultra charge from overhead
      if (!player.ultraActive) {
        player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 4);
        if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
      }
      if (t.hp <= 0 && !t.isBoss) {
        t.dead = true;
        totalKills++;
        spawnParticles(t.x, t.y - 25, '#ffd700', 12);
        spawnCoinPickup(t.x, t.y - 20, 20);
        playSFX('coin');
      }
    }
  });
  spawnParticles(player.x + player.facing * 20, player.y - 20, '#ff9800', 10, 4);
}

// Jump attack: standalone aerial attack (not part of combo chain)
function playerJumpAttack() {
  if (player.dead || player.grounded || player.jumpAttacking) return;
  player.jumpAttacking = true;
  player.attacking = true;
  player.attackTimer = 8;
  player.attackActiveTimer = 8;

  const weap = weapons[player.weapon];
  const dmg = weap.damage * 1.2;
  const range = weap.range;
  const attackX = player.x + player.facing * range * 0.5;

  // Ranged weapon shoots downward-angled bullet
  if (weap.ranged) {
    projectiles.push({
      x: player.x + player.facing * 20, y: player.y - 20,
      vx: player.facing * 10, vy: 3,
      life: 40, damage: dmg, hostile: false, type: 'bullet', poiseDmg: weap.poise
    });
    return;
  }

  const targets = [...goons.filter(g => !g.dead)];
  if (boss && !boss.dead) targets.push(boss);
  if (reginaActive && regina && !regina.dead) targets.push(regina);
  if (mariusoActive && mariuso && !mariuso.dead) targets.push(mariuso);

  targets.forEach(t => {
    if (Math.abs(attackX - t.x) < range * 0.7 + (t.w || 30) / 2 && Math.abs(player.y - t.y) < 60) {
      // Super armor: overhead bounces off charging boss
      if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
        t.hp -= dmg * 0.3;
        t.hitFlash = 5;
        hurtPlayer(Math.floor(dmg * 0.2));
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 8, 4);
        spawnDamageNumber(t.x, t.y - (t.h || 50), 'SUPER ARMOR!', '#ff6f00');
        player.vx = -player.facing * 5;
        screenShake = 6;
        playSFX('stomp');
        return;
      }
      const launchBonus = (t.launched && t.launched > 0) ? 1.5 : 1;
      t.hp -= dmg * launchBonus;
      let didStagger = false;
      if (t.poise !== undefined) {
        t.lastHitTimer = 0;
        if (t.consecutiveHitCount !== undefined) {
          t.consecutiveHitCount++;
          t.lastHitByPlayerTimer = 0;
        }
        if (t.poiseBreakCooldown > 0) {
          t.poise = Math.max(1, t.poise - weap.poise);
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        } else {
          t.poise -= weap.poise;
          if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
            t.staggerTimer = 28;
            t.poise = 0;
            t.poiseBreakCooldown = 70;
            t.consecutiveHitCount = 0;
            t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
            spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
            spawnCoinPickup(t.x, t.y - 20, 3);
            didStagger = true;
          } else if (t.poise > 0) {
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          }
        }
      }
      if (didStagger || t.poise === undefined || t.staggerTimer > 0) t.hitFlash = 10;
      const airLabel = launchBonus > 1 ? 'AIR JUGGLE! ' + Math.floor(dmg * launchBonus) : 'AIR ' + Math.floor(dmg);
      spawnDamageNumber(t.x, t.y - (t.h || 50), airLabel, launchBonus > 1 ? '#ffeb3b' : '#80d8ff');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#80d8ff', 8, 4);
      hitstopFrames = 4;
      screenShake = 5;
      playSFX('hit');
      player.comboHitCount++;
      player.comboHitTimer = 0;
      levelScore += Math.floor(dmg * launchBonus * player.scoreMultiplier);
      if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
      else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
      else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
      else player.scoreMultiplier = 1;
      if (t.hp <= 0 && !t.isBoss) {
        t.dead = true;
        totalKills++;
        spawnParticles(t.x, t.y - 25, '#ffd700', 12);
        spawnCoinPickup(t.x, t.y - 20, 6 + Math.floor(Math.random() * 3));
        spawnCoinPickup(t.x, t.y - 30, 4);
        playSFX('coin');
      }
    }
  });
}

// Check bullet/shockwave projectiles against enemies
function checkBulletHits() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    if (p.hostile || (p.type !== 'bullet' && p.type !== 'shockwave' && p.type !== 'sbombo_wave')) continue;

    const targets = [...goons.filter(g => !g.dead)];
    // Only target boss after intro (don't hit offscreen boss during waves)
    if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) targets.push(boss);
    if (reginaActive && regina && !regina.dead) targets.push(regina);
    if (mariusoActive && mariuso && !mariuso.dead) targets.push(mariuso);

    let hitSomething = false;
    for (const t of targets) {
      if (Math.abs(p.x - t.x) < 20 && Math.abs(p.y - (t.y - (t.h||50)/2)) < 30) {
        // Super armor: projectiles deflect off charging boss
        if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
          t.hp -= (p.damage || weapons[0].damage) * 0.3;
          t.hitFlash = 3;
          spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 4, 2);
          spawnDamageNumber(t.x, t.y - (t.h || 50), 'DEFLECT!', '#ff6f00');
          if (!p.piercing) { hitSomething = true; }
          continue;
        }
        let dmg = p.damage || weapons[0].damage;
        // Apply boss weapon matchup to projectiles
        let projMatchup = 1;
        if (t.isBoss) {
          projMatchup = getBossMatchupMult();
          dmg *= projMatchup;
        }
        // Ciccio tank mode: 50% bullet damage reduction
        if (t.isBoss && t.ciccioTank) dmg *= 0.5;
        t.hp -= dmg;
        let didStagger = false;
        // Apply poise damage
        if (t.poise !== undefined && p.poiseDmg) {
          t.lastHitTimer = 0;
          if (t.consecutiveHitCount !== undefined) {
            t.consecutiveHitCount++;
            t.lastHitByPlayerTimer = 0;
          }
          if (t.poiseBreakCooldown > 0) {
            t.poise = Math.max(1, t.poise - p.poiseDmg);
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          } else {
            t.poise -= p.poiseDmg;
            if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
              t.staggerTimer = 28;
              t.poise = 0;
              t.poiseBreakCooldown = 70;
              t.consecutiveHitCount = 0;
              t.knockbackVx = (t.knockbackVx || 0) + Math.sign(p.vx) * 6;
              spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
              spawnCoinPickup(t.x, t.y - 20, 3);
              didStagger = true;
            } else if (t.poise > 0) {
              spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
            }
          }
        }
        if (didStagger || t.poise === undefined || t.staggerTimer > 0) t.hitFlash = 10;
        spawnDamageNumber(t.x, t.y - (t.h||50), Math.floor(dmg), '#ffeb3b');
        spawnParticles(t.x, t.y - (t.h||50)/2, '#ffeb3b', 6);
        if (t.hp <= 0 && !t.isBoss) {
          t.dead = true;
          totalKills++;
          spawnParticles(t.x, t.y - 25, '#ffd700', 12);
          spawnCoinPickup(t.x, t.y - 20, 6 + Math.floor(Math.random() * 3));
          playSFX('coin');
        }
        playSFX('hit');
        // Projectile matchup feedback on boss
        if (t.isBoss && projMatchup >= 1.2) {
          spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'EFFICACE!', '#4caf50');
        } else if (t.isBoss && projMatchup <= 0.75) {
          spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'RESISTE...', '#888');
        }
        player.comboHitCount++;
        player.comboHitTimer = 0;
        levelScore += Math.floor(dmg * player.scoreMultiplier);
        if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
        else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
        else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
        else player.scoreMultiplier = 1;
        hitSomething = true;
        if (!p.piercing) break;
      }
    }
    if (hitSomething && !p.piercing) {
      projectiles.splice(i, 1);
    }
  }
}

// ==========================================
// BOSS AI
// ==========================================
function createBoss(levelIdx) {
  const lvl = levels[levelIdx];
  const b = {
    x: 700, y: 430, w: 44, h: 60,
    vx: 0, vy: 0,
    hp: lvl.bossHp * DIFF_HP[difficulty], maxHp: lvl.bossHp * DIFF_HP[difficulty],
    speed: 2.2 + levelIdx * 0.3,
    facing: -1,
    attackTimer: 0,
    attackCooldown: 60,
    hitFlash: 0,
    stunTimer: 0,
    dead: false,
    isBoss: true,
    phase: 0,
    onMoped: false,
    specialTimer: 0,
    chargeTimer: 0,
    windingUp: false,
    windupTimer: 0,
    recoveryTimer: 0,
    // State machine
    bossPhase: 1,
    bossState: 'idle',
    stateTimer: 0,
    currentMove: null,
    moveData: {},
    // Poise
    poise: [52, 60, 85, 60, 52][levelIdx],
    maxPoise: [52, 60, 85, 60, 52][levelIdx],
    poiseRecovery: 0.45,
    staggerTimer: 0,
    lastHitTimer: 999,
    poiseBreakCooldown: 0,
    consecutiveHitCount: 0,
    lastHitByPlayerTimer: 999,
    bleedTimer: 0,
    bleedDmg: 0
  };

  if (levelIdx === 2) { b.h = 80; b.w = 48; } // Dale is tall
  if (levelIdx === 3) { b.w = 52; } // Ciccio is wider
  if (levelIdx === 4) { b.h = 72; b.w = 38; } // Pisellino is tall and thin

  return b;
}

function triggerPhaseTransition(text, color) {
  phaseTransitionTimer = 90;
  phaseTransitionText = text;
  phaseTransitionColor = color || '#e94560';
  screenShake = 15;
  screenFlash = 10;
  flashColor = color || '#e94560';
  if (boss) boss.stunTimer = 60;
}

function updateBossAI() {
  if (!boss || boss.dead || boss.stunTimer > 0) {
    if (boss && boss.stunTimer > 0) boss.stunTimer--;
    return;
  }

  boss.hitFlash = Math.max(0, boss.hitFlash - 1);
  boss.attackTimer = Math.max(0, boss.attackTimer - 1);
  boss.specialTimer++;

  // Boss poise break cooldown
  if (boss.poiseBreakCooldown > 0) boss.poiseBreakCooldown--;
  // Boss consecutive hit tracking
  boss.lastHitByPlayerTimer++;
  if (boss.lastHitByPlayerTimer > 45) boss.consecutiveHitCount = 0;

  // Boss poise recovery
  if (boss.lastHitTimer !== undefined) {
    boss.lastHitTimer++;
    if (boss.lastHitTimer > 40 && boss.poise < boss.maxPoise && boss.poiseBreakCooldown <= 0) {
      boss.poise = Math.min(boss.maxPoise, boss.poise + (boss.poiseRecovery || 0.3));
    }
    // Boss stagger — interrupts telegraph
    if (boss.staggerTimer > 0) {
      boss.staggerTimer--;
      if (boss.staggerTimer <= 0) boss.poise = boss.maxPoise;
      if (boss.bossState === 'telegraph') {
        boss.bossState = 'recovery';
        boss.stateTimer = 20;
      }
      return;
    }
    // Boss bleed
    if (boss.bleedTimer > 0) {
      boss.bleedTimer--;
      if (boss.bleedTimer % 60 === 0) {
        boss.hp -= boss.bleedDmg;
        spawnParticles(boss.x, boss.y - 30, '#b71c1c', 3, 2);
        spawnDamageNumber(boss.x, boss.y - boss.h, boss.bleedDmg, '#b71c1c');
      }
    }
  }

  const dx = player.x - boss.x;
  const dist = Math.abs(dx);
  boss.facing = dx > 0 ? 1 : -1;

  // Phase transitions based on HP
  if (boss.bossPhase === 1 && boss.hp < boss.maxHp * 0.6) {
    boss.bossPhase = 2;
    boss.bossState = 'idle';
    boss.stateTimer = 0;
    const phaseTexts = [
      '"Sono pazzo... SONO PAZZO DI TE!"',
      '"In gabbia m\'hanno insegnato! REGINAAAA!"',
      '"DALEEEEE! BASTA! SO\' INCAZZATO!"',
      '"ER FORNO E\' APERTO! PIZZA INFERNALE!"',
      '"Time to ride bro! Er motorino della morte!"'
    ];
    triggerPhaseTransition(phaseTexts[currentLevel], levels[currentLevel].bossColor);
    // Level 1: summon Regina in phase 2
    if (currentLevel === 1 && !reginaActive) {
      reginaActive = true;
      regina = {
        x: W + 50, y: 430, w: 32, h: 50,
        hp: 120 * DIFF_HP[difficulty], maxHp: 120 * DIFF_HP[difficulty],
        hitFlash: 0, stunTimer: 0, dead: false,
        throwTimer: 0, entering: true,
        poise: 30, maxPoise: 30, poiseRecovery: 0.45, staggerTimer: 0, lastHitTimer: 999,
        poiseBreakCooldown: 0, consecutiveHitCount: 0, lastHitByPlayerTimer: 999,
        bleedTimer: 0, bleedDmg: 0
      };
    }
  }
  if (boss.bossPhase === 2 && boss.hp < boss.maxHp * 0.3) {
    boss.bossPhase = 3;
    boss.bossState = 'idle';
    boss.stateTimer = 0;
    const phase3Texts = [
      '"Preparate Conte... PREPARATE!"',
      '"In gabbia sognavo sto momento! MO\' PAGHI!"',
      '"DALE DALE DALEEEE! BASTA!"',
      '"HAI VISTO ER MOHAWK?! CE STA IL FUOCO!"',
      '"STO PER CONTO MIO NOW bro! This is MINE!"'
    ];
    triggerPhaseTransition(phase3Texts[currentLevel], '#f44336');
    // Ciccio phase 3: massive size + tank mode + fire aura
    if (currentLevel === 3) {
      boss.w = 72;
      boss.h = 78;
      boss.maxPoise = 120; // massive poise — very hard to stagger
      boss.poise = 120;
      boss.poiseRecovery = 0.8; // fast poise regen
      boss.ciccioTank = true; // flag for 50% damage reduction
      spawnParticles(boss.x, boss.y - 40, '#ff6f00', 25, 8);
      spawnParticles(boss.x, boss.y - 30, '#f44336', 15, 6);
      screenFlash = 8;
      flashColor = '#ff6f00';
      screenShake = 16;
      showQuickText('"SONO DIVENTATO ENORME! ER FORNO BRUCIA!"', '#ff3d00');
    }
    // Level 4: summon Mariuso in phase 3
    if (currentLevel === 4 && !mariusoActive) {
      mariusoActive = true;
      mariuso = {
        x: W + 60, y: 430, w: 50, h: 60,
        hp: 200 * DIFF_HP[difficulty], maxHp: 200 * DIFF_HP[difficulty],
        hitFlash: 0, stunTimer: 0, dead: false,
        attackTimer: 0, isBoss: false, entering: true,
        poise: 50, maxPoise: 50, poiseRecovery: 0.45, staggerTimer: 0, lastHitTimer: 999,
        poiseBreakCooldown: 0, consecutiveHitCount: 0, lastHitByPlayerTimer: 999,
        bleedTimer: 0, bleedDmg: 0
      };
    }
    boss.speed *= 1.2;
  }

  // State machine
  boss.stateTimer--;

  switch(boss.bossState) {
    case 'idle':
      // SYNERGY: Pisellino hangs back when Mariuso is active (let uncle do melee)
      if (currentLevel === 4 && mariusoActive && mariuso && !mariuso.dead) {
        if (dist < 150) boss.x -= Math.sign(dx) * boss.speed * 0.6; // retreat
        else if (dist > 250) boss.x += Math.sign(dx) * boss.speed * 0.3; // keep in range for shots
      } else {
        // Normal approach — later bosses are more aggressive
        const approachMult = 0.8 + currentLevel * 0.1;
        if (dist > 80) boss.x += Math.sign(dx) * boss.speed * approachMult;
        else if (dist < 50) boss.x -= Math.sign(dx) * boss.speed * 0.5;
      }
      // Slight weave — more agitated in later levels
      boss.x += Math.sin(boss.specialTimer * 0.03) * (0.5 + currentLevel * 0.2);

      // Counter-attack system: if player is attacking within range, chance to counter
      // Later levels have higher counter chance
      if (player.attackActiveTimer > 0 && dist < 80 && boss.staggerTimer <= 0) {
        const levelBonus = currentLevel * 0.008;
        const counterChance = (boss.bossPhase === 3 ? 0.03 : boss.bossPhase === 2 ? 0.02 : 0.01) + levelBonus;
        if (Math.random() < counterChance) {
          // Immediate counter with halved telegraph time
          boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, dist);
          boss.bossState = 'telegraph';
          boss.stateTimer = Math.floor((boss.currentMove.telegraphFrames || 15) * 0.5);
          boss.moveData = {};
          spawnDamageNumber(boss.x, boss.y - boss.h - 10, '!', '#f44336');
          break;
        }
      }

      if (boss.stateTimer <= 0) {
        // Pick a move
        boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, dist);
        boss.bossState = 'telegraph';
        boss.stateTimer = boss.currentMove.telegraphFrames || 15;
        boss.moveData = {};
      }
      break;

    case 'telegraph':
      // Boss flashes warning, can be interrupted by stagger
      if (boss.stateTimer <= 0) {
        boss.bossState = 'attack';
        boss.stateTimer = boss.currentMove.attackFrames || 20;
        boss.moveData.started = true;
      }
      break;

    case 'attack':
      // Execute the current move
      executeBossMove(boss.currentMove, dx, dist);
      if (boss.stateTimer <= 0) {
        boss.bossState = 'recovery';
        boss.stateTimer = boss.currentMove.recoveryFrames || 30;
      }
      break;

    case 'recovery':
      // Vulnerability window — boss moves slowly
      if (dist > 100) boss.x += Math.sign(dx) * boss.speed * 0.3;
      if (boss.stateTimer <= 0) {
        boss.bossState = 'idle';
        // Later levels = shorter idle = more aggressive
        const idleBase = Math.max(10, 30 - currentLevel * 5);
        const idleRand = Math.max(10, 30 - currentLevel * 4);
        boss.stateTimer = idleBase + Math.floor(Math.random() * idleRand);
      }
      break;
  }

  // Keep boss in bounds
  boss.x = Math.max(50, Math.min(W - 50, boss.x));

  // Update Regina (L1 helper)
  if (reginaActive && regina && !regina.dead) updateReginaAI();
  // Update Mariuso (L4 helper)
  if (mariusoActive && mariuso && !mariuso.dead) updateMariusoAI();
}

// Boss move selection per level and phase
function pickBossMove(level, phase, dist) {
  const moves = BOSS_MOVES[level] || BOSS_MOVES[0];
  const available = moves.filter(m => m.phase <= phase && (m.minDist === undefined || dist >= m.minDist) && (m.maxDist === undefined || dist <= m.maxDist));
  // Weighted random selection
  const totalW = available.reduce((s, m) => s + (m.weight || 1), 0);
  let r = Math.random() * totalW;
  for (const m of available) {
    r -= (m.weight || 1);
    if (r <= 0) return m;
  }
  return available[available.length - 1] || moves[0];
}

// Execute a boss move during attack state
function executeBossMove(move, dx, dist) {
  if (!move || !move.execute) return;
  move.execute(dx, dist, boss.stateTimer, boss.moveData);
}

// Boss move definitions per level
const BOSS_MOVES = {
  // LaFedeltà — rugby rapper narcisista
  0: [
    { name: 'rugby_tackle', phase: 1, telegraphFrames: 20, attackFrames: 30, recoveryFrames: 35, weight: 4, minDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        // Wind up low, then charge across screen
        if (timer > 25) {
          // Crouch telegraph — boss dips down
          if (!data.yelled) { data.yelled = true; showQuickText('"PLACCAGGIO!"', '#ffd54f'); }
        } else if (timer > 5) {
          // Full sprint charge
          const spd = boss.bossPhase >= 3 ? 11 : 9;
          boss.x += boss.facing * spd;
          // Dust trail
          if (timer % 3 === 0) spawnParticles(boss.x - boss.facing * 20, boss.y, '#8d6e63', 2, 2);
          // Hit detection throughout charge
          if (Math.abs(boss.x - player.x) < 45 && Math.abs(boss.y - player.y) < 40 && !data.hit) {
            data.hit = true;
            const dmg = boss.bossPhase >= 2 ? 30 : 24;
            hurtPlayer(dmg);
            player.vx = boss.facing * 8; // knockback
            screenShake = 12;
            spawnParticles(player.x, player.y - 20, '#ffd54f', 10, 4);
            showQuickText('"META!"', '#ffd54f');
          }
        } else {
          // Brake - skid to stop
          if (timer === 5) spawnParticles(boss.x, boss.y, '#8d6e63', 6, 3);
        }
        // Clamp to screen
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'shoulder_charge', phase: 1, telegraphFrames: 14, attackFrames: 18, recoveryFrames: 28, weight: 3, minDist: 40, superArmor: true,
      execute(dx, dist, timer, data) {
        // Short burst forward with shoulder
        boss.x += boss.facing * 6;
        if (timer === 12 && dist < 65) {
          hurtPlayer(20);
          player.vx = boss.facing * 5;
          screenShake = 6;
          spawnParticles(player.x, player.y - 20, '#ffd54f', 5);
        }
      }},
    { name: 'knife_combo', phase: 1, telegraphFrames: 12, attackFrames: 20, recoveryFrames: 25, weight: 2, maxDist: 70,
      execute(dx, dist, timer, data) {
        if (timer === 16 && dist < 60) { hurtPlayer(18); screenShake = 4; }
        if (timer === 8 && dist < 60) { hurtPlayer(20); screenShake = 5; }
      }},
    { name: 'smoke_bomb', phase: 2, telegraphFrames: 14, attackFrames: 25, recoveryFrames: 20, weight: 2,
      execute(dx, dist, timer, data) {
        if (timer === 22 && !data.smoked) {
          data.smoked = true;
          spawnParticles(boss.x, boss.y - 20, '#888', 20, 6);
          screenShake = 4;
        }
        if (timer === 10) {
          boss.x = player.x - boss.facing * 80;
          spawnParticles(boss.x, boss.y - 20, '#888', 10, 3);
          if (dist < 70) { hurtPlayer(22); }
        }
      }},
    { name: 'rugby_blitz', phase: 2, telegraphFrames: 22, attackFrames: 40, recoveryFrames: 40, weight: 3, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        // Phase 2+: charges back and forth twice
        if (!data.charges) data.charges = 0;
        if (timer > 5) {
          const spd = boss.bossPhase >= 3 ? 12 : 10;
          if (data.charges === 0) {
            boss.x += boss.facing * spd;
          } else {
            boss.x -= boss.facing * spd;
          }
          if (timer % 3 === 0) spawnParticles(boss.x - boss.facing * 15, boss.y, '#8d6e63', 2, 2);
          // Switch direction at halfway
          if (timer === 20 && data.charges === 0) {
            data.charges = 1;
            spawnParticles(boss.x, boss.y, '#ffd54f', 8, 3);
            screenShake = 6;
          }
          // Hit detection
          if (Math.abs(boss.x - player.x) < 45 && Math.abs(boss.y - player.y) < 40) {
            if (!data.hit1 && data.charges === 0) {
              data.hit1 = true;
              hurtPlayer(boss.bossPhase >= 3 ? 25 : 20);
              player.vx = boss.facing * 6;
              screenShake = 8;
            }
            if (!data.hit2 && data.charges === 1) {
              data.hit2 = true;
              hurtPlayer(boss.bossPhase >= 3 ? 28 : 23);
              player.vx = -boss.facing * 6;
              screenShake = 10;
              showQuickText('"ANDATA E RITORNO!"', '#ffd54f');
            }
          }
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'desperation_flurry', phase: 3, telegraphFrames: 15, attackFrames: 30, recoveryFrames: 40, weight: 3, maxDist: 80,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 3;
        if (timer % 7 === 0 && dist < 65) {
          hurtPlayer(15 + Math.floor(Math.random() * 5));
          screenShake = 4;
          spawnParticles(player.x, player.y - 20, '#ffd54f', 4);
        }
      }},
    { name: 'taunt_heal', phase: 2, telegraphFrames: 10, attackFrames: 50, recoveryFrames: 20, weight: 2,
      execute(dx, dist, timer, data) {
        // Taunts for 50 frames, heals 3% HP if not interrupted by stagger
        if (timer === 45 && !data.taunted) { data.taunted = true; showQuickText('"TROPPO BELLO PER TE!"', '#ffd54f'); }
        if (timer === 1 && boss.staggerTimer <= 0) {
          const heal = Math.floor(boss.maxHp * 0.03);
          boss.hp = Math.min(boss.maxHp, boss.hp + heal);
          spawnDamageNumber(boss.x, boss.y - boss.h, '+' + heal, '#4caf50');
          spawnParticles(boss.x, boss.y - 30, '#4caf50', 8, 3);
        }
      }},
    { name: 'scarf_throw', phase: 1, telegraphFrames: 10, attackFrames: 10, recoveryFrames: 25, weight: 1, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 8 && !data.thrown) {
          data.thrown = true;
          const count = boss.bossPhase >= 2 ? 2 : 1;
          for (let i = 0; i < count; i++) {
            projectiles.push({ x: boss.x, y: boss.y - 30, vx: boss.facing * 5 + (i === 1 ? boss.facing * 1.5 : 0), vy: -2, life: 80, damage: boss.bossPhase >= 3 ? 16 : 12, hostile: true, type: 'scarf', gravity: true });
          }
        }
      }},
  ],
  // Gioacchino — heavy enforcer
  1: [
    { name: 'ground_pound', phase: 1, telegraphFrames: 18, attackFrames: 50, recoveryFrames: 40, weight: 2, minDist: 40, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 45) boss.y -= 70;
        if (timer === 20) {
          boss.y = 430;
          screenShake = 18;
          if (Math.abs(boss.x - player.x) < 110) hurtPlayer(boss.bossPhase >= 3 ? 40 : 32);
          spawnParticles(boss.x, boss.y, '#795548', 20, 6);
        }
      }},
    { name: 'charge_tackle', phase: 1, telegraphFrames: 18, attackFrames: 25, recoveryFrames: 35, weight: 2, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 8;
        if (Math.abs(boss.x - player.x) < 40 && Math.abs(boss.y - player.y) < 40) {
          if (!data.hit) { hurtPlayer(boss.bossPhase >= 2 ? 30 : 25); data.hit = true; screenShake = 8; }
        }
      }},
    { name: 'baton_combo', phase: 1, telegraphFrames: 18, attackFrames: 25, recoveryFrames: 25, weight: 3, maxDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 20 && dist < 80) { hurtPlayer(25); screenShake = 5; spawnParticles(player.x, player.y - 20, '#795548', 5); }
        if (timer === 10 && dist < 80 && boss.bossPhase >= 2) { hurtPlayer(18); screenShake = 4; showQuickText('"DOPPIO BASTONE!"', '#6d4c41'); }
      }},
    { name: 'grab_slam', phase: 2, telegraphFrames: 20, attackFrames: 30, recoveryFrames: 35, weight: 2, maxDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 25 && dist < 55 && !data.grabbed) {
          data.grabbed = true;
          player.stunTimer = 25;
          showQuickText('"TE TENGO!"', '#6d4c41');
        }
        if (timer === 5 && data.grabbed) {
          hurtPlayer(38);
          screenShake = 12;
          spawnParticles(player.x, player.y, '#795548', 15, 5);
          showQuickText('"SBAM!"', '#6d4c41');
        }
      }},
    { name: 'guard_counter', phase: 2, telegraphFrames: 12, attackFrames: 40, recoveryFrames: 25, weight: 2, maxDist: 100,
      execute(dx, dist, timer, data) {
        // Guards for 40 frames; if hit during guard → counter-attacks for 30 dmg
        if (timer === 38 && !data.announced) { data.announced = true; showQuickText('"In gabbia ho imparato a para\'! PROVACE!"', '#6d4c41'); }
        // Check if boss got hit during guard
        if (!data.countered && boss.staggerTimer <= 0 && boss.lastHitTimer < 3 && timer > 5) {
          data.countered = true;
          // Refund damage: heal what was just taken
          boss.hp = Math.min(boss.maxHp, boss.hp + 20);
          hurtPlayer(30);
          screenShake = 10;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 10, 4);
          showQuickText('"CONTRATTACCO!"', '#ff6f00');
          spawnDamageNumber(boss.x, boss.y - boss.h, 'GUARD!', '#ff6f00');
        }
        // Visual: boss braces/shimmers
        if (timer % 4 === 0 && !data.countered) spawnParticles(boss.x, boss.y - 30, '#795548', 1, 1);
      }},
    { name: 'rage_flurry', phase: 3, telegraphFrames: 20, attackFrames: 45, recoveryFrames: 45, weight: 3, maxDist: 90,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 4;
        if (timer % 8 === 0 && dist < 80) {
          hurtPlayer(18);
          screenShake = 5;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 4);
        }
      }},
  ],
  // Dale — agile capoeira fighter, acrobatic and unpredictable
  2: [
    { name: 'flying_kick', phase: 1, telegraphFrames: 8, attackFrames: 20, recoveryFrames: 30, weight: 3, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 12;
        if (timer > 14) boss.y -= 3; // rises
        else if (timer > 8) boss.y += 3; // descends
        if (timer === 10 && Math.abs(boss.x - player.x) < 65) {
          hurtPlayer(boss.bossPhase >= 3 ? 34 : 28);
          screenShake = 10;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 10, 5);
          showQuickText('"DALE KICK!"', '#90a4ae');
        }
        if (timer === 1) boss.y = 430; // ensure grounded
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'capoeira_spin', phase: 1, telegraphFrames: 10, attackFrames: 25, recoveryFrames: 25, weight: 3, maxDist: 120,
      execute(dx, dist, timer, data) {
        // Spinning kick — hits twice, moves toward player
        boss.x += boss.facing * 4;
        if (timer % 3 === 0) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 2, 3);
        if (timer === 18 && dist < 80) {
          hurtPlayer(boss.bossPhase >= 2 ? 22 : 18);
          screenShake = 6;
          showQuickText('"GIRA DALE!"', '#90a4ae');
        }
        if (timer === 8 && dist < 80) {
          hurtPlayer(boss.bossPhase >= 3 ? 26 : 20);
          player.vx = boss.facing * 5;
          screenShake = 8;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 8, 4);
        }
      }},
    { name: 'sweep_kick', phase: 1, telegraphFrames: 8, attackFrames: 12, recoveryFrames: 28, weight: 2, maxDist: 100,
      execute(dx, dist, timer, data) {
        if (timer === 6 && dist < 90 && player.grounded) {
          hurtPlayer(24);
          player.stunTimer = 20;
          screenShake = 6;
          showQuickText('"SWEEP!"', '#90a4ae');
          spawnParticles(boss.x + boss.facing * 40, boss.y, '#90a4ae', 6, 3);
        }
      }},
    { name: 'wall_bounce', phase: 2, telegraphFrames: 10, attackFrames: 30, recoveryFrames: 30, weight: 3, minDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        // Charges to wall, bounces off, attacks from other side
        if (!data.phase) data.phase = 0;
        if (data.phase === 0) {
          boss.x += boss.facing * 14;
          if (boss.x <= 40 || boss.x >= W - 40) {
            data.phase = 1;
            boss.facing *= -1;
            spawnParticles(boss.x, boss.y - 30, '#ffeb3b', 10, 4);
            screenShake = 6;
            showQuickText('"RIMBALZO!"', '#90a4ae');
          }
        } else {
          boss.x += boss.facing * 16;
          if (Math.abs(boss.x - player.x) < 55 && Math.abs(boss.y - player.y) < 45 && !data.hit) {
            data.hit = true;
            hurtPlayer(boss.bossPhase >= 3 ? 36 : 30);
            player.vx = boss.facing * 7;
            screenShake = 12;
            spawnParticles(player.x, player.y - 20, '#ff6f00', 12, 5);
          }
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'counter_stance', phase: 2, telegraphFrames: 6, attackFrames: 25, recoveryFrames: 18, weight: 2,
      execute(dx, dist, timer, data) {
        // If hit during this window, teleport behind and strike
        if (!data.countered && boss.staggerTimer <= 0 && timer > 5) {
          if (boss.lastHitTimer < 3) {
            data.countered = true;
            boss.x = player.x - boss.facing * 60;
            boss.facing *= -1;
            spawnParticles(boss.x, boss.y - 30, '#90a4ae', 10, 4);
            hurtPlayer(32);
            screenShake = 8;
            showQuickText('"COUNTER!"', '#ff6f00');
          }
        }
        if (timer % 4 === 0 && !data.countered) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 1, 1);
      }},
    { name: 'dale_ground_pound', phase: 2, telegraphFrames: 12, attackFrames: 30, recoveryFrames: 30, weight: 2,
      execute(dx, dist, timer, data) {
        // Jump up, slam down with shockwaves
        if (timer === 26) { boss.y -= 90; spawnParticles(boss.x, boss.y + 40, '#90a4ae', 8, 4); showQuickText('"DALE SLAM!"', '#90a4ae'); }
        if (timer === 12 && !data.slammed) {
          data.slammed = true;
          boss.y = 430;
          screenShake = 16;
          if (dist < 80 && player.grounded) { hurtPlayer(30); spawnParticles(player.x, player.y - 20, '#90a4ae', 10); }
          projectiles.push({ x: boss.x, y: boss.y - 10, vx: -5, vy: 0, life: 45, damage: 16, hostile: true, type: 'shockwave', poiseDmg: 10, piercing: true });
          projectiles.push({ x: boss.x, y: boss.y - 10, vx: 5, vy: 0, life: 45, damage: 16, hostile: true, type: 'shockwave', poiseDmg: 10, piercing: true });
          spawnParticles(boss.x, boss.y, '#90a4ae', 18, 7);
        }
        if (timer === 1) boss.y = 430;
      }},
    { name: 'feint_backflip', phase: 1, telegraphFrames: 6, attackFrames: 20, recoveryFrames: 22, weight: 2, maxDist: 120,
      execute(dx, dist, timer, data) {
        // Fakes an approach then backflips away and throws a kick
        if (timer > 14) {
          boss.x += boss.facing * 5; // approach
        } else if (timer > 8) {
          boss.x -= boss.facing * 8; // backflip away
          if (timer === 10) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 6, 3);
        } else if (timer === 5 && dist < 100) {
          // Long range kick on return
          hurtPlayer(boss.bossPhase >= 2 ? 26 : 22);
          screenShake = 6;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 6);
          showQuickText('"FINTA!"', '#90a4ae');
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'berserker_rush', phase: 3, telegraphFrames: 10, attackFrames: 40, recoveryFrames: 35, weight: 4, maxDist: 150, superArmor: true,
      execute(dx, dist, timer, data) {
        // Phase 3: wild zigzag rush with multiple hits
        if (!data.zigDir) data.zigDir = 1;
        boss.x += boss.facing * 8;
        boss.x += data.zigDir * 3;
        if (timer % 8 === 0) { data.zigDir *= -1; spawnParticles(boss.x, boss.y, '#ff6f00', 3, 2); }
        if (timer % 6 === 0 && dist < 70) {
          hurtPlayer(18);
          screenShake = 5;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 5);
        }
        if (timer === 20) showQuickText('"DALE DALE DALEEEE!"', '#ff6f00');
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
  ],
  // Ciccio — tank with chains
  3: [
    { name: 'chain_whip', phase: 1, telegraphFrames: 15, attackFrames: 15, recoveryFrames: 30, weight: 3, minDist: 60,
      execute(dx, dist, timer, data) {
        if (timer === 8 && dist < 150) {
          hurtPlayer(boss.bossPhase >= 2 ? 24 : 18);
          // Pull player toward boss
          if (dist > 60) player.x += Math.sign(boss.x - player.x) * 40;
          screenShake = 6;
          showQuickText('"VIENI QUA!"', '#f44336');
        }
      }},
    { name: 'body_slam', phase: 1, telegraphFrames: 15, attackFrames: 20, recoveryFrames: 35, weight: 2, maxDist: 70, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 10 && dist < 70) { hurtPlayer(boss.bossPhase >= 3 ? 32 : 26); screenShake = 12; spawnParticles(boss.x, boss.y, '#f44336', 12, 5); }
      }},
    { name: 'chain_spin', phase: 2, telegraphFrames: 18, attackFrames: 30, recoveryFrames: 35, weight: 2, superArmor: true,
      execute(dx, dist, timer, data) {
        // 360 AoE, must dodge through or stay far
        if (timer % 10 === 0 && dist < 120) { hurtPlayer(20); screenShake = 5; }
        spawnParticles(boss.x + Math.cos(timer * 0.5) * 60, boss.y - 20 + Math.sin(timer * 0.5) * 30, '#f44336', 2, 2);
      }},
    { name: 'earthquake', phase: 3, telegraphFrames: 18, attackFrames: 40, recoveryFrames: 40, weight: 3, superArmor: true,
      execute(dx, dist, timer, data) {
        // 3 successive shockwaves
        if ((timer === 35 || timer === 25 || timer === 15) && player.grounded) {
          if (dist < 200) { hurtPlayer(24); screenShake = 10; }
          spawnParticles(boss.x, boss.y, '#ff6f00', 15, 6);
          showQuickText('"TERREMOTO!"', '#ff3d00');
        }
      }},
    { name: 'pizza_throw', phase: 1, telegraphFrames: 12, attackFrames: 10, recoveryFrames: 25, weight: 2, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 8 && !data.thrown) {
          data.thrown = true;
          const spread = boss.bossPhase >= 2 ? 2 : 1;
          for (let i = -spread; i <= spread; i++) {
            projectiles.push({ x: boss.x, y: boss.y - 30, vx: boss.facing * 4 + i * 1.5, vy: -2 + Math.abs(i), life: 100, damage: boss.bossPhase >= 3 ? 24 : 18, hostile: true, type: 'pizza', gravity: true });
          }
        }
      }},
    { name: 'pizza_rain', phase: 3, telegraphFrames: 18, attackFrames: 30, recoveryFrames: 35, weight: 3,
      execute(dx, dist, timer, data) {
        // Throws 5 pizza projectiles in arcs for area denial
        if (timer === 25 && !data.rained) {
          data.rained = true;
          showQuickText('"PIOGGIA DI PIZZA!"', '#ff3d00');
          for (let i = 0; i < 5; i++) {
            const angle = -0.4 + i * 0.2;
            projectiles.push({
              x: boss.x, y: boss.y - 40,
              vx: Math.cos(angle) * 3 * boss.facing + (Math.random() - 0.5) * 2,
              vy: -5 - Math.random() * 3,
              life: 120, damage: 20, hostile: true, type: 'pizza', gravity: true
            });
          }
          spawnParticles(boss.x, boss.y - 40, '#ff6f00', 10, 4);
          screenShake = 6;
        }
      }},
  ],
  // Pisellino — gang leader, all-rounder
  4: [
    { name: 'pistol_burst', phase: 1, telegraphFrames: 14, attackFrames: 20, recoveryFrames: 25, weight: 3, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 16 || timer === 12 || timer === 8) {
          projectiles.push({ x: boss.x, y: boss.y - 35, vx: boss.facing * 8, vy: (Math.random() - 0.5) * 2, life: 60, damage: boss.bossPhase >= 3 ? 22 : 16, hostile: true, type: 'bullet', color: '#b0bec5' });
          playSFX('hit');
        }
      }},
    { name: 'summon_goons', phase: 1, telegraphFrames: 14, attackFrames: 10, recoveryFrames: 40, weight: 1,
      execute(dx, dist, timer, data) {
        if (timer === 5 && !data.summoned) {
          data.summoned = true;
          const count = boss.bossPhase >= 2 ? 2 : 1;
          const types = ENEMY_TYPES[4] || ENEMY_TYPES[0];
          for (let i = 0; i < count; i++) {
            const t = types[Math.floor(Math.random() * types.length)];
            goons.push({
              x: boss.x + (i === 0 ? -80 : 80), y: GROUND_Y, w: t.w, h: t.h,
              hp: t.hp * 0.6 * DIFF_HP[difficulty], maxHp: t.hp * 0.6 * DIFF_HP[difficulty], speed: t.speed, damage: t.dmg,
              attackTimer: 60 + Math.random() * 60, hitFlash: 0, stunTimer: 0, dead: false,
              color: t.color, hat: t.hat, name: t.name, type: t.type, shootTimer: 0,
              flankDir: Math.random() > 0.5 ? 1 : -1, knockbackVx: 0, windupTimer: 0,
              poise: t.poise || 15, maxPoise: t.poise || 15, poiseRecovery: t.poiseRecovery || 0.25,
              staggerTimer: 0, lastHitTimer: 999, poiseBreakCooldown: 0,
              consecutiveHitCount: 0, lastHitByPlayerTimer: 999, bleedTimer: 0, bleedDmg: 0
            });
          }
          showQuickText('"GET HIM BOYS!"', '#b0bec5');
        }
      }},
    { name: 'molotov', phase: 2, telegraphFrames: 16, attackFrames: 15, recoveryFrames: 30, weight: 2, minDist: 60,
      execute(dx, dist, timer, data) {
        if (timer === 10 && !data.thrown) {
          data.thrown = true;
          projectiles.push({ x: boss.x, y: boss.y - 35, vx: (player.x - boss.x) * 0.04, vy: -4, life: 50, damage: 22, hostile: true, type: 'molotov', gravity: true });
          showQuickText('"BRUCIA! BURN BRO!"', '#ff6f00');
        }
      }},
    { name: 'teleport_strike', phase: 1, telegraphFrames: 10, attackFrames: 12, recoveryFrames: 25, weight: 2, maxDist: 200,
      execute(dx, dist, timer, data) {
        if (timer === 10 && !data.teleported) {
          data.teleported = true;
          boss.x += (Math.random() > 0.5 ? 1 : -1) * 130;
          boss.x = Math.max(50, Math.min(W - 50, boss.x));
          spawnParticles(boss.x, boss.y - 30, '#b0bec5', 8);
        }
        if (timer === 4 && Math.abs(boss.x - player.x) < 60) { hurtPlayer(28); screenShake = 5; }
      }},
    { name: 'desperate_dual', phase: 3, telegraphFrames: 12, attackFrames: 30, recoveryFrames: 25, weight: 4, maxDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 4;
        if (timer % 5 === 0 && dist < 65) {
          hurtPlayer(16);
          screenShake = 4;
          spawnParticles(player.x, player.y - 20, '#b0bec5', 4);
        }
      }},
    { name: 'melee', phase: 1, telegraphFrames: 12, attackFrames: 10, recoveryFrames: 20, weight: 2, maxDist: 65,
      execute(dx, dist, timer, data) {
        if (timer === 5 && dist < 65) { hurtPlayer(boss.bossPhase >= 3 ? 26 : 20); screenShake = 4; }
      }},
    { name: 'shadow_decoy', phase: 3, telegraphFrames: 10, attackFrames: 50, recoveryFrames: 20, weight: 3,
      execute(dx, dist, timer, data) {
        // Teleports away, leaves decoy that explodes after delay
        if (timer === 45 && !data.teleported) {
          data.teleported = true;
          data.decoyX = boss.x;
          data.decoyY = boss.y;
          // Teleport boss to opposite side
          boss.x = boss.x > W/2 ? 100 + Math.random() * 150 : W - 100 - Math.random() * 150;
          boss.x = Math.max(50, Math.min(W - 50, boss.x));
          spawnParticles(data.decoyX, data.decoyY - 30, '#b0bec5', 10, 3);
          spawnParticles(boss.x, boss.y - 30, '#b0bec5', 6, 3);
          showQuickText('"NOW YOU SEE ME..."', '#b0bec5');
        }
        // Draw decoy shimmer
        if (data.decoyX && timer > 10 && timer < 45) {
          const shimmer = Math.sin(gameTime * 0.3) * 0.3 + 0.5;
          spawnParticles(data.decoyX + (Math.random() - 0.5) * 20, data.decoyY - 30, '#b0bec5', 1, 1);
        }
        // Decoy explodes
        if (timer === 10 && data.decoyX) {
          const decoyDist = Math.abs(player.x - data.decoyX);
          if (decoyDist < 90 && Math.abs(player.y - data.decoyY) < 50) {
            hurtPlayer(28);
            screenShake = 10;
          }
          spawnParticles(data.decoyX, data.decoyY - 20, '#f44336', 15, 6);
          showQuickText('"BOOM BRO!"', '#f44336');
          screenShake = 8;
        }
      }},
  ]
};

// Old individual boss AI functions removed — replaced by state machine above

// Regina AI helper (L1 boss phase 2+) — SYNERGY: hides behind Gioacchino, fires from cover
function updateReginaAI() {
  regina.hitFlash = Math.max(0, regina.hitFlash - 1);
  if (regina.stunTimer > 0) { regina.stunTimer--; return; }
  if (regina.entering) {
    regina.x += (650 - regina.x) * 0.05;
    if (Math.abs(regina.x - 650) < 5) regina.entering = false;
    return;
  }
  // Poise break cooldown
  if (regina.poiseBreakCooldown > 0) regina.poiseBreakCooldown--;
  regina.lastHitByPlayerTimer++;
  if (regina.lastHitByPlayerTimer > 45) regina.consecutiveHitCount = 0;
  if (regina.staggerTimer > 0) { regina.staggerTimer--; if (regina.staggerTimer <= 0) regina.poise = regina.maxPoise; return; }
  regina.lastHitTimer++;
  if (regina.lastHitTimer > 60 && regina.poise < regina.maxPoise && regina.poiseBreakCooldown <= 0) {
    regina.poise = Math.min(regina.maxPoise, regina.poise + regina.poiseRecovery);
  }

  // === SYNERGY: Regina positions BEHIND Gioacchino (opposite side from player) ===
  if (boss && !boss.dead) {
    const behindX = boss.x - Math.sign(player.x - boss.x) * 60; // behind boss relative to player
    const targetX = Math.max(40, Math.min(W - 40, behindX));
    regina.x += (targetX - regina.x) * 0.06; // smooth follow
  } else {
    // Boss dead: Regina panics, backs away
    if (Math.abs(player.x - regina.x) < 150) regina.x -= Math.sign(player.x - regina.x) * 1.5;
  }

  regina.throwTimer++;
  // Throw rate: faster when Gioacchino is attacking (covering fire)
  const bossAttacking = boss && !boss.dead && boss.bossState === 'attack';
  const throwInterval = bossAttacking ? 50 : 80; // much faster during boss attacks
  if (regina.throwTimer % throwInterval === 0) {
    const targetY = player.y - player.h / 2;
    const originY = regina.y - 25;
    const angle = Math.atan2(targetY - originY, player.x - regina.x);
    projectiles.push({ x: regina.x, y: originY, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, life: 120, damage: 14, hostile: true, type: 'meat' });
    spawnParticles(regina.x, originY, '#d32f2f', 3, 2);
    // During boss attack: also fire a second angled shot
    if (bossAttacking) {
      projectiles.push({ x: regina.x, y: originY, vx: Math.cos(angle + 0.3) * 3.5, vy: Math.sin(angle + 0.3) * 3.5, life: 100, damage: 10, hostile: true, type: 'meat' });
    }
  }

  // === SYNERGY: Retaliation shot when player hits Gioacchino ===
  if (boss && !boss.dead && boss.lastHitTimer < 2 && regina.throwTimer > 10) {
    const retAngle = Math.atan2((player.y - 20) - regina.y, player.x - regina.x);
    projectiles.push({ x: regina.x, y: regina.y - 25, vx: Math.cos(retAngle) * 5, vy: Math.sin(retAngle) * 5, life: 80, damage: 16, hostile: true, type: 'meat' });
    spawnParticles(regina.x, regina.y - 25, '#e91e63', 4, 2);
    regina.throwTimer = 0; // reset throw cooldown
  }

  if (regina.hp <= 0) {
    regina.dead = true;
    spawnParticles(regina.x, regina.y - 25, '#e91e63', 15);
    showQuickText('"REGINA NOOOO!"', '#e91e63');
    boss.stunTimer = 60;
    boss.speed += 1.0;
  }
}

// Mariuso AI helper (L4 boss phase 3) — SYNERGY: pincer attacks with Pisellino
function updateMariusoAI() {
  mariuso.hitFlash = Math.max(0, mariuso.hitFlash - 1);
  if (mariuso.stunTimer > 0) { mariuso.stunTimer--; return; }
  if (mariuso.entering) {
    mariuso.x += (200 - mariuso.x) * 0.04;
    if (Math.abs(mariuso.x - 200) < 10) mariuso.entering = false;
    return;
  }
  // Poise management
  if (mariuso.poiseBreakCooldown > 0) mariuso.poiseBreakCooldown--;
  mariuso.lastHitByPlayerTimer++;
  if (mariuso.lastHitByPlayerTimer > 45) mariuso.consecutiveHitCount = 0;
  if (mariuso.staggerTimer > 0) { mariuso.staggerTimer--; if (mariuso.staggerTimer <= 0) mariuso.poise = mariuso.maxPoise; return; }
  mariuso.lastHitTimer++;
  if (mariuso.lastHitTimer > 60 && mariuso.poise < mariuso.maxPoise && mariuso.poiseBreakCooldown <= 0) {
    mariuso.poise = Math.min(mariuso.maxPoise, mariuso.poise + mariuso.poiseRecovery);
  }

  // === SYNERGY: Mariuso rushes in while Pisellino keeps distance (pincer) ===
  if (!mariuso.pincerTimer) mariuso.pincerTimer = 0;
  mariuso.pincerTimer++;

  const mdx = player.x - mariuso.x;
  const mdist = Math.abs(mdx);

  // Mariuso aggressively chases player
  mariuso.x += Math.sign(mdx) * 3.2;

  mariuso.attackTimer = Math.max(0, mariuso.attackTimer - 1);
  if (mdist < 55 && mariuso.attackTimer === 0) {
    hurtPlayer(28);
    mariuso.attackTimer = 30;
    screenShake = 8;
    spawnParticles(player.x, player.y - 20, '#7b1fa2', 8);
    showQuickText('"MARIUSO COLPISCE!"', '#ce93d8');
  }

  // === SYNERGY: Pisellino teleports behind player for pincer every 200 frames ===
  if (mariuso.pincerTimer % 200 === 0 && boss && !boss.dead && boss.bossState === 'idle' && mdist < 80) {
    // Pisellino teleports behind the player while Mariuso attacks from front
    const behindPlayer = player.x - Math.sign(mdx) * 100;
    boss.x = Math.max(50, Math.min(W - 50, behindPlayer));
    boss.facing = Math.sign(player.x - boss.x);
    spawnParticles(boss.x, boss.y - 30, '#b0bec5', 10, 4);
    screenShake = 5;
    showQuickText('"PINZA BRO! PINZA!"', '#b0bec5');
    // Pisellino immediately attacks
    boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, Math.abs(player.x - boss.x));
    boss.bossState = 'telegraph';
    boss.stateTimer = Math.floor((boss.currentMove.telegraphFrames || 15) * 0.4); // very fast telegraph
    boss.moveData = {};
  }

  // === SYNERGY: When Mariuso gets staggered, Pisellino teleports to cover him ===
  if (mariuso.staggerTimer === 27 && boss && !boss.dead) { // just started stagger
    boss.x = mariuso.x + Math.sign(mariuso.x - player.x) * 50;
    boss.x = Math.max(50, Math.min(W - 50, boss.x));
    boss.facing = Math.sign(player.x - boss.x);
    spawnParticles(boss.x, boss.y - 30, '#b0bec5', 8, 3);
    showQuickText('"STAY AWAY FROM MY UNCLE!"', '#b0bec5');
    // Fire covering shots
    for (let i = 0; i < 3; i++) {
      projectiles.push({ x: boss.x, y: boss.y - 35, vx: boss.facing * 7 + (i - 1) * 2, vy: (Math.random() - 0.5) * 3, life: 60, damage: 14, hostile: true, type: 'bullet', color: '#b0bec5' });
    }
  }

  if (mariuso.hp <= 0) {
    mariuso.dead = true;
    spawnParticles(mariuso.x, mariuso.y - 30, '#7b1fa2', 20);
    showQuickText('"NO BRO... UNCLE... That\'s it. BASTA."', '#76ff03');
    boss.speed += 1.0;
    spawnCoinPickup(mariuso.x, mariuso.y - 30, 30);
  }
}

// Legacy stubs (old boss AIs removed — state machine handles everything)
function aiGioacchino() {}

// ==========================================
// GOON AI
// ==========================================
// Enemy types per level
// Goon nickname pools per type — randomly assigned on spawn for personality
const GOON_NICKNAMES = {
  0: { // Via Plava: Lazio ultras
    rusher: ['Zorzetto', 'Bianchino', 'Er Laziale', 'Aquilotto', 'Polverino'],
    tank: ['Bulldozer', 'Er Muro', 'Bestione', 'Zampone', 'Testacalda'],
  },
  1: { // Down Under Pub
    drunk: ['Vino Rosso', 'Sbronzetto', 'Er Barcollone', 'Gino Pinta', 'Ciuccio'],
    tank: ['Buttafuori', 'Nerone', 'Portone', 'Er Gorilla', 'Black'],
    thrower: ['Shaker', 'Er Cocktail', 'Barman', 'Colpo Secco', 'Oliva'],
  },
  2: { // Piazza Bainsizza: street
    rusher: ['Coltellaccio', 'Stradaiolo', 'Fumetto', 'Selciato', 'Rattazzo'],
    flanker: ['Ombra', 'Sveltino', 'Er Fantasma', 'Furetto', 'Sguscio'],
    tank: ['Macigno', 'Er Grosso', 'Bidone', 'Masso', 'Colosseo'],
  },
  3: { // Pizzarium: pizza fighters
    thrower: ['Mozzarella', 'Pomodorino', 'Farina', 'Lievitino', 'Condimento'],
    rusher: ['Motorino', 'Express', 'Scooterino', 'Freccia', 'Consegna'],
    tank: ['Forno', 'Impasto', 'Sfornata', 'Pala', 'Lievito Madre'],
  },
  4: { // Piazza Mazzini: elite
    rusher: ['Soldatino', 'Recluta', 'Caporale', 'Fucile', 'Er Marziale'],
    ranged: ['Mirino', 'Sniper', 'Occhio', 'Grilletto', 'Silenzio'],
    tank: ['Corazza', 'Bunker', 'Er Blindato', 'Fortezza', 'Trincea'],
    flanker: ['Pestifero', 'Monello', 'Lametta', 'Scattino', 'Trottolino'],
  }
};

const ENEMY_TYPES = {
  // Level 0 - Via Plava: rugby hooligans + Lazio tifosi
  0: [
    { name: 'Tifoso', color: '#1565c0', hp: 110, speed: 1.5, dmg: 9, w: 32, h: 50, type: 'rusher', hat: '#64b5f6', poise: 25, poiseRecovery: 0.4 },
    { name: 'Hooligan', color: '#455a64', hp: 220, speed: 0.9, dmg: 14, w: 36, h: 52, type: 'tank', hat: '#90a4ae', poise: 65, poiseRecovery: 0.55 },
  ],
  // Level 1 - Down Under Pub: drunk pub guys + bouncers
  1: [
    { name: 'Ubriaco', color: '#5d4037', hp: 90, speed: 1.7, dmg: 8, w: 30, h: 48, type: 'drunk', hat: '#8d6e63', poise: 20, poiseRecovery: 0.3 },
    { name: 'Bouncer', color: '#212121', hp: 250, speed: 0.7, dmg: 16, w: 40, h: 56, type: 'tank', hat: '#424242', poise: 72, poiseRecovery: 0.55 },
    { name: 'Barista', color: '#4e342e', hp: 105, speed: 1.1, dmg: 12, w: 30, h: 48, type: 'thrower', hat: '#6d4c41', poise: 25, poiseRecovery: 0.4 },
  ],
  // Level 2 - Piazza Bainsizza: street toughs
  2: [
    { name: 'Teppista', color: '#37474f', hp: 155, speed: 1.4, dmg: 12, w: 32, h: 50, type: 'rusher', hat: '#546e7a', poise: 30, poiseRecovery: 0.4 },
    { name: 'Spacciatore', color: '#1b5e20', hp: 105, speed: 2.0, dmg: 9, w: 28, h: 46, type: 'flanker', hat: '#2e7d32', poise: 24, poiseRecovery: 0.4 },
    { name: 'Grosso', color: '#424242', hp: 335, speed: 0.6, dmg: 20, w: 44, h: 58, type: 'tank', hat: '#616161', poise: 80, poiseRecovery: 0.6 },
  ],
  // Level 3 - Pizzarium: pizza workers + delivery guys
  3: [
    { name: 'Garzone', color: '#fff', hp: 100, speed: 1.6, dmg: 10, w: 30, h: 48, type: 'thrower', hat: '#f44336', poise: 24, poiseRecovery: 0.4 },
    { name: 'Fattorino', color: '#ff8f00', hp: 140, speed: 2.2, dmg: 12, w: 30, h: 48, type: 'rusher', hat: '#ffc107', poise: 28, poiseRecovery: 0.4 },
    { name: 'Impastatore', color: '#fff', hp: 310, speed: 0.8, dmg: 19, w: 42, h: 54, type: 'tank', hat: '#d32f2f', poise: 78, poiseRecovery: 0.55 },
  ],
  // Level 4 - Piazza Mazzini: Valle Aurelia gang elite
  4: [
    { name: 'Soldato', color: '#263238', hp: 170, speed: 1.7, dmg: 14, w: 32, h: 52, type: 'rusher', hat: '#37474f', poise: 34, poiseRecovery: 0.5 },
    { name: 'Cecchino', color: '#1a1a2e', hp: 100, speed: 0.9, dmg: 19, w: 28, h: 48, type: 'ranged', hat: '#311b92', poise: 20, poiseRecovery: 0.4 },
    { name: 'Guardaspalle', color: '#1a1a1a', hp: 380, speed: 0.7, dmg: 22, w: 46, h: 60, type: 'tank', hat: '#333', poise: 88, poiseRecovery: 0.6 },
    { name: 'Scugnizzo', color: '#4a148c', hp: 90, speed: 2.8, dmg: 9, w: 26, h: 44, type: 'flanker', hat: '#7b1fa2', poise: 24, poiseRecovery: 0.4 },
  ]
};

function spawnGoons(count) {
  // Dead goons already pruned in updateGoons
  const types = ENEMY_TYPES[currentLevel] || ENEMY_TYPES[0];
  for (let i = 0; i < count; i++) {
    const t = types[i % types.length];
    // Spawn offscreen and walk in (alternating sides)
    const spawnSide = (i % 2 === 0) ? W + 40 + i * 30 : -40 - i * 30;
    // Assign a random nickname from the level's pool
    const nickPool = GOON_NICKNAMES[currentLevel] && GOON_NICKNAMES[currentLevel][t.type];
    const nickname = nickPool ? nickPool[Math.floor(Math.random() * nickPool.length)] : t.name;
    goons.push({
      x: spawnSide,
      y: GROUND_Y,
      entering: true, // walk-in flag
      w: t.w, h: t.h,
      hp: t.hp * DIFF_HP[difficulty], maxHp: t.hp * DIFF_HP[difficulty],
      speed: t.speed,
      damage: t.dmg,
      attackTimer: 60 + Math.random() * 60,
      hitFlash: 0,
      stunTimer: 0,
      dead: false,
      color: t.color,
      hat: t.hat,
      name: nickname,
      typeName: t.name,
      type: t.type,
      shootTimer: 0,
      flankDir: Math.random() > 0.5 ? 1 : -1,
      knockbackVx: 0,
      windupTimer: 0,
      phaseOffset: Math.random() * Math.PI * 2, // unique movement phase
      // Poise system
      poise: t.poise || 15,
      maxPoise: t.poise || 15,
      poiseRecovery: t.poiseRecovery || 0.25,
      staggerTimer: 0,
      lastHitTimer: 999, // frames since last hit (starts high so poise recovery works)
      poiseBreakCooldown: 0, // frames after poise break where poise can't be broken again
      consecutiveHitCount: 0, // for auto-knockdown system
      lastHitByPlayerTimer: 999, // frames since last player hit (for consecutive hit reset)
      bleedTimer: 0,
      bleedDmg: 0
    });
  }
}

function updateGoons() {
  // Prune dead goons every frame to keep array lean
  goons = goons.filter(g => !g.dead);
  const aliveCount = goons.length;

  // Aggression slots: max 5 enemies attack simultaneously, others circle at medium range
  const MAX_ATTACKERS = 5;
  let attackingCount = 0;
  for (let i = 0; i < goons.length; i++) {
    const g = goons[i];
    if (g.windupTimer > 0 || (g.attackTimer > 0 && g.attackTimer < 20)) attackingCount++;
  }
  const attackSlotsAvailable = MAX_ATTACKERS - attackingCount;

  goons.forEach(g => {
    // Walk-in animation: move toward play area from offscreen
    if (g.entering) {
      if (!g.enterTarget) g.enterTarget = 200 + Math.random() * 400;
      const dir = g.x < g.enterTarget ? 1 : -1;
      g.x += dir * g.speed * 2.5;
      if (Math.abs(g.x - g.enterTarget) < 10) { g.entering = false; g.enterTarget = null; }
      return;
    }
    g.hitFlash = Math.max(0, g.hitFlash - 1);
    // Apply hazard slow
    const origSpeed = g.speed;
    if (g.hazardSlow) g.speed *= 0.7;
    if (g.slowTimer > 0) { g.slowTimer--; g.speed *= 0.7; }
    if (g.stunTimer > 0) { g.stunTimer--; g.speed = origSpeed; return; }

    // Poise break cooldown timer
    if (g.poiseBreakCooldown > 0) g.poiseBreakCooldown--;

    // Consecutive hit reset: if not hit for 45 frames, reset counter
    g.lastHitByPlayerTimer++;
    if (g.lastHitByPlayerTimer > 45) g.consecutiveHitCount = 0;

    // Launched state: enemy floating above ground, takes 1.5x from jump attacks
    if (g.launched > 0) {
      g.launched--;
      const launchProgress = g.launched / 40;
      g.y = (g.launchY || GROUND_Y) - Math.sin(launchProgress * Math.PI) * 80;
      if (g.launched <= 0) {
        g.y = GROUND_Y;
        g.stunTimer = Math.max(g.stunTimer, 15);
      }
      // Apply knockback while launched
      if (Math.abs(g.knockbackVx) > 0.2) {
        g.x += g.knockbackVx;
        g.knockbackVx *= 0.9;
      }
      return;
    }

    // Stagger: enemy can't act, flashes, takes bonus damage
    if (g.staggerTimer > 0) {
      g.staggerTimer--;
      if (g.staggerTimer <= 0) {
        // Poise resets to full after stagger ends
        g.poise = g.maxPoise;
      }
      // Still apply knockback during stagger
      if (Math.abs(g.knockbackVx) > 0.2) {
        g.x += g.knockbackVx;
        g.knockbackVx *= 0.82;
      } else {
        g.knockbackVx = 0;
      }
      return; // Can't act during stagger
    }

    // Knockback physics
    if (Math.abs(g.knockbackVx) > 0.2) {
      g.x += g.knockbackVx;
      g.knockbackVx *= 0.82;
    } else {
      g.knockbackVx = 0;
    }

    // Poise recovery: if not hit for 40 frames and not in poise break cooldown, regenerate poise
    g.lastHitTimer++;
    if (g.lastHitTimer > 40 && g.poise < g.maxPoise && g.poiseBreakCooldown <= 0) {
      g.poise = Math.min(g.maxPoise, g.poise + g.poiseRecovery);
    }

    // Bleed DoT
    if (g.bleedTimer > 0) {
      g.bleedTimer--;
      if (g.bleedTimer % 60 === 0) {
        g.hp -= g.bleedDmg;
        spawnParticles(g.x, g.y - 20, '#b71c1c', 3, 2);
        spawnDamageNumber(g.x, g.y - (g.h || 50), g.bleedDmg, '#b71c1c');
        if (g.hp <= 0 && !g.dead) {
          g.dead = true;
          totalKills++;
          spawnParticles(g.x, g.y - 25, '#ffd700', 12);
          spawnCoinPickup(g.x, g.y - 20, 6 + Math.floor(Math.random() * 3));
          playSFX('coin');
        }
      }
    }

    // Windup - telegraphed attack about to fire
    if (g.windupTimer > 0) {
      // Dust on first frame
      if (!g.windupStarted) { g.windupStarted = true; g.windupMax = g.windupTimer; spawnParticles(g.x, g.y, '#9e8e7e', 3, 2); }
      g.windupTimer--;
      if (g.windupTimer === 0 && !player.dead) {
        const dx = player.x - g.x;
        const dist = Math.abs(dx);
        if (g.type === 'thrower') {
          const pType = currentLevel === 3 ? 'pizza' : 'meat';
          projectiles.push({
            x: g.x, y: g.y - 25,
            vx: Math.sign(dx) * 4.5, vy: -2.5,
            life: 80, damage: g.damage, hostile: true,
            type: pType, gravity: true
          });
        } else if (g.type === 'ranged') {
          projectiles.push({
            x: g.x, y: g.y - 25,
            vx: Math.sign(dx) * 6.5, vy: 0,
            life: 90, damage: g.damage, hostile: true,
            type: 'bullet', color: '#7b1fa2'
          });
        } else {
          // Melee - visible swing + range check (jumping avoids melee attacks)
          const atkDir = Math.sign(player.x - g.x) || 1;
          spawnParticles(g.x + atkDir * 25, g.y - 25, '#ff8a65', 4, 3);
          const playerAirborne = player.y < GROUND_Y - 30;
          if (dist < 65 && !playerAirborne) {
            hurtPlayer(g.damage);
            screenShake = g.type === 'tank' ? 5 : 3;
            if (g.type === 'tank') spawnParticles(player.x, player.y - 20, '#f44336', 4);
          }
        }
      }
      g.windupStarted = false;
      return; // Freeze during windup (committed to attack)
    }

    g.attackTimer = Math.max(0, g.attackTimer - 1);

    const dx = player.x - g.x;
    const dist = Math.abs(dx);

    // Aggression boost when fewer allies remain
    const aggroMult = aliveCount <= 1 ? 1.5 : aliveCount <= 2 ? 1.2 : 1.0;

    // If no attack slot available and this goon isn't already attacking, circle at medium range
    const canAttack = attackSlotsAvailable > 0 || g.windupTimer > 0;
    const circleRange = 100 + Math.sin(gameTime * 0.02 + g.x) * 30; // medium range orbit

    switch(g.type) {
      case 'rusher':
        if (!canAttack && dist < circleRange) {
          // Pace at medium range with unique rhythm
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 1.0;
          if (dist < 60) g.x += Math.sign(g.x - player.x) * g.speed * 0.6;
        } else if (dist > 45) {
          g.x += Math.sign(dx) * g.speed * 1.5 * aggroMult;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 16;
          g.attackTimer = Math.floor(24 / aggroMult);
        }
        break;

      case 'tank':
        if (!canAttack && dist < circleRange) {
          g.x += Math.sin(gameTime * 0.03 + g.phaseOffset) * g.speed * 0.7;
          if (dist < 70) g.x += Math.sign(g.x - player.x) * g.speed * 0.5;
        } else if (dist > 55) {
          g.x += Math.sign(dx) * g.speed * 1.1 * aggroMult;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 24;
          g.attackTimer = Math.floor(36 / aggroMult);
        }
        break;

      case 'drunk':
        // Always moving erratically — unique wobble per goon
        g.x += Math.sign(dx) * g.speed * 0.8 * aggroMult + Math.sin(gameTime * 0.1 + g.phaseOffset) * 1.8;
        if (dist > 200) g.x += Math.sign(dx) * g.speed * 0.5;
        if (dist < 50 && g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 12;
          g.attackTimer = Math.floor(22 / aggroMult);
        }
        break;

      case 'thrower': {
        // Maintain ideal range 140-220, always moving
        if (dist < 120) g.x -= Math.sign(dx) * g.speed * 0.6;
        else if (dist > 250) g.x += Math.sign(dx) * g.speed * 1.1;
        else {
          // Strafe at ideal range with unique phase
          g.x += Math.sin(gameTime * 0.05 + g.phaseOffset) * g.speed * 1.0;
          if (dist < 140) g.x -= Math.sign(dx) * g.speed * 0.3;
          else if (dist > 220) g.x += Math.sign(dx) * g.speed * 0.3;
        }
        g.shootTimer++;
        if (g.shootTimer > Math.floor(48 / aggroMult) && g.attackTimer === 0 && !player.dead && canAttack) {
          g.shootTimer = 0;
          g.windupTimer = 18;
          g.attackTimer = 20;
        }
        break;
      }

      case 'flanker': {
        const behindX = player.x + g.flankDir * 80;
        if (!canAttack && dist < circleRange) {
          // Pace around the player's flank with unique rhythm
          g.x += Math.sin(gameTime * 0.06 + g.phaseOffset) * g.speed * 1.1;
          if (dist < 50) g.x += Math.sign(g.x - player.x) * g.speed * 0.6;
        } else if (Math.abs(g.x - behindX) > 30) {
          g.x += Math.sign(behindX - g.x) * g.speed * 1.15 * aggroMult;
        } else if (g.attackTimer === 0 && dist < 60 && !player.dead && canAttack) {
          g.windupTimer = 14;
          g.attackTimer = Math.floor(20 / aggroMult);
          g.flankDir *= -1;
        }
        break;
      }

      case 'ranged':
        // Maintain range 200-350
        if (dist < 180) g.x -= Math.sign(dx) * g.speed * 1.1;
        else if (dist > 350) g.x += Math.sign(dx) * g.speed * 0.8;
        else {
          // Strafe with unique phase
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 0.8;
        }
        g.shootTimer++;
        if (g.shootTimer > Math.floor(40 / aggroMult) && g.attackTimer === 0 && !player.dead && canAttack) {
          g.shootTimer = 0;
          g.windupTimer = 18;
          g.attackTimer = 20;
        }
        break;

      default:
        if (!canAttack && dist < circleRange) {
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 0.8;
          if (dist < 60) g.x += Math.sign(g.x - player.x) * g.speed * 0.4;
        } else if (dist > 50) {
          g.x += Math.sign(dx) * g.speed;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 16;
          g.attackTimer = 28;
        }
    }

    // Separation: don't stack on top of other goons (strong force)
    for (let oi = 0; oi < goons.length; oi++) {
      const other = goons[oi];
      if (other === g) continue;
      const gap = g.x - other.x;
      if (Math.abs(gap) < 40) {
        g.x += Math.sign(gap || 1) * ((40 - Math.abs(gap)) / 40 * 2.0);
      }
    }

    g.x = Math.max(30, Math.min(W - 30, g.x));
    g.speed = origSpeed; // restore after hazard slow
  });
}

// Upgraded goon drawing with distinct looks per type
function drawGoon(g) {
  if (g.dead) return;
  // Lean-back during windup (telegraph body language)
  let leanX = 0;
  if (g.windupTimer > 0) {
    const leanDir = Math.sign(g.x - player.x) || 1;
    leanX = leanDir * 4;
  }
  const x = g.x - g.w/2 + leanX, y = g.y - g.h;

  // Stagger flash
  if (g.staggerTimer > 0) {
    ctx.globalAlpha = Math.floor(gameTime / 2) % 2 === 0 ? 0.3 : 0.8;
  } else if (g.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0) {
    ctx.globalAlpha = 0.5;
  }

  drawPixelChar(x, y, g.w, g.h, g.color, '#deb887', (px, py, w, h) => {
    // Hat/hair varies by type
    drawRect(px + 2, py - 3, w - 4, 6, g.hat || '#333');
    // Tank gets a scarf
    if (g.type === 'tank') {
      drawRect(px + 4, py + 18, w - 8, 5, '#c62828');
    }
    // Thrower has an apron
    if (g.type === 'thrower') {
      drawRect(px + 4, py + 22, w - 8, 15, '#fff');
    }
    // Flanker has a hoodie
    if (g.type === 'flanker') {
      drawRect(px, py - 2, 6, 12, g.hat);
      drawRect(px + w - 6, py - 2, 6, 12, g.hat);
    }
    // Drunk blush
    if (g.type === 'drunk') {
      drawRect(px + 4, py + 12, 5, 3, '#e57373');
      drawRect(px + w - 9, py + 12, 5, 3, '#e57373');
    }
    // Ranged has scope/visor
    if (g.type === 'ranged') {
      drawRect(px + 6, py + 8, w - 12, 3, '#b71c1c');
    }
    // Level-specific accessories
    if (currentLevel === 0) {
      // Lazio scarf on rushers
      if (g.type === 'rusher') drawRect(px + 2, py + 19, w - 4, 3, '#87ceeb');
    } else if (currentLevel === 1) {
      // Pub apron string on drunks
      if (g.type === 'drunk') drawRect(px + w/2 - 1, py + 20, 2, h - 24, '#8d6e63');
    } else if (currentLevel === 3) {
      // Flour stains on pizza workers
      if (g.type === 'thrower' || g.type === 'tank') {
        drawRect(px + 8, py + 25, 4, 3, 'rgba(255,255,255,0.5)');
        drawRect(px + w - 14, py + 30, 5, 3, 'rgba(255,255,255,0.5)');
      }
    } else if (currentLevel === 4) {
      // Armband on elite soldiers
      if (g.type === 'rusher') drawRect(px, py + 16, 4, 6, '#e94560');
    }
  });
  ctx.globalAlpha = 1;

  // Windup visual — body tint + red circle "!" + ground line + flash
  if (g.windupTimer > 0) {
    const wp = g.windupMax ? 1 - (g.windupTimer / g.windupMax) : 0.5;
    const shake = (wp > 0.5 ? 1 : 0) * (Math.floor(gameTime) % 2 === 0 ? 1 : -1);
    const windupFrame = g.windupMax ? (g.windupMax - g.windupTimer) : 0;

    // Bright red flash for first 6 frames of windup
    if (windupFrame < 6) {
      ctx.globalAlpha = 0.5 * (1 - windupFrame / 6);
      drawRect(x - 4, y - 4, g.w + 8, g.h + 8, '#ff1744');
      ctx.globalAlpha = 1;
    }

    // Body red tint (stronger)
    ctx.globalAlpha = 0.30 + wp * 0.35;
    drawRect(x + shake, y, g.w, g.h, '#ff1744');
    ctx.globalAlpha = 1;

    // Ground attack line (melee only) — thicker with glow
    if (g.type !== 'thrower' && g.type !== 'ranged') {
      const atkDir = Math.sign(player.x - g.x) || 1;
      const lineW = 50 + wp * 35;
      const lineX = atkDir > 0 ? g.x : g.x - lineW;
      // Glow layer
      ctx.globalAlpha = (0.5 + wp * 0.4) * 0.4;
      drawRect(lineX, GROUND_Y - 5, lineW, 8, '#ff5252');
      ctx.globalAlpha = 0.5 + wp * 0.4;
      drawRect(lineX, GROUND_Y - 2, lineW, 4, '#ff5252');
      ctx.globalAlpha = 1;
    }

    // Red circle with "!" above head
    const exPulse = Math.sin(gameTime * 0.3) > 0;
    const exX = x + g.w/2 + shake;
    const exY = y - 20;
    ctx.globalAlpha = exPulse ? 1 : 0.7;
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath();
    ctx.arc(exX, exY, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    drawText('!', exX, exY + 6, '#fff', 20, 'center');
  }

  // Thrower/ranged: arm raise + dotted aim line during windup
  if (g.windupTimer > 0 && (g.type === 'thrower' || g.type === 'ranged')) {
    const armDir = Math.sign(player.x - g.x) || 1;
    const armX = x + g.w/2 + armDir * 10;
    drawRect(armX - 4, y - 14, 8, 16, g.color || '#888');
    drawRect(armX - 3, y - 14, 6, 5, '#deb887');
    // Dotted aim line (larger dots, higher alpha)
    const wp = g.windupMax ? 1 - (g.windupTimer / g.windupMax) : 0.5;
    ctx.globalAlpha = 0.4 + wp * 0.4;
    const lineLen = Math.min(Math.abs(player.x - g.x), 100);
    for (let d = 0; d < lineLen; d += 8) {
      drawRect(g.x + armDir * d, g.y - 28, 6, 4, '#ff5252');
    }
    ctx.globalAlpha = 1;
  }

  const hpR = g.hp / g.maxHp;
  drawRect(x, y - 10, g.w, 4, '#333');
  drawRect(x, y - 10, g.w * hpR, 4, '#ff5722');
  // Poise bar (only visible when poise < max)
  if (g.poise !== undefined && g.poise < g.maxPoise) {
    const poiseR = Math.max(0, g.poise / g.maxPoise);
    drawRect(x, y - 6, g.w, 2, '#555');
    drawRect(x, y - 6, g.w * poiseR, 2, g.staggerTimer > 0 ? '#ff9800' : '#ffeb3b');
  }
  // Stagger indicator
  if (g.staggerTimer > 0) {
    const pulse = Math.sin(gameTime * 0.3) * 0.3 + 0.7;
    ctx.globalAlpha = pulse;
    drawText('STAGGER', x + g.w/2, y - 18, '#ff9800', 8, 'center');
    ctx.globalAlpha = 1;
  }
  // Name tag — styled with type color background
  if (g.name && g.staggerTimer <= 0) {
    const nameW = g.name.length * 5 + 8;
    const nameX = x + g.w/2 - nameW/2;
    const nameColor = g.type === 'tank' ? '#c62828' : g.type === 'flanker' ? '#7b1fa2' :
      g.type === 'thrower' ? '#e65100' : g.type === 'ranged' ? '#311b92' :
      g.type === 'drunk' ? '#795548' : '#37474f';
    ctx.globalAlpha = 0.85;
    drawRect(nameX, y - 24, nameW, 12, nameColor);
    ctx.globalAlpha = 1;
    drawText(g.name, x + g.w/2, y - 14, '#fff', 8, 'center');
  }
}

// ==========================================
// GAME SCREENS
// ==========================================

function drawMenu() {
  // Dark background with gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 50; i++) {
    const sx = (i * 73 + gameTime * 0.2) % W;
    const sy = (i * 47) % (H * 0.6);
    const bright = 0.3 + Math.sin(gameTime * 0.02 + i) * 0.3;
    ctx.globalAlpha = bright;
    drawRect(sx, sy, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Title
  const bounce = Math.sin(gameTime * 0.03) * 5;
  drawText('LA GUERRA DI', W/2, 130 + bounce, '#e94560', 32, 'center');
  drawText('VALLE AURELIA', W/2, 175 + bounce, '#e94560', 40, 'center');

  // Subtitle
  drawText('La storia del Conte contro la gang', W/2, 220, '#aaa', 14, 'center');

  // Animated silhouette of Rome
  drawRect(100, 380, 80, 60, '#2d2d44');
  drawRect(110, 360, 20, 20, '#2d2d44');
  drawRect(250, 370, 100, 70, '#2d2d44');
  drawRect(270, 340, 15, 30, '#2d2d44');
  drawRect(295, 345, 15, 25, '#2d2d44');
  drawRect(450, 375, 120, 65, '#2d2d44');
  drawRect(600, 360, 90, 80, '#2d2d44');
  drawRect(620, 330, 10, 30, '#2d2d44');
  drawRect(700, 385, 100, 55, '#2d2d44');

  // Ground
  drawRect(0, 440, W, 110, '#16213e');

  // Start button (tappable on mobile)
  const startBtnW = 280, startBtnH = 40;
  const startBtnX = W/2 - startBtnW/2, startBtnY = 295;
  const startHover = mouseX >= startBtnX && mouseX <= startBtnX + startBtnW && mouseY >= startBtnY && mouseY <= startBtnY + startBtnH;
  const startPulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = startHover ? 1 : startPulse;
  drawRect(startBtnX, startBtnY, startBtnW, startBtnH, startHover ? '#e94560' : 'rgba(233,69,96,0.2)');
  drawRect(startBtnX, startBtnY, startBtnW, 2, '#e94560');
  drawText('INIZIA', W/2, startBtnY + 28, '#fff', 20, 'center');
  ctx.globalAlpha = 1;

  // Controls
  drawText('WASD/Frecce = Muovi | Z/Spazio = Attacca | X = Schiva | 1-4 = Helper', W/2, 500, '#666', 11, 'center');
  drawText('M = Mute/Unmute musica', W/2, 520, '#555', 10, 'center');

  // Small "Crediti" button bottom-right
  const credBtnX = W - 80, credBtnY = H - 28, credBtnW = 70, credBtnH = 20;
  const hoverCred = mouseX >= credBtnX && mouseX <= credBtnX + credBtnW && mouseY >= credBtnY && mouseY <= credBtnY + credBtnH;
  drawRect(credBtnX, credBtnY, credBtnW, credBtnH, hoverCred ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.06)');
  drawText('Crediti', credBtnX + 35, credBtnY + 15, hoverCred ? '#aaa' : '#555', 10, 'center');
  if (mouseClick && hoverCred) {
    showCredits = true;
    codeInput = '';
  }

  // Show cheat active indicator
  if (player.maxHp >= 999) {
    drawText('CONTE MODE', W/2, 280, '#ffd700', 14, 'center');
  }

  // === Credits overlay with code entry ===
  if (showCredits) {
    // Darken background
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.8)');

    // Credits panel — taller on touch to fit on-screen keyboard
    const panelX = W/2 - 200, panelY = isTouchDevice ? 30 : 100, panelW = 400, panelH = isTouchDevice ? 500 : 340;
    drawRect(panelX, panelY, panelW, panelH, 'rgba(20,20,40,0.95)');
    drawRect(panelX, panelY, panelW, 2, '#e94560');
    drawRect(panelX, panelY + panelH - 2, panelW, 2, '#e94560');

    const tOff = isTouchDevice ? -50 : 0; // text offset for touch layout
    drawText('- CREDITI -', W/2, 130 + tOff, '#e94560', 22, 'center');
    drawText('LA GUERRA DI VALLE AURELIA', W/2, 155 + tOff, '#ffd700', 14, 'center');
    drawText('Un gioco da conti...anzi, del Conte!', W/2, 175 + tOff, '#ccc', 11, 'center');
    drawText('Ambientato a Prati, Roma', W/2, 193 + tOff, '#aaa', 11, 'center');
    drawText('Sviluppatore: Cicca', W/2, 214 + tOff, '#aaa', 11, 'center');
    drawText('Programmazione: Cicca + Claude', W/2, 232 + tOff, '#aaa', 11, 'center');
    drawText('Idea & Design: Cicca', W/2, 250 + tOff, '#aaa', 11, 'center');
    drawText('Grazie per aver giocato!', W/2, 272 + tOff, '#ffcc80', 12, 'center');

    // Code entry box
    const codeY = isTouchDevice ? 280 : 320;
    drawRect(W/2 - 90, codeY, 180, 28, 'rgba(255,255,255,0.08)');
    drawRect(W/2 - 90, codeY, 180, 1, '#555');
    drawRect(W/2 - 90, codeY + 27, 180, 1, '#555');
    const cursor = Math.floor(gameTime / 30) % 2 === 0 ? '_' : '';
    const displayCode = codeInput + cursor;
    drawText(displayCode || 'Inserisci codice...', W/2, codeY + 20, codeInput ? '#fff' : '#555', 12, 'center');

    // On-screen keyboard for mobile
    drawCreditsKeyboard(codeY + 35);

    // Close button
    const closeBtnY2 = isTouchDevice ? codeY + 130 : 370;
    const closeBtnX = W/2 - 40, closeBtnW = 80, closeBtnH = 24;
    const hoverClose = mouseX >= closeBtnX && mouseX <= closeBtnX + closeBtnW && mouseY >= closeBtnY2 && mouseY <= closeBtnY2 + closeBtnH;
    drawRect(closeBtnX, closeBtnY2, closeBtnW, closeBtnH, hoverClose ? '#e94560' : 'rgba(233,69,96,0.4)');
    drawText('Chiudi', W/2, closeBtnY2 + 17, '#fff', 11, 'center');
    if (mouseClick && hoverClose) {
      showCredits = false;
      codeInput = '';
    }

    // Handle keyboard input for code entry
    const letterKeys = ['KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG','KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT','KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ'];
    letterKeys.forEach(k => {
      if (keysJustPressed[k]) {
        if (codeInput.length < 12) codeInput += k.charAt(3);
      }
    });
    if (keysJustPressed['Backspace']) codeInput = codeInput.slice(0, -1);

    // Check for CONTE code
    if (codeInput === 'CONTE') {
      showCredits = false;
      codeInput = '';
      // UNLOCK EVERYTHING
      coins = 9999;
      bossDefeated = [true, true, true, true, true];
      player.maxHp = 999;
      player.hp = 999;
      player.maxStamina = 999;
      player.stamina = 999;
      player.invincible = 999999;
      player.speed = 6;
      UPGRADE_POOL.forEach(u => { if (!player.upgrades.some(e => e.effect === u.effect)) player.upgrades.push(u); });
      helpers.forEach(h => { h.tier = 3; h.unlocked = true; });
      firstTime = false;
      screenFlash = 20;
      flashColor = '#ffd700';
      showQuickText('CONTE MODE ACTIVATED! SEI INVINCIBILE!', '#ffd700');
      playSFX('victory_jingle');
      spawnParticles(W/2, H/2, '#ffd700', 40, 10);
    }

    // Check for SABI code
    if (codeInput === 'SABI') {
      showCredits = false;
      codeInput = '';
      sabiTimer = 0;
      sabiCicca = { x: 200, y: GROUND_Y, vx: 0, facing: 1, animTimer: 0 };
      sabiSabi = { x: 450, y: GROUND_Y, animTimer: 0, petting: false };
      sabiTotti = { x: 650, y: GROUND_Y, animTimer: 0, wagging: true, fetching: false };
      sabiMessages = [];
      sabiPreviousState = state;
      state = 'sabi';
      screenFlash = 15;
      flashColor = '#ff69b4';
      playSFX('coin');
    }

    // Check for FREESTYLE code
    if (codeInput === 'FREESTYLE') {
      showCredits = false;
      codeInput = '';
      startFreestyleVideo();
    }

    // Block menu interaction while credits open
    return;
  }

  const startTap = startHover && mouseClick;
  if (keys['Enter'] || keys['Space'] || startTap) {
    if (firstTime) {
      state = 'difficultySelect';
      firstTime = false;
      resetPlayer();
    } else {
      state = 'hub';
      resetPlayer();
    }
  }
  mouseClick = false;
}

// ==========================================
// DIFFICULTY SELECT
// ==========================================
let diffSelectIndex = 1; // default to medium
let diffSelectReady = false;
let diffSelectTimer = 0;

function drawDifficultySelect() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawText('SCEGLI LA DIFFICOLTA\'', W/2, 60, '#e94560', 24, 'center');
  drawText('Puoi sempre cambiare dopo', W/2, 82, '#666', 10, 'center');

  diffSelectTimer++;
  if (diffSelectTimer > 15) diffSelectReady = true;

  const diffs = [
    { name: 'FACILE', color: '#4caf50', desc: 'Modalità Parioli',
      detail: 'Per goderti la storia del Conte senza troppo stress.', icon: '\u263A' },
    { name: 'MEDIO', color: '#ff9800', desc: 'Modalità Prati',
      detail: 'L\'esperienza standard. Nemici meno duri, danno ridotto.', icon: '\u2694' },
    { name: 'DIFFICILE', color: '#f44336', desc: 'Modalità Tor Bella',
      detail: 'Nemici piu\' forti e aggressivi. Nessuna pieta\'.', icon: '\u2620' }
  ];

  // Navigation
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) { diffSelectIndex = Math.max(0, diffSelectIndex - 1); playSFX('hit'); }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) { diffSelectIndex = Math.min(2, diffSelectIndex + 1); playSFX('hit'); }
  if (keysJustPressed['Digit1']) { diffSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { diffSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { diffSelectIndex = 2; playSFX('hit'); }

  diffs.forEach((d, i) => {
    const cx = 120 + i * 240;
    const selected = (i === diffSelectIndex);

    // Click detection
    if (mouseX >= cx && mouseX <= cx + 200 && mouseY >= 110 && mouseY <= 380 && mouseClick) {
      diffSelectIndex = i;
      playSFX('hit');
    }

    // Card
    const cardAlpha = selected ? 1 : 0.5;
    ctx.globalAlpha = cardAlpha;
    drawRect(cx, 110, 200, 270, selected ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.4)');
    drawRect(cx, 110, 200, 3, d.color);
    if (selected) {
      drawRect(cx, 377, 200, 3, d.color);
      drawRect(cx, 110, 3, 270, d.color);
      drawRect(cx + 197, 110, 3, 270, d.color);
    }

    // Icon
    drawText(d.icon, cx + 100, 170, d.color, 32, 'center');

    // Name
    drawText(d.name, cx + 100, 210, d.color, 18, 'center');

    // Description
    drawText(d.desc, cx + 100, 240, '#ccc', 10, 'center');

    // Detail lines (word wrap manually)
    const words = d.detail.split(' ');
    let line1 = '', line2 = '';
    words.forEach(w => {
      if ((line1 + w).length < 28) line1 += (line1 ? ' ' : '') + w;
      else line2 += (line2 ? ' ' : '') + w;
    });
    drawText(line1, cx + 100, 270, '#888', 9, 'center');
    if (line2) drawText(line2, cx + 100, 284, '#888', 9, 'center');

    // Difficulty-specific info
    if (i === 0) {
      drawText('Vite: \u221E', cx + 100, 310, '#4caf50', 11, 'center');
      drawText('Nemici: -30% HP', cx + 100, 326, '#4caf50', 10, 'center');
      drawText('Danni subiti: -40%', cx + 100, 342, '#4caf50', 10, 'center');
    } else if (i === 1) {
      drawText('Vite: 3 per boss', cx + 100, 310, '#ff9800', 11, 'center');
      drawText('Nemici: normali', cx + 100, 326, '#ff9800', 10, 'center');
      drawText('Danni subiti: normali', cx + 100, 342, '#ff9800', 10, 'center');
    } else {
      drawText('Vite: 3 in TOTALE', cx + 100, 310, '#f44336', 11, 'center');
      drawText('Nemici: normali', cx + 100, 326, '#f44336', 10, 'center');
      drawText('Danni subiti: normali', cx + 100, 342, '#f44336', 10, 'center');
    }

    ctx.globalAlpha = 1;
  });

  // Key hint
  drawText('Frecce/1-2-3 per scegliere', W/2, 400, '#555', 10, 'center');

  // Confirm button
  const confirmW = 220, confirmH = 36;
  const confirmX = W/2 - confirmW/2, confirmY = 420;
  const confirmHover = mouseX >= confirmX && mouseX <= confirmX + confirmW && mouseY >= confirmY && mouseY <= confirmY + confirmH;
  const selColor = diffs[diffSelectIndex].color;
  drawRect(confirmX, confirmY, confirmW, confirmH, confirmHover ? selColor : 'rgba(255,255,255,0.1)');
  drawRect(confirmX, confirmY, confirmW, 2, selColor);
  drawText('CONFERMA: ' + diffs[diffSelectIndex].name, W/2, confirmY + 25, '#fff', 14, 'center');

  const confirmTap = diffSelectReady && confirmHover && mouseClick;
  if (diffSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    difficulty = ['easy', 'medium', 'hard'][diffSelectIndex];
    if (difficulty === 'hard') lives = 3;
    state = 'weaponSelect';
    weaponSelectIndex = 0;
    weaponSelectReady = false;
    weaponSelectTimer = 0;
    spawnParticles(W/2, H/2, selColor, 20, 5);
    playSFX('coin');
  }

  drawTouchButtons();
  mouseClick = false;
}

// ==========================================
// TUTORIAL
// ==========================================
const tutorialSteps = [
  { text: 'Benvenuto, Conte! Questo e\' il tuo addestramento.', hint: '[ENTER] per continuare' },
  { text: 'Usa A/D o FRECCE per muoverti.', hint: 'Muoviti a sinistra e destra!', check: 'move' },
  { text: 'Premi W o FRECCIA SU per saltare!', hint: 'Salta!', check: 'jump' },
  { text: 'Premi Z o SPAZIO per attaccare! Colpisci il manichino!', hint: 'Attacca il manichino!', check: 'attack' },
  { text: 'Ora fai un COMBO completo! Premi Z piu\' volte di fila veloce!', hint: 'Completa tutto il combo (3 colpi) sul manichino!', check: 'combo' },
  { text: 'Premi X per schivare! Breve invincibilita\'.', hint: 'Schiva!', check: 'dodge' },
  { text: 'Colpire carica la barra ULTRA! Continua a colpire fino a riempirla!', hint: 'Riempi la barra dorata colpendo il manichino!', check: 'ultra' },
  { text: 'Prova i consumabili! Premi 5, 6 o 7 per usarli in battaglia.', hint: 'Premi 5, 6 o 7 per usare un consumabile!', check: 'consumable' },
  { text: 'TAB = lista mosse completa. Helper: tasti 1-4.', hint: 'Premi TAB per vedere tutte le mosse!' },
  { text: 'Sei pronto, Conte. La gang di Valle Aurelia ti aspetta!', hint: '[ENTER] per iniziare!' }
];
let tutorialChecks = { move: false, jump: false, attack: false, combo: false, dodge: false, ultra: false, consumable: false };

function updateTutorial() {
  tutorialTimer++;

  // Check conditions
  if (tutorialSteps[tutorialStep] && tutorialSteps[tutorialStep].check) {
    const check = tutorialSteps[tutorialStep].check;
    if (check === 'move' && (keys['ArrowLeft'] || keys['ArrowRight'] || keys['KeyA'] || keys['KeyD'])) {
      tutorialChecks.move = true;
    }
    if (check === 'jump' && !player.grounded) {
      tutorialChecks.jump = true;
    }
    if (check === 'attack' && player.attacking) {
      tutorialChecks.attack = true;
    }
    if (check === 'combo' && player.comboChainCount >= 1) {
      // Full combo chain completed (all hits of weapon combo)
      tutorialChecks.combo = true;
    }
    if (check === 'dodge' && player.dodging) {
      tutorialChecks.dodge = true;
    }
    if (check === 'ultra' && player.ultraAvailable) {
      // Ultra bar is full
      tutorialChecks.ultra = true;
    }
    if (check === 'consumable' && (keysJustPressed['Digit5'] || keysJustPressed['Digit6'] || keysJustPressed['Digit7'])) {
      tutorialChecks.consumable = true;
    }
  }

  // Give tutorial consumables for the consumable step
  if (tutorialSteps[tutorialStep] && tutorialSteps[tutorialStep].check === 'consumable' && player.consumables.length === 0) {
    player.consumables = ['freeStamina', 'dmgBoost', 'freeStamina'];
  }

  updatePlayerInput();

  // Tick stamina/exhaustion/reload timers (normally in updateLevel)
  if (player.exhaustedTimer > 0) player.exhaustedTimer--;
  if (player.reloadTimer > 0) {
    player.reloadTimer--;
    if (player.reloadTimer <= 0) {
      const weap = weapons[player.weapon];
      if (weap.maxAmmo) { weap.currentAmmo = weap.maxAmmo; }
    }
  }
  if (player.staminaRegenDelay > 0) {
    player.staminaRegenDelay--;
  } else if (player.stamina < player.maxStamina) {
    player.stamina = Math.min(player.maxStamina, player.stamina + 0.8);
  }

  // Reset dummy if killed
  if (tutorialDummy && tutorialDummy.dead) {
    tutorialDummy = { x: 550, y: GROUND_Y, w: 34, h: 52, hp: 50, maxHp: 50, hitFlash: 0, stunTimer: 0, dead: false, color: '#777' };
  }
  if (tutorialDummy) tutorialDummy.hitFlash = Math.max(0, tutorialDummy.hitFlash - 1);

  // Hit detection on dummy (only on first active frame of each combo hit)
  if (player.attacking && player.attackActiveTimer === weapons[player.weapon].activeFrames - 1 && tutorialDummy && !tutorialDummy.dead) {
    const weap = weapons[player.weapon];
    const attackX = player.x + player.facing * weap.range * 0.5;
    if (Math.abs(attackX - tutorialDummy.x) < weap.range * 0.7 + tutorialDummy.w/2 && Math.abs(player.y - tutorialDummy.y) < 55) {
      const dmg = weap.damage * COMBO_DMG_MULT[Math.min(player.comboStep - 1, 3)];
      tutorialDummy.hp -= dmg;
      tutorialDummy.hitFlash = 10;
      spawnParticles(tutorialDummy.x, tutorialDummy.y - 25, '#ffeb3b', 6);
      spawnDamageNumber(tutorialDummy.x, tutorialDummy.y - 52, Math.floor(dmg), '#ffeb3b');
      playSFX('hit');
      // Ultra charge in tutorial
      if (!player.ultraActive) {
        player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 6);
        if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
      }
      if (tutorialDummy.hp <= 0) {
        tutorialDummy.dead = true;
        spawnParticles(tutorialDummy.x, tutorialDummy.y - 25, '#ffd700', 15);
      }
    }
  }

  // Ultra timer countdown in tutorial
  if (player.ultraActive) {
    player.ultraTimer--;
    if (player.ultraTimer <= 0) {
      player.ultraActive = false;
      player.ultraTimer = 0;
    }
  }

  updateParticles();
  player.x = Math.max(25, Math.min(W - 25, player.x));
}

function drawTutorial() {
  // Background - training area at Vanni bar
  const trainSky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  trainSky.addColorStop(0, '#0d1b2a');
  trainSky.addColorStop(1, '#1b2838');
  ctx.fillStyle = trainSky;
  ctx.fillRect(0, 0, W, GROUND_Y);
  drawRect(0, GROUND_Y, W, H - GROUND_Y, '#3e2723');
  drawRect(0, GROUND_Y, W, 3, '#5d4037');

  // Back wall - bar interior feel
  drawRect(0, 95, W, GROUND_Y - 95, '#2d2233');
  // Brick texture (reduced)
  ctx.globalAlpha = 0.08;
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 10; col++) {
      const offset = row % 2 === 0 ? 0 : 50;
      drawRect(col * 100 + offset, 100 + row * 76, 92, 68, '#5d4037');
    }
  }
  ctx.globalAlpha = 1;

  // Vanni bar counter at back
  drawRect(0, GROUND_Y - 45, W, 8, '#5d4037');
  drawRect(0, GROUND_Y - 37, W, 37, '#3e2723');
  // Bottles on shelf
  const bColors = ['#4caf50','#f44336','#2196f3','#ff9800','#9c27b0','#ffeb3b','#4caf50','#f44336'];
  bColors.forEach((c, i) => {
    drawRect(60 + i * 100, GROUND_Y - 72, 8, 28, c);
    drawRect(58 + i * 100, GROUND_Y - 74, 12, 4, c);
  });

  // Training targets on wall (punching bag outlines)
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = '#f44336';
  ctx.beginPath(); ctx.arc(180, GROUND_Y - 130, 25, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(720, GROUND_Y - 130, 25, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;
  // Target rings
  [180, 720].forEach(tx => {
    ctx.strokeStyle = '#f44336'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.arc(tx, GROUND_Y - 130, 15, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, GROUND_Y - 130, 8, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = 1;
  });

  // Warm hanging lights
  [200, 450, 700].forEach(lx => {
    drawRect(lx, 95, 2, 20, '#444');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx) * 0.1;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx + 1, 118, 14, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    drawRect(lx - 5, 114, 12, 6, '#ffd54f');
  });

  // Floor mat (training area)
  ctx.globalAlpha = 0.15;
  drawRect(300, GROUND_Y + 3, 300, H - GROUND_Y - 3, '#1565c0');
  ctx.globalAlpha = 1;

  // Vanni sign (below tutorial panel)
  drawRect(350, 92, 200, 28, '#b71c1c');
  drawRect(350, 92, 200, 2, '#e53935');
  drawText('VANNI - ADDESTRAMENTO', W/2, 112, '#fff', 13, 'center');

  // Draw dummy
  if (tutorialDummy && !tutorialDummy.dead) {
    const dx = tutorialDummy.x - tutorialDummy.w/2, dy = tutorialDummy.y - tutorialDummy.h;
    if (tutorialDummy.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0) ctx.globalAlpha = 0.5;
    drawPixelChar(dx, dy, tutorialDummy.w, tutorialDummy.h, '#777', '#aaa', (px, py, w, h) => {
      drawText('DUMMY', px - 2, py - 8, '#999', 9);
      // X eyes
      drawRect(px + 10, py + 10, 2, 2, '#f00');
      drawRect(px + w - 12, py + 10, 2, 2, '#f00');
    });
    ctx.globalAlpha = 1;
    const hpR = tutorialDummy.hp / tutorialDummy.maxHp;
    drawRect(dx, dy - 6, 30, 4, '#333');
    drawRect(dx, dy - 6, 30 * hpR, 4, '#ff5722');
  }

  // Draw player
  drawConte(player);
  drawParticles();

  // === Tutorial mini-HUD (ultra bar + consumable slots) ===
  const tutStep = tutorialSteps[tutorialStep];
  const isUltraStep = tutStep && tutStep.check === 'ultra';
  const isConsumableStep = tutStep && tutStep.check === 'consumable';
  const showTutHud = tutorialStep >= 3; // show from attack step onward

  if (showTutHud) {
    // Ultra bar - bottom left
    const ubX = 14, ubY = H - 60, ubW = 140, ubH = 10;
    drawRect(ubX - 4, ubY - 16, ubW + 8, 30, 'rgba(0,0,0,0.7)');
    drawText('ULTRA [Q]', ubX, ubY - 4, '#ff8f00', 9);
    drawRect(ubX, ubY, ubW, ubH, '#333');
    const ultraR = player.ultraCharge / player.ultraMaxCharge;
    if (player.ultraAvailable) {
      const pulse = Math.sin(gameTime * 0.15) * 0.3 + 0.7;
      ctx.globalAlpha = pulse;
      drawRect(ubX, ubY, ubW, ubH, '#ffd700');
      drawText('PRONTO!', ubX + ubW + 6, ubY + 9, '#ffd700', 9);
      ctx.globalAlpha = 1;
    } else {
      drawRect(ubX, ubY, ubW * ultraR, ubH, '#ff8f00');
      drawText(Math.floor(ultraR * 100) + '%', ubX + ubW + 6, ubY + 9, '#ff8f00', 8);
    }

    // Pulsing highlight arrow during ultra step
    if (isUltraStep && !tutorialChecks.ultra) {
      const arrowPulse = Math.sin(gameTime * 0.1) * 8;
      const aX = ubX + ubW / 2, aY = ubY - 22 + arrowPulse;
      ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(aX - 8, aY - 10);
      ctx.lineTo(aX + 8, aY - 10);
      ctx.lineTo(aX, aY);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      drawText('COLPISCI PER CARICARE!', aX, aY - 16, '#ffd700', 10, 'center');
    }
  }

  // Consumable slots display during tutorial
  if (isConsumableStep && player.consumables.length > 0) {
    const csX = W - 210, csY = H - 60;
    drawRect(csX - 4, csY - 16, 210, 30, 'rgba(0,0,0,0.7)');
    drawText('CONSUMABILI', csX, csY - 4, '#a1887f', 9);
    for (let i = 0; i < player.consumables.length; i++) {
      const cx = csX + i * 62;
      const cy = csY;
      const effect = player.consumables[i];
      const ci = consumableItems.find(c => c.effect === effect);
      if (ci) {
        drawRect(cx, cy, 56, 12, 'rgba(255,255,255,0.15)');
        drawRect(cx, cy, 56, 2, ci.color);
        drawText('[' + (i+5) + '] ' + ci.icon, cx + 4, cy + 11, '#fff', 9);
      }
    }
    // Pulsing arrow
    if (!tutorialChecks.consumable) {
      const arrowPulse = Math.sin(gameTime * 0.1) * 8;
      const aX = csX + 90, aY = csY - 22 + arrowPulse;
      ctx.fillStyle = '#a1887f';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(aX - 8, aY - 10);
      ctx.lineTo(aX + 8, aY - 10);
      ctx.lineTo(aX, aY);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      drawText('PREMI 5, 6 O 7!', aX, aY - 16, '#a1887f', 10, 'center');
    }
  }

  // === Tutorial UI - at the TOP ===
  const step = tutorialSteps[tutorialStep];
  if (step) {
    drawRect(0, 0, W, 80, 'rgba(10,10,30,0.92)');
    drawRect(0, 78, W, 2, '#4caf50');

    // Step progress dots
    for (let i = 0; i < tutorialSteps.length; i++) {
      const dotX = W/2 - (tutorialSteps.length * 8) + i * 16;
      drawRect(dotX, 6, 8, 4, i < tutorialStep ? '#4caf50' : i === tutorialStep ? '#fff' : '#333');
    }

    // Step indicator
    drawText('TUTORIAL ' + (tutorialStep + 1) + '/' + tutorialSteps.length, W/2, 22, '#4caf50', 11, 'center');
    drawText(step.text, W/2, 42, '#fff', 14, 'center');
    drawText(step.hint, W/2, 62, '#aaa', 11, 'center');

    // Auto-advance or manual advance
    const hasCheck = step.check;
    const confirmPressed = keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'];
    if (hasCheck) {
      if (tutorialChecks[step.check]) {
        const bravoPulse = Math.sin(gameTime * 0.12) * 0.3 + 0.7;
        ctx.globalAlpha = bravoPulse;
        drawText('Bravo! [Z/ENTER]', W/2, 76, '#4caf50', 10, 'center');
        ctx.globalAlpha = 1;
        if (confirmPressed) { tutorialStep++; }
      }
    } else {
      if (Math.floor(gameTime / 30) % 2 === 0) {
        drawText('[Z/ENTER]', W/2, 76, '#888', 10, 'center');
      }
      if (confirmPressed) { tutorialStep++; }
    }
  }

  // Tutorial complete
  if (tutorialStep >= tutorialSteps.length) {
    state = 'hub';
    resetPlayer();
  }

  // Moves screen (TAB/P) — handled in draw phase to avoid double-toggle
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP']) {
    toggleMovesScreen();
  }

  // Mobile touch buttons
  drawTouchButtons();

  // Skip option — top right, big enough to tap on mobile
  const skipBtnW = 140, skipBtnH = 36;
  const skipBtnX = W - skipBtnW - 10, skipBtnY = 86;
  const skipHover = mouseX >= skipBtnX && mouseX <= skipBtnX + skipBtnW && mouseY >= skipBtnY && mouseY <= skipBtnY + skipBtnH;
  drawRect(skipBtnX, skipBtnY, skipBtnW, skipBtnH, skipHover ? 'rgba(255,255,255,0.25)' : 'rgba(255,255,255,0.1)');
  drawRect(skipBtnX, skipBtnY, skipBtnW, 2, '#888');
  drawText('SALTA TUTORIAL >', skipBtnX + skipBtnW / 2, skipBtnY + 23, skipHover ? '#fff' : '#aaa', 12, 'center');
  if ((mouseClick && skipHover) || keys['Escape']) {
    state = 'hub';
    resetPlayer();
    mouseClick = false;
  }
}

function resetPlayer() {
  player.x = 200;
  player.y = 430;
  player.hp = player.maxHp;
  player.stamina = player.maxStamina;
  player.dead = false;
  player.invincible = player.maxHp >= 999 ? 999999 : 0; // preserve cheat invincibility
  player.attacking = false;
  player.attackTimer = 0;
  player.attackCooldown = 0;
  player.dodging = false;
  player.dodgeTimer = 0;
  player.dodgeCooldown = 0;
  player.vx = 0;
  player.vy = 0;
  player.stunTimer = 0;
  player.speedBoost = 0;
  player.comboStep = 0;
  player.comboWindowTimer = 0;
  player.endLagTimer = 0;
  player.attackBuffered = false;
  player.attackActiveTimer = 0;
  player.comboChainCount = 0;
  player.jumpAttacking = false;
  player.stamina = player.maxStamina;
  player.staminaRegenDelay = 0;
  player.reloadTimer = 0;
  // Reset ammo on level start
  const w0 = weapons[player.weapon];
  if (w0 && w0.maxAmmo) w0.currentAmmo = w0.maxAmmo;
  player.grabbing = false;
  player.grabbedEnemy = null;
  player.grabTimer = 0;
  player.comboHitCount = 0;
  player.comboHitTimer = 0;
  player.scoreMultiplier = 1;
  player.hazardSlow = false;
  player.exhaustedTimer = 0;
  player.sameTargetHits = 0;
  player.sameTargetTimer = 0;
  player.lastHitTarget = null;
  // Ultra system reset
  player.ultraCharge = 0;
  player.ultraActive = false;
  player.ultraTimer = 0;
  player.ultraAvailable = false;
}

// ==========================================
// WEAPON SELECT
// ==========================================
function drawWeaponSelect() {
  // Input guard — ignore keys for first 20 frames so menu Enter doesn't carry over
  weaponSelectTimer++;
  if (weaponSelectTimer > 20) weaponSelectReady = true;

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a1a2e');
  grad.addColorStop(1, '#0d0d1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawText('SCEGLI LA TUA ARMA', W/2, 40, '#ffd700', 24, 'center');
  drawText('"Conte, da Vanni c\'e\' rimasto \'sto ben di Dio..."', W/2, 65, '#aaa', 11, 'center');

  // Navigate with arrows/WASD or 1-4
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) {
    weaponSelectIndex = Math.max(0, weaponSelectIndex - 1);
    playSFX('hit');
  }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) {
    weaponSelectIndex = Math.min(3, weaponSelectIndex + 1);
    playSFX('hit');
  }
  if (keysJustPressed['Digit1']) { weaponSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { weaponSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { weaponSelectIndex = 2; playSFX('hit'); }
  if (keysJustPressed['Digit4']) { weaponSelectIndex = 3; playSFX('hit'); }

  const cardW = 190, cardH = 320, gap = 15;
  const totalW = 4 * cardW + 3 * gap;
  const startX = (W - totalW) / 2;
  const startY = 85;

  for (let i = 0; i < 4; i++) {
    const sw = starterWeapons[i];
    const cx = startX + i * (cardW + gap);
    const cy = startY;
    const selected = (i === weaponSelectIndex);
    const isHover = mouseX > cx && mouseX < cx + cardW && mouseY > cy && mouseY < cy + cardH;

    if (isHover && mouseClick) {
      weaponSelectIndex = i;
    }

    // Card background
    const cardColor = selected ? '#2a2a4a' : '#1a1a2e';
    drawRect(cx, cy, cardW, cardH, cardColor);
    // Selection border
    if (selected) {
      ctx.strokeStyle = sw.color;
      ctx.lineWidth = 3;
      ctx.strokeRect(cx, cy, cardW, cardH);
      ctx.lineWidth = 1;
    } else {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(cx, cy, cardW, cardH);
    }

    // Color accent bar
    drawRect(cx, cy, cardW, 4, sw.color);

    // Number key hint
    drawText((i+1) + '', cx + 12, cy + 22, selected ? sw.color : '#555', 14);

    // Weapon name
    drawText(sw.name, cx + cardW/2, cy + 38, selected ? '#fff' : '#888', 14, 'center');

    // Weapon icon/visual
    const iconY = cy + 85;
    ctx.save();
    ctx.globalAlpha = selected ? 1 : 0.5;
    drawWeaponIcon(cx + cardW/2, iconY, sw, selected);
    ctx.restore();

    // Type label
    const types = ['VELOCE', 'BILANCIATO', 'PESANTE', 'RANGED'];
    const typeColors = ['#4caf50', '#2196f3', '#ff9800', '#9c27b0'];
    drawText(types[i], cx + cardW/2, cy + 135, typeColors[i], 10, 'center');

    // Stats
    const statY = cy + 160;
    const statX = cx + 15;
    const barMaxW = cardW - 30;

    drawStatBar(statX, statY, 'DANNO', sw.damage, 40, barMaxW, '#f44336');
    drawStatBar(statX, statY + 28, 'RAGGIO', Math.min(sw.range, 100), 100, barMaxW, '#2196f3');
    drawStatBar(statX, statY + 56, 'VELOCITA\'', 20 - sw.speed, 20, barMaxW, '#4caf50');
    drawStatBar(statX, statY + 84, 'CRITICO', sw.crit, 30, barMaxW, '#ffeb3b');
    drawStatBar(statX, statY + 112, 'COMBO', sw.comboHits, 5, barMaxW, '#e040fb');

    // Description
    drawText(sw.desc, cx + cardW/2, cy + cardH - 20, selected ? '#ccc' : '#555', 8, 'center');
  }

  // Confirm button (tappable on mobile)
  const confirmBtnW = 200, confirmBtnH = 36;
  const confirmBtnX = W/2 - confirmBtnW/2, confirmBtnY = H - 55;
  const confirmHover = mouseX >= confirmBtnX && mouseX <= confirmBtnX + confirmBtnW && mouseY >= confirmBtnY && mouseY <= confirmBtnY + confirmBtnH;
  const pulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  drawRect(confirmBtnX, confirmBtnY, confirmBtnW, confirmBtnH, confirmHover ? '#ffd700' : 'rgba(255,215,0,0.3)');
  drawRect(confirmBtnX, confirmBtnY, confirmBtnW, 3, '#ffd700');
  drawText('CONFERMA', W/2, confirmBtnY + 24, confirmHover ? '#1a1a2e' : '#ffd700', 16, 'center');
  ctx.globalAlpha = 1;
  drawText('Frecce/1-4 = Seleziona', W/2, H - 10, '#666', 10, 'center');

  // Confirm selection (keyboard, or tap confirm button)
  const confirmTap = weaponSelectReady && confirmHover && mouseClick;
  if (weaponSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    const chosen = JSON.parse(JSON.stringify(starterWeapons[weaponSelectIndex]));
    if (chosen.maxAmmo) chosen.currentAmmo = chosen.maxAmmo;
    weapons = [chosen];
    player.weapon = 0;
    weaponTier = 0;
    // Go to helper select
    state = 'helperSelect';
    helperSelectIndex = 0;
    helperSelectReady = false;
    helperSelectTimer = 0;
    spawnParticles(W/2, H/2, starterWeapons[weaponSelectIndex].color, 25, 6);
    playSFX('coin');
  }

  mouseClick = false;
}

function drawHelperSelect() {
  ctx.fillStyle = '#0d0d1a';
  ctx.fillRect(0, 0, W, H);

  helperSelectTimer++;
  if (helperSelectTimer > 15) helperSelectReady = true;

  drawText('SCEGLI IL TUO ALLEATO', W/2, 40, '#e040fb', 22, 'center');
  drawText('Gli altri si sbloccano dall\'armeria di Vanni', W/2, 60, '#888', 10, 'center');

  // Navigate
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) {
    helperSelectIndex = Math.max(0, helperSelectIndex - 1); playSFX('hit');
  }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) {
    helperSelectIndex = Math.min(3, helperSelectIndex + 1); playSFX('hit');
  }
  if (keysJustPressed['Digit1']) { helperSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { helperSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { helperSelectIndex = 2; playSFX('hit'); }
  if (keysJustPressed['Digit4']) { helperSelectIndex = 3; playSFX('hit'); }

  for (let i = 0; i < 4; i++) {
    const h = helpers[i];
    const cx = 60 + i * 205;
    const cy = 80;
    const cw = 190, ch = 280;
    const isHover = mouseX > cx && mouseX < cx + cw && mouseY > cy && mouseY < cy + ch;
    const selected = (i === helperSelectIndex);

    if (isHover && (mouseX !== 0 || mouseY !== 0)) helperSelectIndex = i;

    const bg = selected ? 'rgba(224,64,251,0.15)' : 'rgba(255,255,255,0.04)';
    drawRect(cx, cy, cw, ch, bg);
    drawRect(cx, cy, cw, 3, h.color);

    if (selected) {
      const pulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
      ctx.strokeStyle = h.color;
      ctx.lineWidth = 2 + pulse;
      ctx.strokeRect(cx - 2, cy - 2, cw + 4, ch + 4);
      ctx.lineWidth = 1;
    }

    // Icon
    drawRect(cx + cw/2 - 25, cy + 25, 50, 50, 'rgba(0,0,0,0.5)');
    drawText(h.icon, cx + cw/2, cy + 60, h.color, 32, 'center');

    // Name
    drawText(h.name, cx + cw/2, cy + 100, '#fff', 16, 'center');
    drawText('[' + (i+1) + ']', cx + cw/2, cy + 116, '#666', 9, 'center');

    // Description
    drawText(h.desc, cx + cw/2, cy + 140, '#aaa', 10, 'center');

    // Tier info
    drawText('Cooldown: ' + Math.floor(h.cooldown / 60) + 's', cx + cw/2, cy + 170, '#888', 9, 'center');

    // Tier upgrades preview
    drawText('Potenziamenti:', cx + cw/2, cy + 200, '#666', 8, 'center');
    for (let t = 0; t < 3; t++) {
      drawText('Lv.' + (t+1) + ': ' + h.tiers[t].desc, cx + cw/2, cy + 218 + t * 16, '#555', 7, 'center');
    }

    // Click to select
    if (isHover && mouseClick && helperSelectReady) {
      helperSelectIndex = i;
    }
  }

  // Instructions + Confirm button
  drawText('Frecce/1-4 = Seleziona', W/2, H - 65, '#666', 10, 'center');

  const confirmX = W/2 - 100, confirmY = H - 52;
  const confirmHover = mouseX > confirmX && mouseX < confirmX + 200 && mouseY > confirmY && mouseY < confirmY + 36;
  drawRect(confirmX, confirmY, 200, 36, helperSelectReady ? (confirmHover ? '#e040fb' : 'rgba(224,64,251,0.4)') : '#333');
  drawRect(confirmX, confirmY, 200, 2, '#e040fb');
  drawText(helperSelectReady ? 'CONFERMA [ENTER]' : '...', W/2, confirmY + 24, helperSelectReady ? '#fff' : '#555', 14, 'center');

  const confirmTap = helperSelectReady && confirmHover && mouseClick;
  if (helperSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    // Unlock the chosen helper for free
    helpers.forEach((h, idx) => { h.unlocked = (idx === helperSelectIndex); });
    // Go to tutorial
    state = 'tutorial';
    resetPlayer();
    player.x = 200;
    tutorialStep = 0;
    tutorialTimer = 0;
    tutorialDummy = { x: 550, y: GROUND_Y, w: 34, h: 52, hp: 50, maxHp: 50, hitFlash: 0, stunTimer: 0, dead: false, color: '#777' };
    spawnParticles(W/2, H/2, helpers[helperSelectIndex].color, 25, 6);
    playSFX('coin');
  }
  mouseClick = false;
}

function drawWeaponIcon(cx, cy, w, selected) {
  const col = w.color;
  if (w.name === 'Sanpietrino') {
    // Cobblestone
    drawRect(cx - 12, cy - 10, 24, 20, '#9e9e9e');
    drawRect(cx - 10, cy - 8, 20, 16, '#bdbdbd');
    drawRect(cx - 6, cy - 4, 4, 4, '#757575');
    drawRect(cx + 2, cy, 4, 4, '#757575');
  } else if (w.name === 'Cacciavite') {
    // Screwdriver
    drawRect(cx - 2, cy - 18, 4, 24, '#ff8a65');
    drawRect(cx - 4, cy + 6, 8, 10, '#795548');
    drawRect(cx - 1, cy - 20, 2, 4, '#bbb');
  } else if (w.name === 'Spranga') {
    // Metal pipe
    drawRect(cx - 3, cy - 22, 6, 44, '#795548');
    drawRect(cx - 4, cy - 22, 8, 6, '#5d4037');
    drawRect(cx - 2, cy + 16, 4, 6, '#4e342e');
  } else if (w.name === 'Fionda') {
    // Slingshot
    drawRect(cx - 8, cy - 12, 3, 24, '#8d6e63');
    drawRect(cx + 5, cy - 12, 3, 24, '#8d6e63');
    drawRect(cx - 8, cy - 12, 16, 3, '#8d6e63');
    drawRect(cx - 1, cy + 8, 2, 8, '#795548');
    // Rubber band
    ctx.strokeStyle = '#ffcc80';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - 7, cy - 10);
    ctx.lineTo(cx, cy);
    ctx.lineTo(cx + 7, cy - 10);
    ctx.stroke();
  }
}

function drawStatBar(x, y, label, value, maxVal, barW, color) {
  drawText(label, x, y + 8, '#888', 7);
  const bx = x, by = y + 12, bw = barW, bh = 6;
  drawRect(bx, by, bw, bh, '#222');
  drawRect(bx, by, bw * Math.min(value / maxVal, 1), bh, color);
}

// ==========================================
// MOVES/SKILLS REFERENCE SCREEN
// ==========================================
let movesScreenOpen = false;
let movesScreenPrev = ''; // state to return to

function toggleMovesScreen() {
  if (movesScreenOpen) {
    state = movesScreenPrev;
    movesScreenOpen = false;
  } else {
    movesScreenPrev = state;
    state = 'moves';
    movesScreenOpen = true;
  }
}

function drawMovesScreen() {
  ctx.fillStyle = '#0a0a19';
  ctx.fillRect(0, 0, W, H);

  drawText('MOSSE', W/2, 28, '#ffd700', 22, 'center');
  drawText('TAB / ESC = chiudi', W/2, 46, '#555', 9, 'center');

  // Helper to draw a section box
  const drawSection = (x, y, w, h, title, titleCol, rows, keyCol) => {
    drawRect(x, y, w, h, '#111');
    drawRect(x, y, w, 2, titleCol);
    drawText(title, x + 8, y + 15, titleCol, 11);
    let ry = y + 28;
    rows.forEach(([key, desc]) => {
      drawText(key, x + 10, ry, keyCol, 9);
      drawText(desc, x + 80, ry, '#bbb', 8);
      ry += 16;
    });
  };

  // Col 1 — left side
  // ATTACCO
  drawSection(20, 60, 430, 112, 'ATTACCO', '#e94560', [
    ['Z / Spazio', 'Colpisci. Premi piu\' volte = combo chain'],
    ['Q', 'ULTRA — barra piena → attiva (1.5x danno, velocita\', 5 sec)'],
    ['W+Z (tastiera)', 'Overhead — colpo dall\'alto, 2x danno postura'],
    ['Z in aria', 'Attacco aereo'],
    ['X', 'Schivata (durante windup nemico = COUNTER)'],
  ], '#ff8a65');

  // GRAB
  drawSection(20, 182, 430, 68, 'GRAB', '#64b5f6', [
    ['Z vicino', 'Afferra nemico stordito'],
    ['', 'Z = lancia | W+Z = slam (tastiera)'],
  ], '#90caf9');

  // MOVIMENTO
  drawSection(20, 260, 430, 58, 'MOVIMENTO', '#2196f3', [
    ['A/D', 'Muovi    |    W = Salta    |    X = Schiva'],
  ], '#64b5f6');

  // STAMINA
  drawSection(20, 328, 430, 68, 'STAMINA', '#fdd835', [
    ['Costo', 'Colpo = 12 | Ultra = 7 per colpo'],
    ['Esaurito', 'Stamina a 0 → bloccato brevemente'],
    ['Caffe\'', 'Consumabile: stamina gratis 10s'],
  ], '#fff59d');

  // Col 2 — right side
  // SPECIALI ARMA
  drawSection(460, 60, 420, 148, 'SPECIALI ARMA (attivi durante Ultra)', '#ff8a65', [
    ['Sanpietrino', 'Crit cresce ad ogni colpo del combo'],
    ['Cacciavite', 'Ultra: sanguinamento su ogni colpo'],
    ['Spranga', 'Colpo 1 lungo, Colpo 2 entrambi i lati'],
    ['Fionda', 'Il 3o colpo perfora i nemici'],
    ['Machete', 'Ultra: 2x danno su nemici sotto 25% HP'],
    ['Catena', 'Ultra: attira nemici vicini'],
    ['La Lupa', 'Ultra: onda d\'urto devastante'],
  ], '#ffcc80');

  // HELPER
  drawSection(460, 218, 420, 98, 'HELPER & CONSUMABILI', '#e040fb', [
    ['1', 'Pirox — Stun'],
    ['2', 'Tommy — Coltellata'],
    ['3', 'Cicca — Cura'],
    ['4', 'Il Mostro — Speed'],
    ['5-6-7', 'Usa consumabile (Suppli\'/Caffe\'/Cornetto)'],
  ], '#ce93d8');

  // TASTI
  drawSection(460, 326, 420, 58, 'ALTRI TASTI', '#78909c', [
    ['S', 'Armeria (nel hub)    |    M = Musica on/off'],
    ['TAB/P', 'Mosse (questa schermata)'],
  ], '#b0bec5');

  // Current weapon info at bottom
  const w = weapons[player.weapon] || weapons[0];
  // Determine rarity
  let rarityLetter = 'C', rarityColor = '#9e9e9e', rarityName = 'Comune';
  if (rareWeapons.some(rw => rw.name === w.name)) { rarityLetter = 'R'; rarityColor = '#2196f3'; rarityName = 'Raro'; }
  else if (legendaryWeapons.some(lw => lw.name === w.name)) { rarityLetter = 'L'; rarityColor = '#ffd700'; rarityName = 'Leggendario'; }

  drawRect(20, 424, W - 40, 50, '#1a1a2e');
  drawRect(20, 424, W - 40, 2, w.color || '#888');
  // Rarity badge
  drawRect(22, 428, 22, 22, rarityColor);
  drawText(rarityLetter, 33, 444, '#000', 14, 'center');
  drawText('ARMA ATTUALE: ' + w.name, 52, 444, '#fff', 12);
  drawText(rarityName, 52, 462, rarityColor, 9);
  drawText('DMG ' + w.damage + '  |  RNG ' + w.range + '  |  CRIT ' + w.crit + '%  |  COMBO ' + w.comboHits + ' colpi', 400, 444, '#ffcc80', 9);
  drawText('Speciale: ' + (w.special || 'nessuno'), 400, 462, '#ff8a65', 9);

  // Separator line at very bottom
  drawRect(20, 480, W - 40, 1, '#333');
  drawText('"Nun te scorda\' le mosse, Conte!"', W/2, 498, '#444', 9, 'center');

  // Close button (tappable)
  const closeMBtnW = 100, closeMBtnH = 30;
  const closeMBtnX = W/2 - closeMBtnW/2, closeMBtnY = H - 45;
  const closeMHover = mouseX >= closeMBtnX && mouseX <= closeMBtnX + closeMBtnW && mouseY >= closeMBtnY && mouseY <= closeMBtnY + closeMBtnH;
  drawRect(closeMBtnX, closeMBtnY, closeMBtnW, closeMBtnH, closeMHover ? '#e94560' : 'rgba(233,69,96,0.4)');
  drawText('CHIUDI', W/2, closeMBtnY + 21, '#fff', 13, 'center');

  // Level options: restart or return to hub (only when opened from level/tutorial)
  if (movesScreenPrev === 'level' || movesScreenPrev === 'tutorial') {
    const optY = H - 45;
    // Restart level
    const restartW = 150, restartH = 28;
    const restartX = 20, restartY = optY;
    const restartHover = mouseX >= restartX && mouseX <= restartX + restartW && mouseY >= restartY && mouseY <= restartY + restartH;
    drawRect(restartX, restartY, restartW, restartH, restartHover ? '#ff9800' : 'rgba(255,152,0,0.3)');
    drawText('RICOMINCIA', restartX + restartW/2, restartY + 20, restartHover ? '#fff' : '#ff9800', 11, 'center');
    if (restartHover && mouseClick) {
      movesScreenOpen = false;
      startLevel(currentLevel);
      mouseClick = false;
      return;
    }
    // Back to hub
    const hubW = 150, hubH = 28;
    const hubX = W - hubW - 20, hubY = optY;
    const hubHover = mouseX >= hubX && mouseX <= hubX + hubW && mouseY >= hubY && mouseY <= hubY + hubH;
    drawRect(hubX, hubY, hubW, hubH, hubHover ? '#4caf50' : 'rgba(76,175,80,0.3)');
    drawText('TORNA A VANNI', hubX + hubW/2, hubY + 20, hubHover ? '#fff' : '#4caf50', 11, 'center');
    if (hubHover && mouseClick) {
      movesScreenOpen = false;
      state = 'hub';
      resetPlayer();
      mouseClick = false;
      return;
    }
  }

  // Close on TAB, P, ESC, or tap
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP'] || keysJustPressed['Escape'] || (closeMHover && mouseClick)) {
    toggleMovesScreen();
  }

  mouseClick = false;
}

// ==========================================
// HUB - VANNI
// ==========================================
let hubSelection = 0;
let shopOpen = false;

function drawHub() {
  // Night sky
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#070714');
  grad.addColorStop(0.4, '#0d0d24');
  grad.addColorStop(1, '#1a1a30');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.015 + i * 2) * 0.15;
    drawRect((i * 67) % W, (i * 31) % 100 + 5, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Roman palazzi in background (neighbors)
  drawRect(-10, 140, 160, 270, '#3d3530');
  drawRect(740, 160, 180, 250, '#3a3228');
  for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
    drawRect(10 + c * 55, 170 + r * 60, 24, 35, '#1a1a2e');
    drawRect(760 + c * 55, 185 + r * 60, 24, 35, '#1a1a2e');
  }

  // BAR VANNI - main building
  drawRect(150, 100, 540, 310, '#4a3f35');
  drawRect(150, 100, 540, 4, '#6d5f50');

  // Red/maroon awning with scalloped edge
  drawRect(140, 125, 560, 30, '#8b1a1a');
  drawRect(140, 125, 560, 4, '#c62828');
  for (let i = 0; i < 14; i++) {
    ctx.fillStyle = '#8b1a1a';
    ctx.beginPath();
    ctx.arc(160 + i * 40, 157, 12, 0, Math.PI);
    ctx.fill();
  }

  // BAR VANNI sign on awning
  drawRect(310, 95, 220, 34, '#1a1a1a');
  drawRect(310, 95, 220, 2, '#c62828');
  drawText('BAR VANNI', 420, 118, '#ffd54f', 20, 'center');

  // Bar interior visible through windows (warm glow)
  // Large windows
  for (let i = 0; i < 3; i++) {
    const wx = 175 + i * 175;
    drawRect(wx, 170, 80, 100, '#1a1a2e');
    ctx.globalAlpha = 0.35 + Math.sin(gameTime * 0.02 + i) * 0.1;
    drawRect(wx + 2, 172, 76, 96, '#fff3e0');
    ctx.globalAlpha = 1;
    // Window frame
    drawRect(wx, 170, 80, 3, '#5d4037');
    drawRect(wx, 220, 80, 2, '#5d4037');
    drawRect(wx + 39, 170, 2, 100, '#5d4037');
  }

  // Door - open with warm light
  drawRect(385, 280, 70, 130, '#3e2723');
  drawRect(388, 283, 64, 127, '#2a1f16');
  // Warm light from inside
  ctx.globalAlpha = 0.4;
  ctx.fillStyle = '#ffcc80';
  ctx.beginPath();
  ctx.arc(420, 310, 50, Math.PI, 0);
  ctx.fill();
  ctx.globalAlpha = 0.2;
  ctx.fillRect(370, 340, 100, 70);
  ctx.globalAlpha = 1;
  // Espresso machine glow inside (through door)
  drawRect(400, 300, 20, 25, '#666');
  drawRect(404, 295, 12, 8, '#aaa');
  ctx.globalAlpha = 0.6;
  drawRect(406, 302, 8, 4, '#ff6f00');
  ctx.globalAlpha = 1;

  // Outdoor tables (2 small round tables with chairs)
  // Table 1
  drawRect(185, 375, 50, 4, '#5d4037');
  drawRect(207, 379, 6, 30, '#4e342e');
  drawRect(180, 385, 8, 20, '#4e342e');
  drawRect(230, 385, 8, 20, '#4e342e');
  // Coffee cup on table
  drawRect(195, 371, 8, 6, '#fff');
  drawRect(197, 370, 4, 2, '#795548');

  // Table 2
  drawRect(600, 380, 50, 4, '#5d4037');
  drawRect(622, 384, 6, 25, '#4e342e');
  drawRect(595, 390, 8, 18, '#4e342e');
  drawRect(645, 390, 8, 18, '#4e342e');
  // Ashtray
  drawRect(612, 377, 12, 4, '#9e9e9e');

  // Street lamp
  drawRect(120, 200, 4, 210, '#424242');
  drawRect(112, 196, 20, 6, '#424242');
  ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.03) * 0.1;
  ctx.fillStyle = '#ffcc80';
  ctx.beginPath();
  ctx.arc(122, 192, 22, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Street lamp 2
  drawRect(720, 220, 4, 190, '#424242');
  drawRect(712, 216, 20, 6, '#424242');
  ctx.globalAlpha = 0.25 + Math.sin(gameTime * 0.03 + 2) * 0.1;
  ctx.fillStyle = '#ffcc80';
  ctx.beginPath();
  ctx.arc(722, 212, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Cobblestone ground
  drawRect(0, 410, W, 140, '#2c2218');
  drawRect(0, 410, W, 3, '#4e3d2e');
  for (let i = 0; i < 35; i++) {
    ctx.globalAlpha = 0.12;
    drawRect(i * 28 + (Math.floor(i/2) % 2 === 0 ? 0 : 14), 415, 24, 11, '#4a3d30');
    drawRect(i * 28 + (Math.floor(i/2) % 2 === 0 ? 14 : 0), 428, 24, 11, '#4a3d30');
    ctx.globalAlpha = 1;
  }

  // === TOP BAR ===
  drawRect(0, 0, W, 50, 'rgba(0,0,0,0.75)');
  drawRect(0, 48, W, 2, '#4e342e');
  drawText('COINS: ' + coins, 25, 28, '#ffd700', 14);
  // Lives display in hub
  if (difficulty === 'easy') {
    drawText('\u221E', 38, 46, '#4caf50', 14, 'center');
  } else {
    for (let li = 0; li < 3; li++) {
      const alive = li < lives;
      drawRect(25 + li * 22, 34, 18, 14, alive ? '#e94560' : '#333');
      drawText(alive ? '\u2665' : '\u2661', 34 + li * 22, 46, alive ? '#fff' : '#555', 11, 'center');
    }
  }
  drawText('Base del Conte', W/2, 32, '#a1887f', 13, 'center');
  // Shop button
  const shopBx = 720, shopBy = 10;
  const shopHover = mouseX > shopBx && mouseX < shopBx + 150 && mouseY > shopBy && mouseY < shopBy + 32;
  drawRect(shopBx, shopBy, 150, 32, shopHover ? '#d84315' : '#bf360c');
  drawRect(shopBx, shopBy, 150, 2, '#ff6e40');
  drawText('ARMERIA [S]', shopBx + 75, shopBy + 22, '#fff', 13, 'center');
  if (!showCredits && ((shopHover && mouseClick) || keys['KeyS'])) {
    state = 'shop';
    shopTab = 0;
    mouseClick = false;
  }

  // Moves button
  const movesBx = 550, movesBy = 10;
  const movesHover = mouseX > movesBx && mouseX < movesBx + 160 && mouseY > movesBy && mouseY < movesBy + 32;
  drawRect(movesBx, movesBy, 160, 32, movesHover ? '#1565c0' : '#0d47a1');
  drawRect(movesBx, movesBy, 160, 2, '#42a5f5');
  drawText('MOSSE [TAB]', movesBx + 80, movesBy + 22, '#fff', 13, 'center');
  if (!showCredits && ((movesHover && mouseClick) || keysJustPressed['Tab'] || keysJustPressed['KeyP'])) {
    toggleMovesScreen();
    mouseClick = false;
  }

  // === LEVEL SELECT ===
  drawRect(30, 435, W - 60, 105, 'rgba(0,0,0,0.7)');
  drawRect(30, 435, W - 60, 2, '#e94560');
  drawText('SCEGLI BATTAGLIA', 60, 455, '#e94560', 13);

  // Keyboard navigation
  if (!showCredits && (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA'])) {
    hubSelection = Math.max(0, hubSelection - 1);
    playSFX('hit');
  }
  if (!showCredits && (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD'])) {
    hubSelection = Math.min(levels.length - 1, hubSelection + 1);
    playSFX('hit');
  }
  // Number keys to jump to level
  if (!showCredits) {
  for (let n = 0; n < levels.length; n++) {
    if (keysJustPressed['Digit' + (n+1)]) {
      hubSelection = n;
      playSFX('hit');
    }
  }
  }
  // Enter to start selected level
  if (!showCredits && (keysJustPressed['Enter'] || keysJustPressed['Space'])) {
    const selLocked = hubSelection > 0 && !bossDefeated[hubSelection - 1];
    if (!selLocked) {
      currentLevel = hubSelection;
      startLevel(hubSelection);
      return;
    } else {
      playSFX('hurt');
    }
  }

  for (let i = 0; i < levels.length; i++) {
    const bx = 50 + i * 168;
    const by = 462;
    const locked = i > 0 && !bossDefeated[i - 1];
    const beaten = bossDefeated[i];
    const isHover = mouseX > bx && mouseX < bx + 158 && mouseY > by && mouseY < by + 68;
    const isSelected = i === hubSelection;

    // Mouse hover updates selection
    if (isHover && (mouseX !== 0 || mouseY !== 0)) hubSelection = i;

    const bgColor = beaten ? '#1b5e20' : locked ? '#333' : (isSelected || isHover) ? '#b71c1c' : '#4a1a1a';
    drawRect(bx, by, 158, 68, bgColor);
    drawRect(bx, by, 158, 2, beaten ? '#4caf50' : locked ? '#555' : '#e94560');

    // Selection highlight border (animated pulse)
    if (isSelected && !locked) {
      const pulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 2 + pulse;
      ctx.strokeRect(bx - 2, by - 2, 162, 72);
      ctx.lineWidth = 1;
    }

    drawText((i+1) + '.', bx + 8, by + 20, beaten ? '#66bb6a' : locked ? '#555' : '#e94560', 11);

    if (locked) {
      drawText('???', bx + 80, by + 20, '#555', 14, 'center');
      drawText('???', bx + 80, by + 38, '#444', 9, 'center');
      ctx.globalAlpha = 0.7;
      drawRect(bx, by, 158, 68, 'rgba(0,0,0,0.5)');
      ctx.globalAlpha = 1;
      drawText('LOCKED', bx + 80, by + 55, '#777', 10, 'center');
    } else if (beaten) {
      drawText(levels[i].boss, bx + 80, by + 20, '#a5d6a7', 13, 'center');
      drawText(levels[i].name, bx + 80, by + 38, '#81c784', 9, 'center');
      drawText('SCONFITTO', bx + 80, by + 55, '#4caf50', 9, 'center');
    } else {
      drawText(levels[i].boss, bx + 80, by + 20, '#fff', 13, 'center');
      drawText(levels[i].name, bx + 80, by + 38, '#ffcdd2', 9, 'center');
      drawText(isSelected ? '[ ENTER ]' : '', bx + 80, by + 55, '#fff', 9, 'center');
    }

    if (isHover && mouseClick && !locked) {
      currentLevel = i;
      startLevel(i);
      mouseClick = false;
      return;
    }
  }

  // === HELPER INFO BAR ===
  drawRect(30, 56, W - 60, 30, 'rgba(0,0,0,0.5)');
  drawRect(30, 84, W - 60, 2, '#4e342e');
  const helperLabels = ['1:Pirox STUN', '2:Tommy DMG', '3:Cicca HEAL', '4:Mostro SPD'];
  for (let i = 0; i < 4; i++) {
    const hx = 42 + i * 210;
    drawRect(hx, 62, 8, 18, helpers[i].color);
    drawText(helperLabels[i], hx + 14, 76, '#aaa', 10);
  }

  // Controls hint
  drawText(isTouchDevice ? 'Tocca per scegliere e combattere' : '< A/D > Scegli   ENTER = Combatti   S = Armeria', W/2, 425, '#666', 10, 'center');

  // Small "Crediti" button bottom-right corner
  const credBtnX = W - 75, credBtnY = H - 24, credBtnW = 65, credBtnH = 18;
  const hoverCred = mouseX >= credBtnX && mouseX <= credBtnX + credBtnW && mouseY >= credBtnY && mouseY <= credBtnY + credBtnH;
  drawRect(credBtnX, credBtnY, credBtnW, credBtnH, hoverCred ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)');
  drawText('Crediti', credBtnX + 33, credBtnY + 14, hoverCred ? '#aaa' : '#555', 10, 'center');
  if (mouseClick && hoverCred) {
    showCredits = true;
    codeInput = '';
    mouseClick = false;
  }

  // === Credits overlay with code entry ===
  if (showCredits) {
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.85)');
    const panelX = W/2 - 200, panelY = isTouchDevice ? 30 : 100, panelW = 400, panelH = isTouchDevice ? 500 : 340;
    drawRect(panelX, panelY, panelW, panelH, 'rgba(20,20,40,0.95)');
    drawRect(panelX, panelY, panelW, 2, '#e94560');
    drawRect(panelX, panelY + panelH - 2, panelW, 2, '#e94560');

    const tOff = isTouchDevice ? -50 : 0;
    drawText('- CREDITI -', W/2, 130 + tOff, '#e94560', 22, 'center');
    drawText('LA GUERRA DI VALLE AURELIA', W/2, 155 + tOff, '#ffd700', 14, 'center');
    drawText('Un gioco da conti...anzi, del Conte!', W/2, 175 + tOff, '#ccc', 11, 'center');
    drawText('Ambientato a Prati, Roma', W/2, 193 + tOff, '#aaa', 11, 'center');
    drawText('Sviluppatore: Cicca', W/2, 214 + tOff, '#aaa', 11, 'center');
    drawText('Programmazione: Cicca + Claude', W/2, 232 + tOff, '#aaa', 11, 'center');
    drawText('Idea & Design: Cicca', W/2, 250 + tOff, '#aaa', 11, 'center');
    drawText('Grazie per aver giocato!', W/2, 272 + tOff, '#ffcc80', 12, 'center');

    // Code entry box
    const codeY = isTouchDevice ? 280 : 320;
    drawRect(W/2 - 90, codeY, 180, 28, 'rgba(255,255,255,0.08)');
    drawRect(W/2 - 90, codeY, 180, 1, '#555');
    drawRect(W/2 - 90, codeY + 27, 180, 1, '#555');
    const cursor = Math.floor(gameTime / 30) % 2 === 0 ? '_' : '';
    const displayCode = codeInput + cursor;
    drawText(displayCode || 'Inserisci codice...', W/2, codeY + 20, codeInput ? '#fff' : '#555', 12, 'center');

    // On-screen keyboard for mobile
    drawCreditsKeyboard(codeY + 35);

    // Close button
    const closeBtnY2 = isTouchDevice ? codeY + 130 : 370;
    const closeBtnX = W/2 - 40, closeBtnW = 80, closeBtnH = 24;
    const hoverClose = mouseX >= closeBtnX && mouseX <= closeBtnX + closeBtnW && mouseY >= closeBtnY2 && mouseY <= closeBtnY2 + closeBtnH;
    drawRect(closeBtnX, closeBtnY2, closeBtnW, closeBtnH, hoverClose ? '#e94560' : 'rgba(233,69,96,0.4)');
    drawText('Chiudi', W/2, closeBtnY2 + 17, '#fff', 11, 'center');
    if (mouseClick && hoverClose) {
      showCredits = false;
      codeInput = '';
      mouseClick = false;
    }

    // Handle keyboard input for code entry
    const letterKeys = ['KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG','KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT','KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ'];
    letterKeys.forEach(k => {
      if (keysJustPressed[k]) {
        if (codeInput.length < 12) codeInput += k.charAt(3);
      }
    });
    if (keysJustPressed['Backspace']) codeInput = codeInput.slice(0, -1);

    // Check for CONTE code
    if (codeInput === 'CONTE') {
      showCredits = false;
      codeInput = '';
      coins = 9999;
      bossDefeated = [true, true, true, true, true];
      player.maxHp = 999;
      player.hp = 999;
      player.maxStamina = 999;
      player.stamina = 999;
      player.invincible = 999999;
      player.speed = 6;
      UPGRADE_POOL.forEach(u => { if (!player.upgrades.some(e => e.effect === u.effect)) player.upgrades.push(u); });
      helpers.forEach(h => { h.tier = 3; h.unlocked = true; });
      screenFlash = 20;
      flashColor = '#ffd700';
      showQuickText('CONTE MODE ACTIVATED! SEI INVINCIBILE!', '#ffd700');
      playSFX('victory_jingle');
      spawnParticles(W/2, H/2, '#ffd700', 40, 10);
    }

    // Check for SABI code
    if (codeInput === 'SABI') {
      showCredits = false;
      codeInput = '';
      sabiTimer = 0;
      sabiCicca = { x: 200, y: GROUND_Y, vx: 0, facing: 1, animTimer: 0 };
      sabiSabi = { x: 450, y: GROUND_Y, animTimer: 0, petting: false };
      sabiTotti = { x: 650, y: GROUND_Y, animTimer: 0, wagging: true, fetching: false };
      sabiMessages = [];
      sabiPreviousState = state;
      state = 'sabi';
      screenFlash = 15;
      flashColor = '#ff69b4';
      playSFX('coin');
    }

    // Check for FREESTYLE code
    if (codeInput === 'FREESTYLE') {
      showCredits = false;
      codeInput = '';
      startFreestyleVideo();
    }

    mouseClick = false;
    return; // Block hub interaction while credits open
  }

  // Show cheat active indicator
  if (player.maxHp >= 999) {
    drawText('CONTE MODE', W/2, 105, '#ffd700', 11, 'center');
  }

  // Check all beaten
  if (bossDefeated.every(b => b) && player.maxHp < 999) {
    victoryTimer = 0;
    state = 'victory';
  }

  mouseClick = false;
}

// ==========================================
// SHOP — 3 tabs: Potenzia Arma, Potenzia Helper, La Ruota (gacha)
// ==========================================
let shopScroll = 0;

function drawShop() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  drawText('ARMERIA DI VANNI', W/2, 24, '#ffd700', 20, 'center');
  drawText('COINS: ' + coins, W/2, 44, '#ffd700', 14, 'center');

  // === TAB BUTTONS ===
  const tabNames = ['ARMA', 'HELPER', 'LA RUOTA', 'STATS'];
  const tabColors = ['#ff8a65', '#e040fb', '#ffd700', '#4caf50'];
  const tabW = 200, tabH = 28, tabY = 56;
  for (let t = 0; t < 4; t++) {
    const tx = 25 + t * (tabW + 10);
    const active = shopTab === t;
    const hover = mouseX > tx && mouseX < tx + tabW && mouseY > tabY && mouseY < tabY + tabH;
    drawRect(tx, tabY, tabW, tabH, active ? tabColors[t] : hover ? '#333' : '#222');
    drawText(tabNames[t], tx + tabW/2, tabY + 19, active ? '#000' : '#888', 11, 'center');
    if (hover && mouseClick) {
      shopTab = t;
      mouseClick = false;
    }
  }
  // Tab keys
  if (keysJustPressed['Digit1']) shopTab = 0;
  if (keysJustPressed['Digit2']) shopTab = 1;
  if (keysJustPressed['Digit3']) shopTab = 2;
  if (keysJustPressed['Digit4']) shopTab = 3;

  const panelY = 92;

  if (shopTab === 0) drawShopWeapon(panelY);
  else if (shopTab === 1) drawShopHelper(panelY);
  else if (shopTab === 2) drawShopGacha(panelY);
  else drawShopStats(panelY);

  // Back button
  const backHover = mouseX > 30 && mouseX < 150 && mouseY > H - 38 && mouseY < H - 10;
  drawRect(30, H - 38, 120, 28, backHover ? '#c62828' : '#b71c1c');
  drawText('INDIETRO [ESC]', 90, H - 20, '#fff', 11, 'center');
  if ((backHover && mouseClick) || keys['Escape']) {
    state = 'hub';
    mouseClick = false;
  }

  mouseClick = false;
}

// --- Tab 0: Weapon Upgrade ---
function drawShopWeapon(py) {
  const w = weapons[0];
  const tierNames = ['BASE', 'POTENZIATO', 'RINFORZATO', 'LEGGENDARIO'];
  const tierGlows = [null, '#ff8a65', '#ff5722', '#ffd700'];

  // Current weapon display
  drawRect(40, py, W - 80, 120, '#222');
  drawRect(40, py, 4, 120, w.color || '#888');

  // Tier glow effect
  if (weaponTier > 0 && tierGlows[weaponTier]) {
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.05) * 0.05;
    drawRect(40, py, W - 80, 120, tierGlows[weaponTier]);
    ctx.globalAlpha = 1;
  }

  // Rarity badge in shop
  let shopRarLetter = 'C', shopRarColor = '#9e9e9e';
  if (rareWeapons.some(rw => rw.name === w.name)) { shopRarLetter = 'R'; shopRarColor = '#2196f3'; }
  else if (legendaryWeapons.some(lw => lw.name === w.name)) { shopRarLetter = 'L'; shopRarColor = '#ffd700'; }
  drawRect(48, py + 6, 20, 20, shopRarColor);
  drawText(shopRarLetter, 58, py + 21, '#000', 12, 'center');
  drawText(w.name + ' — ' + tierNames[weaponTier], 76, py + 20, '#fff', 16);
  drawText(w.desc, 76, py + 38, '#aaa', 10);

  // Stats display
  const sx = 60, sy = py + 55;
  drawText('DMG: ' + w.damage, sx, sy, '#ff8a80', 11);
  drawText('RNG: ' + w.range, sx + 140, sy, '#80d8ff', 11);
  drawText('SPD: ' + (30 - w.speed), sx + 280, sy, '#b9f6ca', 11);
  drawText('CRIT: ' + w.crit + '%', sx + 420, sy, '#ffcc80', 11);
  drawText('COMBO: ' + w.comboHits + ' colpi', sx + 560, sy, '#e040fb', 11);
  drawText('Speciale: ' + (w.special || 'nessuno'), sx, sy + 18, '#ff8a65', 10);

  // Stat bars
  const bsy = py + 90;
  drawStatBar(60, bsy, 'DANNO', w.damage, 45, 160, '#f44336');
  drawStatBar(260, bsy, 'RAGGIO', Math.min(w.range, 100), 100, 160, '#2196f3');
  drawStatBar(460, bsy, 'VELOCITA\'', 20 - w.speed, 20, 160, '#4caf50');
  drawStatBar(660, bsy, 'CRITICO', w.crit, 35, 160, '#ffeb3b');

  // Upgrade tiers
  drawText('POTENZIAMENTI DISPONIBILI', W/2, py + 140, '#ff8a65', 13, 'center');

  const upgDescs = [
    { label: 'Lv.1 — Affilatura', desc: '+10% danno base', cost: WEAPON_UPGRADE_COSTS[0] },
    { label: 'Lv.2 — Tecnica Avanzata', desc: '+1 colpo combo', cost: WEAPON_UPGRADE_COSTS[1] },
    { label: 'Lv.3 — Arma Suprema', desc: '+12% raggio, bagliore', cost: WEAPON_UPGRADE_COSTS[2] }
  ];

  for (let i = 0; i < 3; i++) {
    const uy = py + 155 + i * 55;
    const unlocked = weaponTier > i;
    const canBuy = weaponTier === i && coins >= upgDescs[i].cost;
    const isNext = weaponTier === i;
    const hover = mouseX > 60 && mouseX < W - 60 && mouseY > uy && mouseY < uy + 48;

    drawRect(60, uy, W - 120, 48, unlocked ? '#1b5e20' : hover && canBuy ? '#333' : '#1a1a1a');
    drawRect(60, uy, 3, 48, unlocked ? '#4caf50' : isNext ? '#ff8a65' : '#333');

    drawText(upgDescs[i].label, 80, uy + 18, unlocked ? '#4caf50' : isNext ? '#fff' : '#555', 12);
    drawText(upgDescs[i].desc, 80, uy + 34, unlocked ? '#81c784' : '#777', 9);

    if (unlocked) {
      drawText('SBLOCCATO', W - 120, uy + 26, '#4caf50', 11, 'center');
    } else if (isNext) {
      drawText(upgDescs[i].cost + ' COINS', W - 120, uy + 26, canBuy ? '#ffd700' : '#666', 12, 'center');
      if (hover && mouseClick && canBuy) {
        coins -= upgDescs[i].cost;
        applyWeaponUpgrade(weaponTier);
        weaponTier++;
        playSFX('coin');
        spawnParticles(W/2, uy + 24, '#ff8a65', 15, 4);
        mouseClick = false;
      }
    } else {
      drawText('BLOCCATO', W - 120, uy + 26, '#444', 10, 'center');
    }
  }

  // Consumables display at bottom
  drawText('CONSUMABILI (usa 5-6-7 in battaglia)', W/2, py + 335, '#aaa', 10, 'center');
  for (let i = 0; i < 3; i++) {
    const ci = consumableItems[i];
    const count = player.consumables.filter(c => c === ci.effect).length;
    const cx = 200 + i * 200;
    drawRect(cx, py + 345, 150, 30, '#222');
    drawRect(cx, py + 345, 3, 30, ci.color);
    drawText('[' + (i+5) + '] ' + ci.name + ' x' + count, cx + 10, py + 363, count > 0 ? '#fff' : '#555', 10);
  }
}

function applyWeaponUpgrade(tier) {
  const w = weapons[0];
  switch(tier) {
    case 0: // +10% damage
      w.damage = Math.round(w.damage * 1.10);
      break;
    case 1: // +1 combo hit
      w.comboHits++;
      break;
    case 2: // +12% range + glow
      w.range = Math.round(w.range * 1.12);
      w.glow = true;
      break;
  }
}

// --- Tab 1: Helper Upgrade ---
function drawShopHelper(py) {
  drawText('POTENZIA I TUOI ALLEATI', W/2, py + 15, '#e040fb', 14, 'center');

  for (let i = 0; i < 4; i++) {
    const h = helpers[i];
    const hx = 40 + i * 212;
    const hy = py + 35;
    const boxH = 180;
    const nextTier = h.tier;
    const maxed = nextTier >= 3;

    drawRect(hx, hy, 200, boxH, '#1a1a2e');
    drawRect(hx, hy, 200, 3, h.color);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(hx, hy, 200, boxH);

    // Helper name + level
    drawText(h.icon + ' ' + h.name, hx + 100, hy + 22, '#fff', 13, 'center');
    drawText('Livello ' + h.tier + '/3', hx + 100, hy + 38, h.color, 10, 'center');
    drawText(h.desc, hx + 100, hy + 54, '#aaa', 9, 'center');

    // Tier pips
    for (let t = 0; t < 3; t++) {
      const pipX = hx + 75 + t * 20;
      drawRect(pipX, hy + 62, 14, 6, t < h.tier ? h.color : '#333');
    }

    // Current tier effects
    if (h.tier > 0) {
      for (let t = 0; t < h.tier; t++) {
        drawText('Lv.' + (t+1) + ': ' + h.tiers[t].desc, hx + 10, hy + 82 + t * 14, '#81c784', 7);
      }
    }

    // Unlock or upgrade button
    const btnY = hy + boxH - 40;
    if (!h.unlocked) {
      // Must unlock first
      const canUnlock = coins >= h.unlockCost;
      const btnHover = mouseX > hx + 10 && mouseX < hx + 190 && mouseY > btnY && mouseY < btnY + 32;
      drawRect(hx + 10, btnY, 180, 32, btnHover && canUnlock ? '#333' : '#222');
      drawText('SBLOCCA', hx + 100, btnY + 12, '#fff', 10, 'center');
      drawText(h.unlockCost + ' COINS', hx + 100, btnY + 26, canUnlock ? '#ffd700' : '#666', 10, 'center');
      if (btnHover && mouseClick && canUnlock) {
        coins -= h.unlockCost;
        h.unlocked = true;
        playSFX('coin');
        spawnParticles(hx + 100, btnY + 16, h.color, 15, 5);
        mouseClick = false;
      }
    } else if (maxed) {
      drawText('MASSIMO', hx + 100, btnY + 20, '#4caf50', 12, 'center');
    } else {
      const tierData = h.tiers[nextTier];
      const canBuy = coins >= tierData.cost;
      const btnHover = mouseX > hx + 10 && mouseX < hx + 190 && mouseY > btnY && mouseY < btnY + 32;

      drawRect(hx + 10, btnY, 180, 32, btnHover && canBuy ? '#333' : '#222');
      drawText('Lv.' + (nextTier+1) + ': ' + tierData.desc, hx + 100, btnY + 12, '#ccc', 7, 'center');
      drawText(tierData.cost + ' COINS', hx + 100, btnY + 26, canBuy ? '#ffd700' : '#666', 10, 'center');

      if (btnHover && mouseClick && canBuy) {
        coins -= tierData.cost;
        h.tier++;
        playSFX('coin');
        spawnParticles(hx + 100, btnY + 16, h.color, 12, 4);
        mouseClick = false;
      }
    }
  }
}

// --- Tab 2: La Ruota (Gacha) ---
function drawShopGacha(py) {
  drawText('LA RUOTA DELLA FORTUNA', W/2, py + 15, '#ffd700', 16, 'center');
  drawText('"Gira gira, Conte... vediamo che esce!"', W/2, py + 34, '#aaa', 10, 'center');
  drawText('Costo: ' + GACHA_COST + ' coins', W/2, py + 52, coins >= GACHA_COST ? '#ffd700' : '#666', 12, 'center');

  // Slot machine frame
  const slotX = W/2 - 150, slotY = py + 70, slotW = 300, slotH = 120;
  drawRect(slotX - 4, slotY - 4, slotW + 8, slotH + 8, '#ffd700');
  drawRect(slotX, slotY, slotW, slotH, '#111');

  if (gachaSpinning) {
    // Spinning animation — show random items
    gachaSpinTimer--;
    const symbols = ['?', '!', '*', '$', '#', '@', '&', '%'];
    for (let s = 0; s < 3; s++) {
      const sym = symbols[Math.floor((gameTime + s * 7) / (gachaSpinTimer < 20 ? 6 : 2)) % symbols.length];
      drawText(sym, slotX + 50 + s * 100, slotY + 68, '#ffd700', 36, 'center');
    }

    if (gachaSpinTimer <= 0) {
      gachaSpinning = false;
      gachaResult = rollGacha();
      gachaResultTimer = 300;
    }
  } else if (gachaResult && gachaResultTimer > 0) {
    gachaResultTimer--;
    // Show result
    const r = gachaResult;
    const bounce = Math.sin(gachaResultTimer * 0.1) * 3;

    if (r.type === 'nothing') {
      drawText('NIENTE!', W/2, slotY + 40 + bounce, '#ff5722', 24, 'center');
      drawText(r.joke, W/2, slotY + 70, '#ffcc80', 9, 'center');
      // Sad trombone particles
      if (gachaResultTimer === 298) spawnParticles(W/2, slotY + 50, '#666', 8, 3);
    } else if (r.type === 'consumable') {
      drawText('CONSUMABILE!', W/2, slotY + 35 + bounce, '#4caf50', 20, 'center');
      drawText(r.item.name + ' — ' + r.item.desc, W/2, slotY + 60, '#fff', 12, 'center');
      drawText('(usa tasto ' + (5 + consumableItems.indexOf(r.item)) + ' in battaglia)', W/2, slotY + 80, '#aaa', 9, 'center');
    } else if (r.type === 'rare') {
      drawText('ARMA RARA!', W/2, slotY + 30 + bounce, '#2196f3', 22, 'center');
      ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.1) * 0.1;
      drawRect(slotX + 20, slotY + 10, slotW - 40, slotH - 20, '#2196f3');
      ctx.globalAlpha = 1;
      drawText(r.weapon.name, W/2, slotY + 58, '#fff', 16, 'center');
      drawText(r.weapon.desc, W/2, slotY + 78, '#aaa', 10, 'center');
      drawText('DMG:' + r.weapon.damage + '  RNG:' + r.weapon.range + '  CRIT:' + r.weapon.crit + '%', W/2, slotY + 96, '#80d8ff', 9, 'center');
    } else if (r.type === 'legendary') {
      // Epic legendary reveal
      const flash = Math.sin(gameTime * 0.15) * 0.2 + 0.3;
      ctx.globalAlpha = flash;
      drawRect(slotX, slotY, slotW, slotH, '#ffd700');
      ctx.globalAlpha = 1;
      drawText('LEGGENDARIA!!!', W/2, slotY + 30 + bounce, '#ffd700', 24, 'center');
      drawText(r.weapon.name, W/2, slotY + 60, '#fff', 18, 'center');
      drawText(r.weapon.desc, W/2, slotY + 80, '#ffcc80', 10, 'center');
      drawText('DMG:' + r.weapon.damage + '  RNG:' + r.weapon.range + '  CRIT:' + r.weapon.crit + '%', W/2, slotY + 98, '#ffd700', 9, 'center');
      if (gachaResultTimer % 10 === 0) spawnParticles(W/2 + (Math.random()-0.5)*200, slotY + 50, '#ffd700', 5, 3);
    }

    // Equip button for weapon results
    if ((r.type === 'rare' || r.type === 'legendary') && r.equipped === false) {
      const eqY = slotY + slotH + 15;
      const eqHover = mouseX > W/2 - 80 && mouseX < W/2 + 80 && mouseY > eqY && mouseY < eqY + 30;
      drawRect(W/2 - 80, eqY, 160, 30, eqHover ? '#1b5e20' : '#2e7d32');
      drawText('EQUIPAGGIA [E]', W/2, eqY + 20, '#fff', 12, 'center');
      if ((eqHover && mouseClick) || keysJustPressed['KeyE']) {
        const newWeap = JSON.parse(JSON.stringify(r.weapon));
        if (newWeap.maxAmmo) newWeap.currentAmmo = newWeap.maxAmmo;
        weapons = [newWeap];
        weaponTier = 0;
        r.equipped = true;
        spawnParticles(W/2, eqY + 15, r.weapon.color || '#fff', 20, 5);
        playSFX('coin');
        mouseClick = false;
      }
    }
  } else {
    // Idle state — show "GIRA!"
    drawText('???', W/2, slotY + 68, '#555', 40, 'center');
  }

  // Spin button
  if (!gachaSpinning) {
    const btnY = slotY + slotH + 55;
    const canSpin = coins >= GACHA_COST;
    const btnHover = mouseX > W/2 - 100 && mouseX < W/2 + 100 && mouseY > btnY && mouseY < btnY + 40;
    drawRect(W/2 - 100, btnY, 200, 40, canSpin ? (btnHover ? '#e65100' : '#bf360c') : '#333');
    drawRect(W/2 - 100, btnY, 200, 3, canSpin ? '#ff6e40' : '#555');
    drawText('GIRA! (' + GACHA_COST + ' coins)', W/2, btnY + 26, canSpin ? '#fff' : '#666', 14, 'center');

    if (btnHover && mouseClick && canSpin) {
      coins -= GACHA_COST;
      gachaSpinning = true;
      gachaSpinTimer = 60 + Math.floor(Math.random() * 30);
      gachaResult = null;
      gachaResultTimer = 0;
      playSFX('hit');
      mouseClick = false;
    }
  }

  // Mystery hint
  drawText('Tenta la fortuna, Conte...', W/2, H - 58, '#444', 8, 'center');
}

function rollGacha() {
  const roll = Math.random();
  if (roll < 0.50) {
    // Nothing — joke
    return { type: 'nothing', joke: gachaJokes[Math.floor(Math.random() * gachaJokes.length)] };
  } else if (roll < 0.80) {
    // Consumable
    const item = consumableItems[Math.floor(Math.random() * consumableItems.length)];
    if (player.consumables.length < 3) {
      player.consumables.push(item.effect);
    } else {
      // Inventory full — give a random replacement or just notify
      return { type: 'nothing', joke: '"Hai le tasche piene, Conte! Usa qualcosa prima."' };
    }
    return { type: 'consumable', item: item };
  } else if (roll < 0.95) {
    // Rare weapon (15% chance)
    const w = rareWeapons[Math.floor(Math.random() * rareWeapons.length)];
    return { type: 'rare', weapon: w, equipped: false };
  } else {
    // Legendary!
    const w = legendaryWeapons[Math.floor(Math.random() * legendaryWeapons.length)];
    return { type: 'legendary', weapon: w, equipped: false };
  }
}

// Consumable usage function (called during level)
function useConsumable(slot) {
  if (state !== 'level') return;
  if (slot < 0 || slot >= player.consumables.length) return;
  const effect = player.consumables[slot];
  const item = consumableItems.find(c => c.effect === effect);
  if (!item) return;

  player.consumables.splice(slot, 1);

  switch(effect) {
    case 'heal':
      player.hp = Math.min(player.hp + item.value, player.maxHp);
      spawnParticles(player.x, player.y - 20, '#4caf50', 10, 3);
      showQuickText('+' + item.value + ' HP!', '#4caf50');
      break;
    case 'freeStamina':
      player.consumableTimers.freeStamina = item.value;
      spawnParticles(player.x, player.y - 20, '#4e342e', 10, 3);
      showQuickText('STAMINA GRATIS!', '#4e342e');
      break;
    case 'dmgBoost':
      player.consumableTimers.dmgBoost = item.value;
      spawnParticles(player.x, player.y - 20, '#ffcc80', 10, 3);
      showQuickText('+30% DANNO!', '#ffcc80');
      break;
  }
  playSFX('coin');
}

// --- Tab 3: Stats Upgrade ---
function drawShopStats(py) {
  drawText('POTENZIA IL CONTE', W/2, py + 15, '#4caf50', 16, 'center');

  const stats = [
    { name: 'SALTO', desc: 'Salto piu\' alto', tier: jumpTier, icon: 'W',
      color: '#4caf50', tierDescs: ['Salto base', 'Salto +9%', 'Salto +18%', 'Salto +27%'] },
    { name: 'SCHIVATA', desc: 'Cooldown schivata ridotto', tier: dodgeTier, icon: 'X',
      color: '#2196f3', tierDescs: ['Cooldown base', 'Cooldown -17%', 'Cooldown -31%', 'Cooldown -46%'] },
    { name: 'VELOCITA\'', desc: 'Movimento piu\' veloce', tier: speedTier, icon: '>',
      color: '#ff9800', tierDescs: ['Velocita\' base', 'Velocita\' +10%', 'Velocita\' +20%', 'Velocita\' +33%'] },
  ];

  for (let i = 0; i < 3; i++) {
    const s = stats[i];
    const sx = 40 + i * 280;
    const sy = py + 35;
    const boxW = 260, boxH = 360;

    drawRect(sx, sy, boxW, boxH, '#1a1a2e');
    drawRect(sx, sy, boxW, 3, s.color);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(sx, sy, boxW, boxH);

    // Icon + name
    drawText(s.icon, sx + boxW/2, sy + 40, s.color, 28, 'center');
    drawText(s.name, sx + boxW/2, sy + 62, '#fff', 14, 'center');
    drawText(s.desc, sx + boxW/2, sy + 78, '#aaa', 9, 'center');

    // Level pips
    for (let t = 0; t < 3; t++) {
      const pipX = sx + boxW/2 - 30 + t * 22;
      drawRect(pipX, sy + 88, 16, 8, t < s.tier ? s.color : '#333');
    }
    drawText('Lv.' + s.tier + '/3', sx + boxW/2, sy + 112, s.color, 10, 'center');

    // Current effect
    drawText(s.tierDescs[s.tier], sx + boxW/2, sy + 130, '#81c784', 9, 'center');

    // Upgrade tiers
    for (let t = 0; t < 3; t++) {
      const uy = sy + 148 + t * 60;
      const unlocked = s.tier > t;
      const isNext = s.tier === t;
      const cost = STAT_UPGRADE_COSTS[t];
      const canBuy = isNext && coins >= cost;
      const hover = mouseX > sx + 10 && mouseX < sx + boxW - 10 && mouseY > uy && mouseY < uy + 50;

      drawRect(sx + 10, uy, boxW - 20, 50, unlocked ? '#1b5e20' : hover && canBuy ? '#333' : '#1a1a1a');
      drawRect(sx + 10, uy, 3, 50, unlocked ? '#4caf50' : isNext ? s.color : '#333');

      drawText('Lv.' + (t+1), sx + 25, uy + 20, unlocked ? '#4caf50' : isNext ? '#fff' : '#555', 11);
      drawText(stats[i].tierDescs[t+1], sx + 25, uy + 36, unlocked ? '#81c784' : '#777', 8);

      if (unlocked) {
        drawText('SBLOCCATO', sx + boxW - 50, uy + 28, '#4caf50', 9, 'center');
      } else if (isNext) {
        drawText(cost + ' COINS', sx + boxW - 50, uy + 28, canBuy ? '#ffd700' : '#666', 10, 'center');
        if (hover && mouseClick && canBuy) {
          coins -= cost;
          if (i === 0) { jumpTier++; }
          else if (i === 1) { dodgeTier++; }
          else { speedTier++; player.speed = SPEED_VALUES[speedTier]; }
          playSFX('coin');
          spawnParticles(sx + boxW/2, uy + 25, s.color, 15, 4);
          mouseClick = false;
        }
      } else {
        drawText('BLOCCATO', sx + boxW - 50, uy + 28, '#444', 9, 'center');
      }
    }
  }
}

// ==========================================
// UPGRADE SELECTION (after level victory)
// ==========================================
let upgradeSelection = 0;

function calculateLevelGrade() {
  const parTime = 3600 + currentLevel * 600; // 60s base + 10s per level
  const elapsed = gameTime - levelStartTime;
  const timeBonus = elapsed < parTime ? 1.5 : elapsed < parTime * 1.5 ? 1.0 : 0.7;
  const dmgRatio = Math.min(1, levelDamageTaken / player.maxHp);
  const finalScore = Math.floor((levelScore + stylePoints) * (1 - dmgRatio * 0.3) * timeBonus);
  const maxPossible = (totalKills * 100 + 500) * 1.5; // rough estimate
  const pct = Math.min(1, finalScore / Math.max(1, maxPossible));

  let grade, gradeColor;
  if (pct >= 0.95) { grade = 'S'; gradeColor = '#ffd700'; }
  else if (pct >= 0.80) { grade = 'A'; gradeColor = '#4caf50'; }
  else if (pct >= 0.60) { grade = 'B'; gradeColor = '#2196f3'; }
  else if (pct >= 0.40) { grade = 'C'; gradeColor = '#ff9800'; }
  else { grade = 'D'; gradeColor = '#f44336'; }

  lastLevelGrade = grade;
  lastLevelBreakdown = {
    score: finalScore,
    kills: totalKills,
    dmgTaken: Math.floor(levelDamageTaken),
    timeBonus: timeBonus,
    grade: grade,
    gradeColor: gradeColor,
    elapsed: Math.floor(elapsed / 60)
  };
  return grade;
}

function generateUpgradeChoices() {
  // Grade-based rewards: more choices for better grades
  const grade = lastLevelGrade;
  const gradeBonus = { S: 80, A: 50, B: 25, C: 10, D: 0 };
  const bonus = gradeBonus[grade] || 0;
  if (bonus > 0) {
    coins += bonus;
    spawnParticles(W/2, 80, '#ffd700', bonus > 20 ? 20 : 10, 4);
  }
  lastLevelBreakdown.coinBonus = bonus;

  // Pick upgrades not already owned — S/A get 4 choices, others get 3
  const numChoices = (grade === 'S' || grade === 'A') ? 4 : 3;
  const owned = player.upgrades.map(u => u.effect);
  let available = UPGRADE_POOL.filter(u => !owned.includes(u.effect));

  // S grade: bias toward mossa/mod upgrades (the powerful ones)
  if (grade === 'S' && available.length > numChoices) {
    const powerful = available.filter(u => u.cat === 'mossa' || u.cat === 'mod');
    const basic = available.filter(u => u.cat === 'stat');
    // Guarantee at least 1 powerful if available
    if (powerful.length > 0) {
      const shuffledPowerful = powerful.sort(() => Math.random() - 0.5);
      const shuffledBasic = basic.sort(() => Math.random() - 0.5);
      available = [...shuffledPowerful, ...shuffledBasic];
    }
  } else {
    available = available.sort(() => Math.random() - 0.5);
  }

  upgradeChoices = [];
  for (let i = 0; i < Math.min(numChoices, available.length); i++) {
    upgradeChoices.push(available[i]);
  }
  upgradeSelection = 0;
}

function applyUpgrade(upgrade) {
  player.upgrades.push(upgrade);
  switch(upgrade.effect) {
    case 'dmg15': break; // applied in damage calc
    case 'hp20': player.maxHp += 20; player.hp = Math.min(player.hp + 20, player.maxHp); break;
    case 'st20': player.maxStamina += 20; player.stamina += 20; break;
    case 'stregen': break; // applied in regen calc
    case 'spd10': player.speed *= 1.1; break;
    case 'crit15': break; // applied in crit calc
    case 'comboext': weapons[0].comboHits++; break;
    // move/mod effects are checked during gameplay
  }
}

function drawUpgradeScreen() {
  ctx.fillStyle = '#0d0d1a';
  ctx.fillRect(0, 0, W, H);

  // Level grade display
  if (lastLevelBreakdown) {
    const b = lastLevelBreakdown;
    drawText('VOTO', W/2 - 70, 35, '#aaa', 10, 'center');
    drawText(b.grade, W/2 - 70, 65, b.gradeColor, 32, 'center');
    drawText('Punteggio: ' + b.score, W/2 + 60, 30, '#ccc', 9, 'center');
    drawText('Tempo: ' + b.elapsed + 's', W/2 + 60, 44, '#ccc', 9, 'center');
    drawText('Danno subito: ' + b.dmgTaken, W/2 + 60, 58, '#ccc', 9, 'center');
    drawText('Bonus tempo: x' + b.timeBonus.toFixed(1), W/2 + 60, 72, '#ccc', 9, 'center');
    if (b.coinBonus > 0) drawText('+' + b.coinBonus + ' COINS bonus!', W/2 + 60, 86, '#ffd700', 9, 'center');
  }

  drawText('SCEGLI UN POTENZIAMENTO', W/2, 100, '#ffd700', 22, 'center');
  drawText('Scegli 1 su ' + upgradeChoices.length, W/2, 120, '#aaa', 12, 'center');

  // Keyboard nav
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) upgradeSelection = Math.max(0, upgradeSelection - 1);
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) upgradeSelection = Math.min(upgradeChoices.length - 1, upgradeSelection + 1);

  const catColors = { stat: '#4caf50', mossa: '#2196f3', mod: '#ff9800' };

  // Dynamic layout: 3 choices = 240px spacing, 4 choices = 200px spacing
  const nc = upgradeChoices.length;
  const cw = nc <= 3 ? 210 : 190;
  const spacing = nc <= 3 ? 240 : 210;
  const startX = Math.floor((W - nc * spacing + (spacing - cw)) / 2);

  for (let i = 0; i < upgradeChoices.length; i++) {
    const u = upgradeChoices[i];
    const cx = startX + i * spacing;
    const cy = 140;
    const ch = 260;
    const isHover = mouseX > cx && mouseX < cx + cw && mouseY > cy && mouseY < cy + ch;
    const isSelected = i === upgradeSelection;

    if (isHover && (mouseX !== 0 || mouseY !== 0)) upgradeSelection = i;

    const bgColor = isSelected ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.04)';
    drawRect(cx, cy, cw, ch, bgColor);
    drawRect(cx, cy, cw, 3, catColors[u.cat] || '#fff');

    if (isSelected) {
      const pulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
      ctx.strokeStyle = catColors[u.cat] || '#fff';
      ctx.lineWidth = 2 + pulse;
      ctx.strokeRect(cx - 2, cy - 2, cw + 4, ch + 4);
      ctx.lineWidth = 1;
    }

    // Icon
    drawRect(cx + cw/2 - 25, cy + 20, 50, 50, 'rgba(0,0,0,0.5)');
    drawText(u.icon, cx + cw/2, cy + 55, catColors[u.cat], 28, 'center');

    // Category
    drawText(u.cat.toUpperCase(), cx + cw/2, cy + 90, catColors[u.cat], 10, 'center');

    // Name
    drawText(u.name, cx + cw/2, cy + 115, '#fff', 14, 'center');

    // Description (word wrap manually for short box)
    const words = u.desc.split(' ');
    let line = '', lineY = cy + 145;
    words.forEach(w => {
      const test = line + w + ' ';
      if (test.length > 22) {
        drawText(line.trim(), cx + cw/2, lineY, '#aaa', 10, 'center');
        lineY += 14;
        line = w + ' ';
      } else {
        line = test;
      }
    });
    if (line.trim()) drawText(line.trim(), cx + cw/2, lineY, '#aaa', 10, 'center');

    // Click to select
    if (isHover && mouseClick) {
      applyUpgrade(u);
      state = 'hub';
      mouseClick = false;
      return;
    }
  }

  // Enter to select
  if (keysJustPressed['Enter'] || keysJustPressed['Space']) {
    if (upgradeChoices[upgradeSelection]) {
      applyUpgrade(upgradeChoices[upgradeSelection]);
      state = 'hub';
    }
  }

  // Show owned upgrades
  if (player.upgrades.length > 0) {
    drawText('Ottenuti: ' + player.upgrades.map(u => u.name).join(', '), W/2, H - 30, '#666', 9, 'center');
  }

  mouseClick = false;
}

// ==========================================
// START LEVEL
// ==========================================
let isReplayLevel = false; // true if replaying a beaten level

function startLevel(idx) {
  currentLevel = idx;
  isReplayLevel = bossDefeated[idx]; // track if this was already beaten
  if (difficulty === 'medium') lives = 3; // medium: 3 lives per boss
  // hard: lives carry over; easy: infinite (lives never decremented)
  state = 'dialogue';
  resetPlayer();
  player.x = 100;
  boss = null;
  goons = [];
  projectiles = [];
  particles = [];
  damageNumbers = [];
  coinPickups = [];
  reginaActive = false;
  regina = null;
  mariusoActive = false;
  mariuso = null;
  activeHelperVisuals = [];
  bossIntro = false;
  bossIntroTimer = 0;
  waveClearTimer = 0;
  waveBreatherTimer = 0;
  levelTimer = 0;
  comboCount = 0;
  comboTimer = 0;
  helperCooldowns = [0, 0, 0, 0];
  helperReviveUsed = false;
  warCryTimer = 0;
  warCryCooldown = 0;
  levelDamageTaken = 0;
  levelScore = 0;
  stylePoints = 0;
  levelStartTime = gameTime;
  initHazards(idx);
  // Wave configs: L0: 2+2, L1: 2+2+2, L2: 2+3+2, L3: 3+3+2, L4: 3+3+3
  const WAVE_CONFIGS = [[3,3],[3,3,3],[3,4,3],[4,4,3],[4,4,4]];
  waveConfig = WAVE_CONFIGS[idx] || [3,3];
  currentWave = 0;

  const lvl = levels[idx];
  dialogueLines = [
    '[ ' + lvl.name.toUpperCase() + ' ]',
    lvl.subtitle,
    '---',
    ...lvl.bossLines
  ];
  dialogueIndex = 0;
  dialogueCallback = () => {
    state = 'level';
    spawnGoons(waveConfig[0] || 2); // Spawn first wave
    currentWave = 1;
    showQuickText('WAVE 1/' + waveConfig.length, '#ff9800');
    boss = createBoss(idx);
    boss.x = W + 100; // Boss enters after all waves cleared
  };
}

// ==========================================
// DIALOGUE
// ==========================================
let dialogueCooldown = 0;

function drawDialogue() {
  // Show level background
  drawLevelBg();

  // Darken
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, W, H);

  // Dialogue box
  drawRect(50, H - 160, W - 100, 120, 'rgba(20,20,40,0.95)');
  drawRect(50, H - 160, W - 100, 3, '#e94560');

  if (dialogueIndex < dialogueLines.length) {
    const line = dialogueLines[dialogueIndex];
    drawText(line, W/2, H - 100, '#fff', 16, 'center');

    if (Math.floor(gameTime / 30) % 2 === 0) {
      drawText('[ENTER]', W/2, H - 60, '#888', 11, 'center');
    }

    dialogueCooldown = Math.max(0, dialogueCooldown - 1);
    if ((keysJustPressed['Enter'] || mouseClick) && dialogueCooldown === 0) {
      dialogueIndex++;
      dialogueCooldown = 15;
      mouseClick = false;
    }
  } else {
    if (dialogueCallback) dialogueCallback();
  }

  mouseClick = false;
}

// ==========================================
// LEVEL BACKGROUND
// ==========================================
function drawLevelBg() {
  const lvl = levels[currentLevel];
  ctx.fillStyle = lvl.bgColor;
  ctx.fillRect(0, 0, W, H);

  switch(currentLevel) {
    case 0: drawBgViaPlava(); break;
    case 1: drawBgDownUnder(); break;
    case 2: drawBgPiazzaBainsizza(); break;
    case 3: drawBgPizzeria(); break;
    case 4: drawBgPiazzaMazzini(); break;
  }

  // Street sign (always) — below player info panel
  drawRect(8, 98, 195, 22, 'rgba(0,0,0,0.75)');
  drawRect(8, 98, 195, 2, '#fff');
  drawText(lvl.name.toUpperCase(), 105, 114, '#fff', 11, 'center');

  // Ground
  drawRect(0, GROUND_Y, W, H - GROUND_Y, lvl.groundColor);
  drawRect(0, GROUND_Y, W, 3, shadeColor(lvl.groundColor, 30));
}

// Via Plava - residential Roman street with palazzi
function drawBgViaPlava() {
  // Sky gradient - deep evening
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#0d0d25');
  sky.addColorStop(1, '#1a1a38');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Roman palazzi - darker ochre/terracotta for contrast with characters
  const buildings = [
    { x: -20, w: 200, h: 260, color: '#7a6540' },
    { x: 190, w: 180, h: 240, color: '#856d48' },
    { x: 380, w: 160, h: 280, color: '#6e5838' },
    { x: 550, w: 200, h: 250, color: '#7a6540' },
    { x: 760, w: 180, h: 270, color: '#856d48' }
  ];
  buildings.forEach(b => {
    drawRect(b.x, GROUND_Y - b.h, b.w, b.h, b.color);
    drawRect(b.x, GROUND_Y - b.h, b.w, 6, shadeColor(b.color, -20));
    // Windows (simplified for performance — fewer, bigger)
    for (let row = 0; row < Math.min(3, Math.floor(b.h / 80)); row++) {
      for (let col = 0; col < Math.min(2, Math.floor(b.w / 70)); col++) {
        const wx = b.x + 20 + col * 70;
        const wy = GROUND_Y - b.h + 25 + row * 80;
        drawRect(wx, wy, 28, 36, '#1a1a2e');
        drawRect(wx - 3, wy, 3, 36, '#2e7d32');
        drawRect(wx + 28, wy, 3, 36, '#2e7d32');
        if ((row + col) % 2 === 0) {
          ctx.globalAlpha = 0.35;
          drawRect(wx + 2, wy + 2, 24, 32, '#fff9c4');
          ctx.globalAlpha = 1;
        }
      }
    }
  });
  // Laundry lines between buildings
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(180, GROUND_Y - 180);
  ctx.lineTo(390, GROUND_Y - 190);
  ctx.stroke();
  // Clothes
  const clothes = ['#e53935','#1e88e5','#fff','#ffb300'];
  for (let i = 0; i < 4; i++) {
    drawRect(200 + i * 45, GROUND_Y - 185 + Math.sin(gameTime*0.02+i)*3, 15, 20, clothes[i]);
  }
  // Street lamps
  [80, 500, 830].forEach(lx => {
    drawRect(lx, GROUND_Y - 100, 4, 100, '#424242');
    drawRect(lx - 8, GROUND_Y - 105, 20, 6, '#616161');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx * 0.1) * 0.1;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx + 2, GROUND_Y - 110, 16, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Parked Vespa
  drawRect(650, GROUND_Y - 30, 40, 20, '#1e88e5'); // body
  drawRect(645, GROUND_Y - 38, 12, 12, '#1565c0'); // handlebar
  drawRect(640, GROUND_Y - 12, 14, 12, '#424242'); // front wheel
  drawRect(680, GROUND_Y - 12, 14, 12, '#424242'); // back wheel
  drawRect(660, GROUND_Y - 42, 4, 8, '#90a4ae'); // mirror

  // Trash bins
  drawRect(42, GROUND_Y - 28, 18, 28, '#424242');
  drawRect(40, GROUND_Y - 30, 22, 4, '#616161');

  // Stray cat (small pixel silhouette, subtle animation)
  const catX = 280, catY = GROUND_Y - 10;
  const catBob = Math.sin(gameTime * 0.02) * 1;
  drawRect(catX, catY + catBob - 8, 12, 8, '#333'); // body
  drawRect(catX + 10, catY + catBob - 12, 6, 6, '#333'); // head
  drawRect(catX + 10, catY + catBob - 15, 2, 4, '#333'); // ear
  drawRect(catX + 14, catY + catBob - 15, 2, 4, '#333'); // ear
  drawRect(catX - 4, catY + catBob - 6, 6, 2, '#333'); // tail
  ctx.globalAlpha = 0.8;
  drawRect(catX + 12, catY + catBob - 10, 2, 2, '#76ff03'); // eye
  ctx.globalAlpha = 1;

  // Cobblestone hint on ground
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = 0.15;
    drawRect(i * 32, GROUND_Y + 5, 28, 12, '#5d4037');
    ctx.globalAlpha = 1;
  }
}

// Down Under Pub - interior
function drawBgDownUnder() {
  // Dark pub interior
  ctx.fillStyle = '#1b1b2b';
  ctx.fillRect(0, 0, W, GROUND_Y);
  // Brick wall (reduced density for performance)
  ctx.globalAlpha = 0.15;
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 10; col++) {
      const offset = row % 2 === 0 ? 0 : 50;
      drawRect(col * 100 + offset, row * 42 + 30, 92, 36, '#8d6e63');
    }
  }
  ctx.globalAlpha = 1;
  // Bar counter
  drawRect(0, GROUND_Y - 90, W, 10, '#4e342e');
  drawRect(0, GROUND_Y - 80, W, 80, '#3e2723');
  // Beer taps
  for (let i = 0; i < 5; i++) {
    drawRect(80 + i * 180, GROUND_Y - 120, 8, 35, '#ffd54f');
    drawRect(75 + i * 180, GROUND_Y - 125, 18, 8, '#ffc107');
  }
  // Bottles on shelf
  drawRect(0, GROUND_Y - 160, W, 6, '#5d4037');
  const bottleColors = ['#4caf50','#f44336','#2196f3','#ff9800','#4caf50','#9c27b0','#f44336','#ffeb3b','#4caf50','#2196f3','#ff9800','#9c27b0'];
  bottleColors.forEach((c, i) => {
    drawRect(30 + i * 72, GROUND_Y - 190, 10, 30, c);
    drawRect(28 + i * 72, GROUND_Y - 192, 14, 4, c);
  });
  // Neon signs
  const glow = 0.5 + Math.sin(gameTime * 0.03) * 0.3;
  ctx.globalAlpha = glow;
  drawText('DOWN UNDER', W/2, 80, '#00e5ff', 22, 'center');
  drawText('PUB', W/2, 105, '#ff1744', 18, 'center');
  ctx.globalAlpha = 1;
  // Dartboard
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(780, 160, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#d32f2f';
  ctx.beginPath();
  ctx.arc(780, 160, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(780, 160, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#d32f2f';
  ctx.beginPath();
  ctx.arc(780, 160, 4, 0, Math.PI * 2);
  ctx.fill();
  // Hanging pendant lights
  [150, 350, 550, 750].forEach(lx => {
    drawRect(lx, 0, 1, 45, '#555');
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.025 + lx * 0.1) * 0.08;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx, 50, 18, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    drawRect(lx - 6, 44, 12, 8, '#ff8f00');
  });

  // Band posters on wall
  drawRect(30, 130, 50, 65, '#1a237e');
  drawText('LIVE', 55, 155, '#f44336', 8, 'center');
  drawText('MUSIC', 55, 168, '#fff', 7, 'center');
  drawRect(840, 140, 45, 55, '#b71c1c');
  drawText('PUB', 862, 160, '#fff', 7, 'center');
  drawText('QUIZ', 862, 175, '#ffd700', 7, 'center');

  // Pool table (background, behind counter)
  drawRect(300, GROUND_Y - 140, 100, 55, '#1b5e20');
  drawRect(296, GROUND_Y - 144, 108, 4, '#5d4037');
  drawRect(296, GROUND_Y - 89, 108, 4, '#5d4037');
  drawRect(296, GROUND_Y - 140, 4, 55, '#5d4037');
  drawRect(400, GROUND_Y - 140, 4, 55, '#5d4037');
  // Pool balls
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(330, GROUND_Y - 115, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#f44336'; ctx.beginPath(); ctx.arc(350, GROUND_Y - 120, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(365, GROUND_Y - 110, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1565c0'; ctx.beginPath(); ctx.arc(380, GROUND_Y - 118, 3, 0, Math.PI * 2); ctx.fill();

  // Stools
  for (let i = 0; i < 6; i++) {
    drawRect(60 + i * 140, GROUND_Y - 10, 30, 10, '#5d4037');
    drawRect(72 + i * 140, GROUND_Y, 6, 20, '#795548');
  }

  // Spilled drink stain (subtle)
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = '#795548';
  ctx.beginPath(); ctx.arc(420, GROUND_Y + 20, 15, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Wooden floor
  for (let i = 0; i < 12; i++) {
    ctx.globalAlpha = 0.1;
    drawRect(i * 80, GROUND_Y + 3, 76, H - GROUND_Y, '#8d6e63');
    ctx.globalAlpha = 1;
  }
}

// Piazza Bainsizza - open piazza with fountain
function drawBgPiazzaBainsizza() {
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#1a2030');
  sky.addColorStop(1, '#263248');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Stars
  for (let i = 0; i < 20; i++) {
    const sx = (i * 97) % W;
    const sy = (i * 41) % 120 + 10;
    ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.02 + i) * 0.2;
    drawRect(sx, sy, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Surrounding buildings - typical Roman
  const bColors = ['#c9a96e','#bfa47a','#d4a76a','#c9a96e'];
  [{ x: -10, w: 200 },{ x: 200, w: 150 },{ x: 600, w: 180 },{ x: 790, w: 150 }].forEach((b, i) => {
    const bh = 180 + (i * 30);
    drawRect(b.x, GROUND_Y - bh, b.w, bh, bColors[i]);
    for (let r = 0; r < 4; r++) for (let c = 0; c < 3; c++) {
      drawRect(b.x + 15 + c * 50, GROUND_Y - bh + 20 + r * 45, 22, 30, '#2a2a3e');
    }
  });

  // Fountain in center background
  drawRect(390, GROUND_Y - 60, 120, 60, '#78909c');
  drawRect(380, GROUND_Y - 30, 140, 8, '#90a4ae');
  drawRect(430, GROUND_Y - 100, 40, 45, '#90a4ae');
  // Water
  ctx.globalAlpha = 0.4;
  const waterY = Math.sin(gameTime * 0.05) * 2;
  drawRect(395, GROUND_Y - 25 + waterY, 110, 20, '#42a5f5');
  ctx.globalAlpha = 1;
  // Water spout
  if (gameTime % 10 < 7) {
    drawRect(448, GROUND_Y - 110, 4, 12, '#64b5f6');
  }

  // Trees
  [120, 350, 560, 780].forEach(tx => {
    drawRect(tx + 8, GROUND_Y - 50, 8, 50, '#5d4037');
    ctx.fillStyle = '#2e7d32';
    ctx.beginPath();
    ctx.arc(tx + 12, GROUND_Y - 65, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#388e3c';
    ctx.beginPath();
    ctx.arc(tx + 8, GROUND_Y - 55, 18, 0, Math.PI * 2);
    ctx.fill();
  });

  // Street lamps with warm glow
  [60, 280, 620, 850].forEach(lx => {
    drawRect(lx, GROUND_Y - 90, 4, 90, '#37474f');
    drawRect(lx - 6, GROUND_Y - 94, 16, 5, '#455a64');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx * 0.05) * 0.1;
    ctx.fillStyle = '#ffe0b2';
    ctx.beginPath(); ctx.arc(lx + 2, GROUND_Y - 98, 14, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Benches
  [200, 680].forEach(bx => {
    drawRect(bx, GROUND_Y - 20, 50, 6, '#5d4037'); // seat
    drawRect(bx + 2, GROUND_Y - 14, 4, 14, '#4e342e'); // leg
    drawRect(bx + 44, GROUND_Y - 14, 4, 14, '#4e342e'); // leg
    drawRect(bx, GROUND_Y - 32, 50, 4, '#5d4037'); // backrest
    drawRect(bx, GROUND_Y - 32, 2, 16, '#4e342e'); // back support
    drawRect(bx + 48, GROUND_Y - 32, 2, 16, '#4e342e');
  });

  // Pigeons (small pixel birds, subtle movement)
  [{ x: 150, d: 0 }, { x: 170, d: 1.5 }, { x: 500, d: 3 }, { x: 520, d: 4.5 }].forEach(p => {
    const bob = Math.sin(gameTime * 0.04 + p.d) * 1.5;
    const px = p.x + Math.sin(gameTime * 0.01 + p.d) * 3;
    drawRect(px, GROUND_Y - 6 + bob, 8, 5, '#78909c'); // body
    drawRect(px + 6, GROUND_Y - 9 + bob, 4, 4, '#90a4ae'); // head
    drawRect(px + 9, GROUND_Y - 8 + bob, 3, 1, '#ff8f00'); // beak
  });

  // Moon
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = '#e0e0e0';
  ctx.beginPath(); ctx.arc(780, 40, 18, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#263248';
  ctx.beginPath(); ctx.arc(786, 36, 16, 0, Math.PI * 2); ctx.fill(); // crescent shadow
  ctx.globalAlpha = 1;

  // Cobblestone piazza
  for (let i = 0; i < 40; i++) {
    ctx.globalAlpha = 0.12;
    const cx = (i * 47) % W;
    const cy = GROUND_Y + 5 + (i * 13) % 40;
    drawRect(cx, cy, 20, 10, '#607d8b');
    ctx.globalAlpha = 1;
  }
}

// Pizzarium - pizzeria exterior/interior
function drawBgPizzeria() {
  ctx.fillStyle = '#3e2723';
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Pizzeria building
  drawRect(0, 50, W, GROUND_Y - 50, '#5d4037');
  // Awning - Italian flag colors
  drawRect(0, 50, W, 15, '#009246');
  drawRect(0, 65, W, 15, '#fff');
  drawRect(0, 80, W, 15, '#ce2b37');

  // Sign
  drawRect(300, 100, 300, 40, '#b71c1c');
  drawText('PIZZARIUM', W/2, 126, '#ffd54f', 18, 'center');

  // Pizza oven in background
  drawRect(620, GROUND_Y - 150, 140, 150, '#4e342e');
  ctx.fillStyle = '#ff6f00';
  ctx.beginPath();
  ctx.arc(690, GROUND_Y - 100, 50, Math.PI, 0);
  ctx.fill();
  // Fire glow inside oven
  ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.1) * 0.3;
  ctx.fillStyle = '#ff3d00';
  ctx.beginPath();
  ctx.arc(690, GROUND_Y - 90, 35, Math.PI, 0);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Counter with pizzas
  drawRect(50, GROUND_Y - 60, 500, 12, '#795548');
  drawRect(50, GROUND_Y - 48, 500, 48, '#5d4037');
  // Pizza display (simplified — rects instead of arcs)
  for (let i = 0; i < 4; i++) {
    drawRect(100 + i * 120, GROUND_Y - 88, 40, 40, '#ffd54f');
    drawRect(108 + i * 120, GROUND_Y - 80, 6, 6, '#f44336');
    drawRect(120 + i * 120, GROUND_Y - 76, 6, 6, '#f44336');
    drawRect(114 + i * 120, GROUND_Y - 68, 6, 6, '#f44336');
  }

  // Checkered floor (reduced)
  ctx.globalAlpha = 0.15;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 10; c++) {
      drawRect(c * 100, GROUND_Y + r * 40, 50, 40, (r + c) % 2 === 0 ? '#fff' : '#d32f2f');
    }
  }
  ctx.globalAlpha = 1;

  // Menu board
  drawRect(30, 120, 120, 160, '#212121');
  drawText('MENU', 90, 145, '#fff', 12, 'center');
  drawText('Margherita  5E', 90, 165, '#ffd54f', 8, 'center');
  drawText('Diavola     7E', 90, 180, '#ffd54f', 8, 'center');
  drawText('Capricciosa 8E', 90, 195, '#ffd54f', 8, 'center');
  drawText('Pugni  GRATIS', 90, 215, '#f44336', 8, 'center');

  // Hanging garlic braids
  [200, 350, 500].forEach(gx => {
    drawRect(gx, 94, 2, 18, '#8d6e63');
    for (let g = 0; g < 3; g++) {
      ctx.fillStyle = '#f5f5dc';
      ctx.beginPath(); ctx.arc(gx + 1, 115 + g * 10, 5, 0, Math.PI * 2); ctx.fill();
    }
  });

  // Steam from oven (animated particles rising)
  for (let s = 0; s < 4; s++) {
    const sx = 675 + Math.sin(gameTime * 0.03 + s * 1.5) * 20;
    const sy = GROUND_Y - 155 - (gameTime * 0.5 + s * 30) % 60;
    ctx.globalAlpha = 0.08 + (1 - ((gameTime * 0.5 + s * 30) % 60) / 60) * 0.1;
    ctx.fillStyle = '#bdbdbd';
    ctx.beginPath(); ctx.arc(sx, sy, 8 + s * 2, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Hanging pepper lights (red string lights along awning)
  for (let i = 0; i < 15; i++) {
    const lx = 30 + i * 60;
    const bob = Math.sin(gameTime * 0.02 + i * 0.8) * 1;
    ctx.fillStyle = i % 3 === 0 ? '#f44336' : i % 3 === 1 ? '#4caf50' : '#fff';
    ctx.globalAlpha = 0.5;
    ctx.beginPath(); ctx.arc(lx, 96 + bob, 3, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Piazza Mazzini - the famous piazza with central garden
function drawBgPiazzaMazzini() {
  // Dark ominous sky for final boss
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#0a0a15');
  sky.addColorStop(0.5, '#111128');
  sky.addColorStop(1, '#1a1a30');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Lightning flashes
  if (Math.random() < 0.005) {
    screenFlash = 3;
    flashColor = '#b0bec5';
  }

  // Surrounding elegant buildings - Piazza Mazzini has grand architecture
  const palazzi = [
    { x: -20, w: 220, h: 300, color: '#4a4a58' },
    { x: 210, w: 180, h: 280, color: '#3d3d4d' },
    { x: 520, w: 200, h: 310, color: '#4a4a58' },
    { x: 730, w: 200, h: 290, color: '#3d3d4d' }
  ];
  palazzi.forEach(p => {
    drawRect(p.x, GROUND_Y - p.h, p.w, p.h, p.color);
    // Windows (simplified — no arches for performance)
    for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
      const wx = p.x + 20 + c * 80;
      const wy = GROUND_Y - p.h + 30 + r * 80;
      drawRect(wx, wy, 30, 38, '#111');
      ctx.globalAlpha = 0.2;
      drawRect(wx + 2, wy + 5, 26, 30, '#b0bec5');
      ctx.globalAlpha = 1;
    }
  });

  // Central garden area (Piazza Mazzini's garden)
  drawRect(350, GROUND_Y - 35, 200, 35, '#1b5e20');
  ctx.globalAlpha = 0.4;
  drawRect(360, GROUND_Y - 30, 180, 25, '#2e7d32');
  ctx.globalAlpha = 1;
  // Trees in garden
  [380, 430, 480, 530].forEach(tx => {
    drawRect(tx + 3, GROUND_Y - 55, 6, 25, '#3e2723');
    ctx.fillStyle = '#1b5e20';
    ctx.beginPath();
    ctx.arc(tx + 6, GROUND_Y - 60, 18, 0, Math.PI * 2);
    ctx.fill();
  });

  // Street lamps - eerie glow
  [100, 400, 700].forEach(lx => {
    drawRect(lx, GROUND_Y - 120, 4, 120, '#424242');
    drawRect(lx - 8, GROUND_Y - 125, 20, 6, '#424242');
    ctx.globalAlpha = 0.25 + Math.sin(gameTime * 0.04 + lx) * 0.15;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath();
    ctx.arc(lx + 2, GROUND_Y - 130, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Statue in center (monument)
  drawRect(440, GROUND_Y - 80, 20, 50, '#546e7a'); // pedestal pillar
  drawRect(430, GROUND_Y - 85, 40, 8, '#607d8b'); // pedestal top
  drawRect(425, GROUND_Y - 30, 50, 10, '#607d8b'); // pedestal base
  // Figure silhouette
  drawRect(442, GROUND_Y - 115, 16, 32, '#455a64');
  drawRect(438, GROUND_Y - 105, 8, 18, '#455a64'); // arm
  drawRect(454, GROUND_Y - 100, 8, 14, '#455a64'); // arm
  drawRect(446, GROUND_Y - 122, 10, 10, '#546e7a'); // head

  // Rain effect (lightweight — rects instead of strokes)
  for (let i = 0; i < 18; i++) {
    const rx = (i * 97 + gameTime * 3) % W;
    const ry = (i * 53 + gameTime * 6) % GROUND_Y;
    ctx.globalAlpha = 0.12;
    drawRect(rx, ry, 1, 10, '#7986cb');
  }
  ctx.globalAlpha = 1;

  // Puddle reflections (flat rects on ground, drawn behind everything)
  [150, 350, 600, 800].forEach(px => {
    ctx.globalAlpha = 0.06;
    drawRect(px - 22, GROUND_Y + 12, 44, 6, '#7986cb');
    ctx.globalAlpha = 1;
  });

  // Fog at ground level (denser)
  for (let i = 0; i < 10; i++) {
    ctx.globalAlpha = 0.06 + Math.sin(gameTime * 0.02 + i) * 0.03;
    const fx = (i * 110 + gameTime * 0.3) % (W + 100) - 50;
    const fw = 80 + (i % 3) * 40;
    drawRect(fx, GROUND_Y - 15, fw, 25, '#b0bec5');
    ctx.globalAlpha = 1;
  }
}

function shadeColor(color, amt) {
  let col = color.replace('#', '');
  if (col.length === 3) col = col[0]+col[0]+col[1]+col[1]+col[2]+col[2];
  const num = parseInt(col, 16);
  let r = Math.min(255, ((num >> 16) & 0xff) + amt);
  let g = Math.min(255, ((num >> 8) & 0xff) + amt);
  let b = Math.min(255, (num & 0xff) + amt);
  return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
}

// ==========================================
// MAIN LEVEL GAMEPLAY
// ==========================================
let bossIntro = false;
let bossIntroTimer = 0;

function updateLevel() {
  if (player.dead) {
    // Game over after a delay
    if (player.invincible < -60) {
      if (difficulty !== 'easy') lives--;
      state = 'gameover';
    }
    player.invincible--;
    updateParticles();
    return;
  }

  levelTimer++;

  // Player input
  updatePlayerInput();

  // Update enemies
  updateGoons();

  // Wave spawning system
  const goonsAlive = goons.length; // already filtered in updateGoons

  // Wave breather countdown
  if (waveBreatherTimer > 0) {
    waveBreatherTimer--;
    if (waveBreatherTimer === 0) {
      // Spawn next wave
      spawnGoons(waveConfig[currentWave] || 2);
      currentWave++;
      showQuickText('WAVE ' + currentWave + '/' + waveConfig.length, '#ff9800');
    }
  }

  // Check if current wave's goons are dead
  if (goonsAlive === 0 && boss && !bossIntro && waveClearTimer === 0 && waveBreatherTimer === 0 && levelTimer > 60) {
    if (currentWave < waveConfig.length) {
      // More waves to go - breather then next wave
      waveBreatherTimer = 120; // 2 seconds
      showQuickText('WAVE CLEAR!', '#4caf50');
      playSFX('coin');
    } else {
      // All waves cleared → bring boss
      waveClearTimer = 90;
      showQuickText('ALL WAVES CLEAR!', '#4caf50');
      playSFX('coin');
    }
  }
  if (waveClearTimer > 0) {
    waveClearTimer--;
    if (waveClearTimer === 0) {
      bossIntro = true;
      // Progressive intro duration: more hype for later bosses
      bossIntroTimer = [120, 150, 180, 200, 240][currentLevel] || 150;
      // Safety: reset boss HP to full when intro starts
      if (boss) { boss.hp = boss.maxHp; boss.poise = boss.maxPoise; }
    }
  }

  // Boss intro walk-in — unique cinematic per boss
  if (bossIntro && bossIntroTimer > 0) {
    const introMax = [120, 150, 180, 200, 240][currentLevel] || 150;
    const introProgress = 1 - (bossIntroTimer / introMax); // 0 → 1
    bossIntroTimer--;

    // === Per-boss walk-in behavior ===
    if (currentLevel === 0) {
      // LaFed: cocky swagger walk, bouncing rhythm
      boss.x += (650 - boss.x) * 0.05;
      if (gameTime % 12 < 6) boss.y = 430 - 3; else boss.y = 430; // swagger bounce
      if (gameTime % 8 === 0) spawnParticles(boss.x, boss.y, '#ffd54f', 1, 1); // gold sparkles
    } else if (currentLevel === 1) {
      // Gioacchino: heavy stomps, screen darkens
      boss.x += (650 - boss.x) * 0.03; // slow menacing approach
      if (gameTime % 20 === 0) { screenShake = 6; spawnParticles(boss.x, boss.y, '#795548', 4, 3); playSFX('stomp'); }
    } else if (currentLevel === 2) {
      // Dale: acrobatic entrance — flips in fast
      if (introProgress < 0.5) {
        boss.x += (650 - boss.x) * 0.08; // fast approach
        if (gameTime % 6 === 0) boss.y = 430 - 40; else boss.y = 430; // flip animation
        if (gameTime % 4 === 0) spawnParticles(boss.x, boss.y - 20, '#90a4ae', 3, 3);
      } else {
        boss.x += (650 - boss.x) * 0.03;
        if (gameTime % 10 === 0) spawnParticles(boss.x, boss.y, '#90a4ae', 2, 2);
      }
      if (Math.random() < 0.08) screenShake = Math.max(screenShake, 4);
    } else if (currentLevel === 3) {
      // Ciccio: ground-shaking heavy walk, fire particles, forno glow
      boss.x += (650 - boss.x) * 0.025;
      if (gameTime % 15 === 0) { screenShake = 8; playSFX('stomp'); }
      if (gameTime % 4 === 0) spawnParticles(boss.x, boss.y - 20, '#ff6f00', 2 + Math.floor(introProgress * 4), 3);
      if (gameTime % 3 === 0) spawnParticles(boss.x + (Math.random()-0.5)*30, boss.y - 40, '#f44336', 1, 2); // fire
      if (Math.random() < 0.05) { screenFlash = 2; flashColor = '#ff6f00'; }
    } else if (currentLevel === 4) {
      // Pisellino: full cinematic — darkness, lightning, manic energy
      boss.x += (650 - boss.x) * 0.04;
      if (Math.random() < 0.04) { screenFlash = 3; flashColor = '#e94560'; }
      if (Math.random() < 0.15) screenShake = Math.max(screenShake, 3 + Math.floor(introProgress * 8));
      if (gameTime % 5 === 0) spawnParticles(boss.x, boss.y, '#b0bec5', 2 + Math.floor(introProgress * 5), 3);
      if (introProgress > 0.7 && gameTime % 3 === 0) spawnParticles(boss.x, boss.y - 40, '#e94560', 3, 4); // red sparks
    }

    // === Per-boss text sequences ===
    if (bossIntroTimer === Math.floor(introMax * 0.7)) {
      const preQuotes = [
        '"Ao\', chi e\' sto tipo che se crede figo?"',
        '"Attento Conte... senti quei passi pesanti..."',
        '"Sta arrivando... si muove come un\'ombra!"',
        '"L\'aria puzza di pizza bruciata... e di guai!"',
        '"Lo senti? Er boss dei boss... Pisellino!"'
      ];
      showQuickText(preQuotes[currentLevel], '#ff8a80');
    }

    // Boss name + subtitle at 40%
    if (bossIntroTimer === Math.floor(introMax * 0.4)) {
      const lvl = levels[currentLevel];
      const shakeAmounts = [8, 12, 14, 18, 22];
      screenShake = shakeAmounts[currentLevel];
      playSFX('boss_appear');
      spawnParticles(boss.x, boss.y - boss.h / 2, lvl.bossColor || '#e94560', 15 + currentLevel * 5, 6);
      // Boss-specific dramatic SFX
      if (currentLevel === 1) playSFX('stomp'); // extra stomp for Gioacchino
      if (currentLevel === 3) { screenFlash = 4; flashColor = '#ff6f00'; } // fire flash for Ciccio
    }

    // Boss-specific taunt near end
    if (bossIntroTimer === 25) {
      const introTaunts = [
        '"Yo! So\' LaFed e sto per placcatte!"',
        '"In gabbia sognavo sto momento..."',
        '"DALE! Nessuno batte er Dale!"',
        '"ER FORNO E\' APERTO! Preparate a brucia\'!"',
        '"Sup bro... ready to get DESTROYED?"'
      ];
      showQuickText(introTaunts[currentLevel], levels[currentLevel].bossColor || '#e94560');
    }

    // Final dramatic moment on arrival
    if (bossIntroTimer === 1) {
      const finalShake = [10, 14, 16, 22, 26];
      screenShake = finalShake[currentLevel];
      if (currentLevel >= 2) { screenFlash = 6; flashColor = levels[currentLevel].bossColor || '#e94560'; }
      // Boss-specific arrival effect
      if (currentLevel === 0) spawnParticles(boss.x, boss.y - 30, '#ffd54f', 20, 6); // gold explosion
      if (currentLevel === 1) { spawnParticles(boss.x, boss.y, '#795548', 25, 7); playSFX('stomp'); } // heavy landing
      if (currentLevel === 2) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 20, 8); // wind burst
      if (currentLevel === 3) { spawnParticles(boss.x, boss.y - 30, '#ff6f00', 30, 8); spawnParticles(boss.x, boss.y, '#f44336', 20, 6); } // fire explosion
      if (currentLevel === 4) { spawnParticles(boss.x, boss.y - 30, '#e94560', 30, 8); spawnParticles(boss.x, boss.y - 50, '#b0bec5', 20, 6); } // chaos burst
      boss.y = 430; // ensure grounded
    }
  }

  // Boss AI runs after intro completes
  if (bossIntro && bossIntroTimer <= 0) {
    updateBossAI();
  }

  // Check boss death
  if (boss && boss.hp <= 0 && !boss.dead) {
    boss.dead = true;
    bossDefeated[currentLevel] = true;
    if (difficulty === 'medium') lives = 3; // medium: lives reset per boss
    // Boss coin drops (physical pickups) — first clear gives big bonus
    const bossCoins = isReplayLevel ? 15 + currentLevel * 10 : 50 + currentLevel * 35;
    spawnCoinPickup(boss.x, boss.y - 30, bossCoins);
    // Level clear bonus
    const clearBonus = isReplayLevel ? 5 : 15 + currentLevel * 8;
    spawnCoinPickup(boss.x, boss.y - 40, clearBonus);
    screenShake = 25;
    screenFlash = 20;
    flashColor = '#ffd700';
    spawnParticles(boss.x, boss.y - 30, '#ffd700', 40, 8);
    playSFX('victory_jingle');

    // Victory dialogue
    const totalBossCoins = bossCoins + clearBonus;
    dialogueLines = [
      levels[currentLevel].boss.toUpperCase() + ' SCONFITTO!',
      ...levels[currentLevel].defeatLines,
      'Il Conte conquista ' + levels[currentLevel].name + '!',
      '+' + totalBossCoins + ' COINS' + (isReplayLevel ? ' (replay)' : ' (prima vittoria!)')
    ];
    dialogueIndex = 0;
    dialogueCallback = () => {
      bossIntro = false;
      // If all bosses defeated, go straight to credits
      if (bossDefeated.every(b => b)) {
        victoryTimer = 0;
        state = 'victory';
      } else {
        // Calculate grade and show upgrade selection
        calculateLevelGrade();
        generateUpgradeChoices();
        state = 'upgrade';
      }
    };
    state = 'dialogue';
  }

  // Update systems
  updateProjectiles();
  checkBulletHits();
  updateParticles();
  updateCoinPickups();
  updateHazards();

  // Passive ultra charge trickle in combat
  if (!player.ultraActive && !player.ultraAvailable && goons.some(g => !g.dead)) {
    player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 0.06);
    if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
  }

  // Update helper cooldowns
  for (let i = 0; i < 4; i++) {
    helperCooldowns[i] = Math.max(0, helperCooldowns[i] - 1);
  }

  // Update helper visuals
  updateHelperVisuals();

  // Exhaustion timer
  if (player.exhaustedTimer > 0) player.exhaustedTimer--;
  // Reload timer for ranged weapons
  if (player.reloadTimer > 0) {
    player.reloadTimer--;
    if (player.reloadTimer <= 0) {
      const weap = weapons[player.weapon];
      if (weap.maxAmmo) {
        weap.currentAmmo = weap.maxAmmo;
        showQuickText('RICARICATO!', '#a1887f');
        playSFX('coin');
      }
    }
  }
  // Consumable timers
  if (player.consumableTimers.freeStamina > 0) player.consumableTimers.freeStamina--;
  if (player.consumableTimers.dmgBoost > 0) player.consumableTimers.dmgBoost--;
  // Stamina regen
  if (player.staminaRegenDelay > 0) {
    player.staminaRegenDelay--;
  } else if (player.stamina < player.maxStamina) {
    const stRegenRate = player.upgrades.some(u => u.effect === 'stregen') ? 0.7 : 0.5;
    player.stamina = Math.min(player.maxStamina, player.stamina + stRegenRate);
  }

  // Same-target penalty timeout: resets after 60 frames without hitting same target
  if (player.sameTargetHits > 0) {
    player.sameTargetTimer++;
    if (player.sameTargetTimer > 60) {
      player.sameTargetHits = 0;
      player.lastHitTarget = null;
      player.sameTargetTimer = 0;
    }
  }

  // Combo hit counter decay
  if (player.comboHitCount > 0) {
    player.comboHitTimer++;
    if (player.comboHitTimer > 90) {
      player.comboHitCount = 0;
      player.comboHitTimer = 0;
      player.scoreMultiplier = 1;
    }
  }

  // War cry timer (Tommy tier 3)
  if (warCryTimer > 0) warCryTimer--;
  if (warCryCooldown > 0) warCryCooldown--;
  // Tommy tier 3 auto-trigger
  if (helpers[1].tier >= 3 && warCryCooldown <= 0 && warCryTimer <= 0) {
    warCryTimer = 240;
    warCryCooldown = 1800; // 30 seconds
    showQuickText('WAR CRY! +30% DMG!', '#ff6e40');
  }

  // Ultra timer countdown
  if (player.ultraActive) {
    player.ultraTimer--;
    // Gold particle trail while Ultra active
    if (gameTime % 3 === 0) spawnParticles(player.x + (Math.random() - 0.5) * 20, player.y - Math.random() * player.h, '#ffd700', 2, 2);
    if (player.ultraTimer <= 0) {
      player.ultraActive = false;
      player.ultraTimer = 0;
      showQuickText('ULTRA FINITO', '#ff8f00');
    }
  }

  // Speed boost timer
  if (player.speedBoost > 0) player.speedBoost--;

  // Dodge counter timer
  if (dodgeCounter > 0) dodgeCounter--;
  // Phase transition timer
  if (phaseTransitionTimer > 0) phaseTransitionTimer--;
}

const GROUND_Y = 430;
const GRAVITY = 0.55;
const FALL_GRAVITY = 0.75;
const JUMP_FORCE = -13.0;

function updatePlayerInput() {
  if (player.stunTimer > 0) { player.stunTimer--; return; }

  const baseSpeed = (player.speed + (player.speedBoost > 0 ? 2.5 : 0)) * (player.ultraActive ? 1.1 : 1);
  const hazardMult = player.hazardSlow ? 0.7 : 1;
  const speed = (player.endLagTimer > 0 ? baseSpeed * 0.5 : baseSpeed) * hazardMult;

  // Movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    player.x -= speed;
    player.facing = -1;
    player.animTimer++;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    player.x += speed;
    player.facing = 1;
    player.animTimer++;
  }

  // Jump (blocked during end-lag)
  if ((keys['ArrowUp'] || keys['KeyW']) && player.grounded && player.endLagTimer <= 0) {
    player.vy = JUMP_FORCES[jumpTier];
    player.grounded = false;
  }

  // Variable jump height: releasing jump early cuts upward velocity (short hop vs full jump)
  if (!player.grounded && player.vy < -4 && !(keys['ArrowUp'] || keys['KeyW'])) {
    player.vy = -4; // cap upward speed for short hop
  }

  // Apply variable gravity (lighter going up, heavier coming down)
  if (!player.grounded) {
    const grav = player.vy < 0 ? GRAVITY : FALL_GRAVITY;
    // Fast-fall: pressing Down while airborne adds extra gravity
    const fastFall = (keys['ArrowDown'] || keys['KeyS']) ? 0.4 : 0;
    player.vy += grav + fastFall;
    player.y += player.vy;
    if (player.y >= GROUND_Y) {
      player.y = GROUND_Y;
      player.vy = 0;
      player.grounded = true;
      // Jump attack: stun nearby enemies on landing
      const jumpTargets = goons.filter(g => !g.dead && Math.abs(g.x - player.x) < 55 && (!g.staggerTimer || g.staggerTimer <= 0));
      if (jumpTargets.length > 0) {
        jumpTargets.forEach(g => {
          g.stunTimer = 25;
          g.knockbackVx = Math.sign(g.x - player.x) * 4;
          spawnParticles(g.x, g.y - 20, '#64b5f6', 4);
        });
        spawnParticles(player.x, GROUND_Y, '#fff', 6, 3);
        screenShake = 4;
        playSFX('stomp');
      }
    }
  }

  // Dodge (blocked during end-lag)
  if ((keys['KeyX'] || keys['ShiftLeft']) && !player.dodging && player.dodgeCooldown <= 0 && player.endLagTimer <= 0 && !player.grabbing) {
    player.dodging = true;
    player.dodgeTimer = 12;
    player.dodgeCooldown = DODGE_COOLDOWNS[dodgeTier];
    player.vx = player.facing * 8;
    player.stamina = Math.max(0, player.stamina - 22);
    player.staminaRegenDelay = 30;
    spawnParticles(player.x, player.y - 20, '#64b5f6', 5);
    playSFX('dodge');
    // Perfect dodge: dodge while an enemy is winding up nearby
    const nearbyWindup = goons.some(g => !g.dead && g.windupTimer > 0 && Math.abs(g.x - player.x) < 90) ||
      (boss && !boss.dead && boss.chargeTimer > 0 && Math.abs(boss.x - player.x) < 100);
    if (nearbyWindup) {
      dodgeCounter = 90;
      showQuickText('PERFECT DODGE! Danno x1.5!', '#64b5f6');
      playSFX('perfect_dodge');
      screenFlash = 4;
      flashColor = '#64b5f6';
      // Style bonus: +2 coins for perfect dodge
      spawnCoinPickup(player.x, player.y - 30, 2);
    }
  }

  if (player.dodging) {
    player.x += player.vx;
    player.dodgeTimer--;
    player.vx *= 0.9;
    if (player.dodgeTimer <= 0) {
      player.dodging = false;
    }
  }

  player.dodgeCooldown = Math.max(0, player.dodgeCooldown - 1);

  // End-lag: player can move at 50% speed but can't attack/dodge/jump
  if (player.endLagTimer > 0) {
    player.endLagTimer--;
    if (player.endLagTimer <= 0) {
      player.comboStep = 0;
      player.attacking = false;
    }
    // Override movement to 50% speed during end-lag (already applied above via speed var)
  }

  // Grab update: if grabbing, handle grab actions
  if (player.grabbing && player.grabbedEnemy) {
    player.grabTimer--;
    const ge = player.grabbedEnemy;
    if (ge.dead || player.grabTimer <= 0) {
      player.grabbing = false;
      player.grabbedEnemy = null;
    } else {
      // Position grabbed enemy in front of player
      ge.x = player.x + player.facing * 30;
      ge.y = player.y;
      ge.stunTimer = 5; // keep stunned while grabbed

      // Grab actions
      if (keysJustPressed['KeyZ'] || keysJustPressed['Space']) {
        const holdUp = !isTouchDevice && (keys['ArrowUp'] || keys['KeyW']);
        if (holdUp) {
          // Slam: high single-target damage, ground bounce
          const slamDmg = weapons[player.weapon].damage * 2.5;
          ge.hp -= slamDmg;
          ge.knockbackVx = 0;
          ge.stunTimer = 0;
          ge.staggerTimer = 30;
          player.stamina = Math.max(0, player.stamina - 15);
          player.staminaRegenDelay = 30;
          spawnDamageNumber(ge.x, ge.y - (ge.h || 50), 'SLAM! ' + Math.floor(slamDmg), '#ff9800');
          spawnParticles(ge.x, ge.y, '#ff9800', 15, 6);
          screenShake = 12;
          playSFX('stomp');
          if (ge.hp <= 0 && !ge.isBoss) {
            ge.dead = true;
            totalKills++;
            spawnParticles(ge.x, ge.y - 25, '#ffd700', 12);
            spawnCoinPickup(ge.x, ge.y - 20, 12);
            playSFX('coin');
          }
        } else {
          // Throw: fling into others
          const throwDir = player.facing;
          ge.knockbackVx = throwDir * 14;
          ge.stunTimer = 0;
          ge.staggerTimer = 20;
          const throwDmg = weapons[player.weapon].damage * 1.5;
          ge.hp -= throwDmg;
          player.stamina = Math.max(0, player.stamina - 15);
          player.staminaRegenDelay = 30;
          spawnDamageNumber(ge.x, ge.y - (ge.h || 50), 'THROW! ' + Math.floor(throwDmg), '#64b5f6');
          // Damage enemies hit by thrown enemy
          const thrown = ge;
          goons.forEach(g => {
            if (g === thrown || g.dead) return;
            if (Math.abs(g.x - thrown.x) < 60 && Math.abs(g.y - thrown.y) < 40) {
              g.hp -= throwDmg * 0.7;
              g.knockbackVx = throwDir * 6;
              g.stunTimer = 20;
              spawnDamageNumber(g.x, g.y - (g.h || 50), Math.floor(throwDmg * 0.7), '#64b5f6');
              spawnParticles(g.x, g.y - 25, '#64b5f6', 6);
              if (g.hp <= 0 && !g.isBoss) {
                g.dead = true;
                totalKills++;
                spawnParticles(g.x, g.y - 25, '#ffd700', 12);
                spawnCoinPickup(g.x, g.y - 20, 10);
                playSFX('coin');
              }
            }
          });
          if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0 && Math.abs(boss.x - thrown.x) < 60) {
            boss.hp -= throwDmg * 0.5;
            spawnDamageNumber(boss.x, boss.y - boss.h, Math.floor(throwDmg * 0.5), '#64b5f6');
          }
          screenShake = 8;
          playSFX('hit');
          if (thrown.hp <= 0 && !thrown.isBoss) {
            thrown.dead = true;
            totalKills++;
            spawnParticles(thrown.x, thrown.y - 25, '#ffd700', 12);
            spawnCoinPickup(thrown.x, thrown.y - 20, 10);
            playSFX('coin');
          }
        }
        player.grabbing = false;
        player.grabbedEnemy = null;
        player.endLagTimer = 12;
      }

      // Reposition while grabbing (slow walk)
      if (keys['ArrowLeft'] || keys['KeyA']) { player.x -= 1.5; player.facing = -1; }
      if (keys['ArrowRight'] || keys['KeyD']) { player.x += 1.5; player.facing = 1; }
      player.x = Math.max(25, Math.min(W - 25, player.x));
      return; // Skip normal attack processing while grabbing
    }
  }

  // Ultra activation — Q key, only when fully charged
  if (keysJustPressed['KeyQ'] && player.ultraAvailable && !player.ultraActive) {
    player.ultraActive = true;
    player.ultraTimer = player.ultraDuration; // 300 frames = 5 seconds
    player.ultraCharge = 0;
    player.ultraAvailable = false;
    screenShake = 12;
    screenFlash = 8;
    flashColor = '#ffd700';
    spawnParticles(player.x, player.y - 30, '#ffd700', 25, 7);
    showQuickText('ULTRA!!!', '#ffd700');
    playSFX('stomp');
  }

  // Combo chain attack system — requires keysJustPressed (no hold-to-spam)
  if (keysJustPressed['KeyZ'] || keysJustPressed['Space']) {
    const holdUp = !isTouchDevice && (keys['ArrowUp'] || keys['KeyW']);

    if (!player.grounded) {
      playerJumpAttack();
    } else if (holdUp && player.endLagTimer <= 0 && player.comboStep === 0) {
      // Up + Attack = Overhead slam (keyboard only)
      playerOverhead();
    } else {
      // Check for grab: attack near staggered enemy
      let grabTarget = null;
      if (player.comboStep === 0 && player.endLagTimer <= 0) {
        const staggeredNearby = goons.filter(g => !g.dead && g.staggerTimer > 0 && Math.abs(g.x - player.x) < 50 && Math.abs(g.y - player.y) < 40);
        if (staggeredNearby.length > 0) grabTarget = staggeredNearby[0];
      }
      if (grabTarget && !grabTarget.isBoss) {
        player.grabbing = true;
        player.grabbedEnemy = grabTarget;
        player.grabTimer = 90;
        grabTarget.stunTimer = 95;
        showQuickText('GRAB!', '#64b5f6');
        playSFX('hit');
      } else {
        playerAttack();
      }
    }
  }

  // Manage active frames → combo window → end-lag transitions
  if (player.attackActiveTimer > 0) {
    player.attackActiveTimer--;
    player.attackTimer = player.attackActiveTimer;
    if (player.attackActiveTimer <= 0) {
      const weap = weapons[player.weapon];
      const maxHits = weap.comboHits;
      if (player.comboStep < maxHits) {
        // Enter combo window (tight timing rewards skill)
        player.comboWindowTimer = weap.comboWindow;
        // Check buffer
        if (player.attackBuffered) {
          player.attackBuffered = false;
          launchComboHit(player.comboStep);
        }
      } else {
        // Last hit complete → full end-lag (50% more if low stamina)
        const lagMult = player.stamina < 35 ? 1.5 : 1;
        player.endLagTimer = Math.floor(weap.endLag * lagMult);
        player.comboChainCount++;
        // Ultra charge bonus for completing full combo chain
        if (!player.ultraActive) {
          player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 14);
          if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
        }
        player.attacking = false;
      }
    }
  }

  // Combo window countdown
  if (player.comboWindowTimer > 0 && player.attackActiveTimer <= 0) {
    player.comboWindowTimer--;
    // Buffer check during window
    if (player.attackBuffered && player.comboStep < weapons[player.weapon].comboHits) {
      player.attackBuffered = false;
      launchComboHit(player.comboStep);
    }
    if (player.comboWindowTimer <= 0 && player.endLagTimer <= 0) {
      // Dropped combo → short end-lag
      player.endLagTimer = DROPPED_END_LAG;
      player.attacking = false;
    }
  }

  // Reset jump attack flag on landing
  if (player.grounded) player.jumpAttacking = false;

  // Invincibility
  if (player.invincible > 0) player.invincible--;

  // Bounds
  player.x = Math.max(25, Math.min(W - 25, player.x));

  // Helper keys
  if (keys['Digit1']) { activateHelper(0); keys['Digit1'] = false; }
  if (keys['Digit2']) { activateHelper(1); keys['Digit2'] = false; }
  if (keys['Digit3']) { activateHelper(2); keys['Digit3'] = false; }
  if (keys['Digit4']) { activateHelper(3); keys['Digit4'] = false; }
  // Consumable keys (5-7)
  if (keys['Digit5']) { useConsumable(0); keys['Digit5'] = false; }
  if (keys['Digit6']) { useConsumable(1); keys['Digit6'] = false; }
  if (keys['Digit7']) { useConsumable(2); keys['Digit7'] = false; }
}

function drawLevel() {
  // Moves screen (TAB/P) — handled in draw phase to avoid double-toggle
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP']) {
    toggleMovesScreen();
  }

  drawLevelBg();
  drawHazards();

  // Draw goons
  goons.forEach(g => drawGoon(g));

  // Draw boss
  if (boss && !boss.dead) drawBossChar(boss);

  // Draw Regina
  if (reginaActive) drawRegina(regina);

  // Draw Mariuso
  if (mariusoActive) drawMariuso(mariuso);

  // Draw player
  drawConte(player);

  // Draw coin pickups
  drawCoinPickups();

  // Draw projectiles
  drawProjectiles();

  // Draw helper characters
  drawHelperVisuals();

  // Draw particles
  drawParticles();

  // HUD
  drawHUD();

  // Quick text - positioned above helper bar
  if (quickTextTimer > 0) {
    const qtY = isTouchDevice ? H - 200 : H - 65;
    ctx.globalAlpha = Math.min(1, quickTextTimer / 20);
    drawRect(W/2 - 260, qtY, 520, 24, 'rgba(0,0,0,0.85)');
    drawRect(W/2 - 260, qtY, 520, 2, quickTextColor);
    drawText(quickText, W/2, qtY + 17, quickTextColor, 12, 'center');
    ctx.globalAlpha = 1;
    quickTextTimer--;
  }

  // Phase transition overlay
  if (phaseTransitionTimer > 0) {
    phaseTransitionTimer--;
    const alpha = Math.min(1, phaseTransitionTimer / 30);
    ctx.globalAlpha = alpha * 0.6;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = alpha;
    drawRect(W/2 - 250, H/2 - 30, 500, 50, 'rgba(0,0,0,0.9)');
    drawRect(W/2 - 250, H/2 - 30, 500, 3, phaseTransitionColor);
    drawText(phaseTransitionText, W/2, H/2, phaseTransitionColor, 16, 'center');
    ctx.globalAlpha = 1;
  }

  // Level intro splash
  if (levelTimer < 120) {
    const fadeIn = Math.min(1, levelTimer / 20);
    const fadeOut = Math.min(1, (120 - levelTimer) / 30);
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.5)');
    drawRect(W/2 - 200, H/2 - 90, 400, 80, 'rgba(0,0,0,0.9)');
    drawRect(W/2 - 200, H/2 - 90, 400, 3, '#e94560');
    drawText(levels[currentLevel].name.toUpperCase(), W/2, H/2 - 60, '#fff', 28, 'center');
    drawText('vs ' + levels[currentLevel].boss, W/2, H/2 - 30, '#e94560', 18, 'center');
    ctx.globalAlpha = 1;
  }

  // Boss intro cinematic overlay — progressive per level
  if (bossIntro && bossIntroTimer > 0) {
    const introMax = [120, 150, 180, 200, 240][currentLevel] || 150;
    const introProgress = 1 - (bossIntroTimer / introMax);
    // Dimming: more dramatic for later bosses
    const dimBase = 0.15 + currentLevel * 0.06; // 0.15 → 0.39
    const dimAlpha = dimBase * (1 - Math.abs(introProgress - 0.5) * 2); // peaks at midpoint
    ctx.globalAlpha = dimAlpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;

    // Boss name banner at 40%-80% of intro
    if (introProgress > 0.35 && introProgress < 0.85) {
      const lvl = levels[currentLevel];
      const bannerAlpha = Math.min(1, (introProgress - 0.35) * 5);
      ctx.globalAlpha = bannerAlpha;
      // Dark banner
      drawRect(W/2 - 200, H/2 - 50, 400, 70, 'rgba(0,0,0,0.85)');
      drawRect(W/2 - 200, H/2 - 50, 400, 3, lvl.bossColor || '#e94560');
      drawRect(W/2 - 200, H/2 + 17, 400, 3, lvl.bossColor || '#e94560');
      // Boss name (big)
      drawText(lvl.boss.toUpperCase(), W/2, H/2 - 20, lvl.bossColor || '#e94560', 24, 'center');
      // Subtitle
      drawText(lvl.subtitle || '', W/2, H/2 + 5, '#ccc', 11, 'center');
      ctx.globalAlpha = 1;
    }

    // Vignette effect for level 3+
    if (currentLevel >= 3) {
      const vigGrad = ctx.createRadialGradient(W/2, H/2, 100, W/2, H/2, 500);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);
    }
  }

  // Dead overlay
  if (player.dead) {
    ctx.fillStyle = 'rgba(20,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    drawRect(W/2 - 160, H/2 - 35, 320, 50, 'rgba(0,0,0,0.8)');
    drawRect(W/2 - 160, H/2 - 35, 320, 3, '#f44336');
    drawText('IL CONTE IS DOWN!', W/2, H/2, '#f44336', 24, 'center');
  }

  // Mobile touch buttons (drawn last = highest z-order)
  drawTouchButtons();
}

function drawHUD() {
  // === TOP LEFT: Player info panel ===
  drawRect(8, 8, 195, 62, 'rgba(0,0,0,0.7)');
  drawRect(8, 8, 195, 2, '#e94560');

  // HP bar — label left, bar right, value far right
  const hpW = 130;
  const barX = 38;
  const hpR = player.hp / player.maxHp;
  drawText('HP', 14, 24, '#fff', 8);
  drawRect(barX, 16, hpW, 9, '#333');
  drawRect(barX, 16, hpW * hpR, 9, hpR > 0.3 ? '#4caf50' : '#f44336');
  drawText(Math.floor(player.hp) + '/' + player.maxHp, barX + hpW + 2, 24, '#ccc', 7, 'left');

  // Stamina bar
  const stR = player.stamina / player.maxStamina;
  const exhausted = player.exhaustedTimer > 0;
  drawText('ST', 14, 34, exhausted ? '#f44336' : '#fdd835', 8);
  drawRect(barX, 28, hpW, 6, '#333');
  drawRect(barX, 28, hpW * stR, 6, exhausted ? '#f44336' : stR > 0.25 ? '#fdd835' : '#ff8f00');
  if (exhausted) {
    // Flash "!" after bar when exhausted
    const exFlash = Math.floor(gameTime / 10) % 2 === 0;
    if (exFlash) drawText('!', barX + hpW + 3, 34, '#f44336', 8);
  }

  // Weapon name row
  const curWeap = weapons[player.weapon];
  drawText(curWeap.name, 14, 45, '#ffcc80', 9);
  // Lives display — clear hearts at bottom of panel
  if (difficulty === 'easy') {
    drawRect(14, 50, 40, 18, 'rgba(0,0,0,0.5)');
    drawText('\u221E', 34, 64, '#4caf50', 14, 'center');
  } else {
    drawRect(14, 50, 60, 18, 'rgba(0,0,0,0.5)');
    for (let li = 0; li < 3; li++) {
      const alive = li < lives;
      drawRect(16 + li * 19, 52, 15, 14, alive ? '#e94560' : '#333');
      drawText(alive ? '\u2665' : '\u2661', 24 + li * 19, 64, alive ? '#fff' : '#555', 11, 'center');
    }
  }
  // Dodge & Jump indicators — right side of panel (desktop only, mobile uses touch buttons)
  if (!isTouchDevice) {
    if (player.dodgeCooldown > 0) {
      drawText('[X]' + Math.ceil(player.dodgeCooldown / 6) / 10 + 's', 130, 45, '#555', 7);
    } else {
      drawText('[X]OK', 130, 45, '#64b5f6', 7);
    }
    drawText('[W]' + (player.grounded ? 'OK' : '--'), 168, 45, player.grounded ? '#64b5f6' : '#555', 7);
  }

  // Ammo row (only for ranged weapons)
  if (curWeap.maxAmmo) {
    if (player.reloadTimer > 0) {
      const reloadFlash = Math.floor(gameTime / 8) % 2 === 0;
      drawText('RICARICA!', 14, 56, reloadFlash ? '#ff8f00' : '#ff5722', 8);
    } else {
      const ammo = curWeap.currentAmmo !== undefined ? curWeap.currentAmmo : curWeap.maxAmmo;
      drawText('AMMO: ' + ammo + '/' + curWeap.maxAmmo, 14, 56, ammo > 1 ? '#a1887f' : '#f44336', 8);
    }
  }

  // === ULTRA BAR — independent widget below player panel ===
  const ultraBarX = 8, ultraBarY = 84, ultraBarW = 195, ultraBarH = 14;
  drawRect(ultraBarX, ultraBarY, ultraBarW, ultraBarH, 'rgba(0,0,0,0.7)');
  const ultraR = player.ultraCharge / player.ultraMaxCharge;
  if (player.ultraActive) {
    const timerR = player.ultraTimer / player.ultraDuration;
    drawRect(ultraBarX + 1, ultraBarY + 1, (ultraBarW - 2) * timerR, ultraBarH - 2, '#fff');
    const ultraPulse = Math.sin(gameTime * 0.2) * 0.3 + 0.7;
    ctx.globalAlpha = ultraPulse;
    drawText('Q  ULTRA!', ultraBarX + ultraBarW / 2, ultraBarY + 11, '#ffd700', 10, 'center');
    ctx.globalAlpha = 1;
  } else if (player.ultraAvailable) {
    const ultraPulse = Math.sin(gameTime * 0.15) * 0.3 + 0.7;
    ctx.globalAlpha = ultraPulse;
    drawRect(ultraBarX + 1, ultraBarY + 1, ultraBarW - 2, ultraBarH - 2, '#ffd700');
    drawText('Q  PRONTO!', ultraBarX + ultraBarW / 2, ultraBarY + 11, '#1a1a2e', 10, 'center');
    ctx.globalAlpha = 1;
  } else {
    drawRect(ultraBarX + 1, ultraBarY + 1, (ultraBarW - 2) * ultraR, ultraBarH - 2, '#ff8f00');
    drawText('Q', ultraBarX + 6, ultraBarY + 11, '#ff8f00', 9);
  }

  // Active consumable buff indicators — below ultra bar
  let buffY = 104;
  if (player.consumableTimers.freeStamina > 0) {
    drawText('CAFFE\' ' + Math.ceil(player.consumableTimers.freeStamina / 60) + 's', 14, buffY, '#6d4c41', 8);
    buffY += 10;
  }
  if (player.consumableTimers.dmgBoost > 0) {
    drawText('+DMG ' + Math.ceil(player.consumableTimers.dmgBoost / 60) + 's', 14, buffY, '#ffcc80', 8);
  }

  // === TOP RIGHT: Coins ===
  drawRect(W - 110, 8, 102, 22, 'rgba(0,0,0,0.7)');
  drawText('COINS: ' + coins, W - 58, 24, '#ffd700', 12, 'center');

  // === Combo Chain Dots ===
  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;
  let rightY = 30; // tracks bottom of last drawn element in top-right column
  if (player.comboStep > 0 || player.endLagTimer > 0) {
    drawRect(W - 115, rightY + 4, 110, 22, 'rgba(0,0,0,0.6)');
    // Draw dots for each combo step
    const dotY = rightY + 15;
    for (let i = 0; i < maxHits; i++) {
      const dotX = W - 108 + i * 24;
      const filled = i < player.comboStep;
      const isActive = i === player.comboStep - 1 && player.attackActiveTimer > 0;
      ctx.beginPath();
      ctx.arc(dotX + 8, dotY, 6, 0, Math.PI * 2);
      if (isActive) {
        ctx.fillStyle = '#ff9800';
        ctx.fill();
        // Pulse effect
        ctx.strokeStyle = '#ffeb3b';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (filled) {
        ctx.fillStyle = '#ff9800';
        ctx.fill();
      } else {
        ctx.fillStyle = '#444';
        ctx.fill();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    rightY += 28; // past combo dots box
    // End-lag cooldown bar
    if (player.endLagTimer > 0) {
      const lagW = 100 * (player.endLagTimer / weap.endLag);
      drawRect(W - 113, rightY, lagW, 3, '#f44336');
      rightY += 5;
    }
  }

  // === Dodge counter (damage boost active) ===
  if (dodgeCounter > 0) {
    const dcW = 96 * (dodgeCounter / 90);
    drawRect(W - 110, rightY + 2, 102, 16, 'rgba(0,0,0,0.5)');
    drawRect(W - 107, rightY + 4, dcW, 12, '#64b5f6');
    drawText('COUNTER!', W - 58, rightY + 15, '#64b5f6', 9, 'center');
    rightY += 20;
  }

  // === Chain Count Multiplier ===
  if (player.comboChainCount > 0) {
    const chainMult = Math.min(2.0, 1.0 + player.comboChainCount * 0.5);
    drawRect(W - 115, rightY + 2, 110, 16, 'rgba(0,0,0,0.5)');
    drawText('CHAIN x' + chainMult.toFixed(1), W - 58, rightY + 14, '#ffd700', 10, 'center');
    rightY += 20;
  }

  // === COMBO COUNTER (center-right) ===
  if (player.comboHitCount >= 2) {
    const comboAlpha = player.comboHitTimer < 60 ? 1 : 1 - (player.comboHitTimer - 60) / 30;
    ctx.globalAlpha = Math.max(0.3, comboAlpha);
    const comboSize = Math.min(36, 20 + player.comboHitCount * 0.5);
    const comboY = rightY + 30;
    const comboX = W - 60;
    // Multiplier color
    const multColor = player.scoreMultiplier >= 3 ? '#f44336' : player.scoreMultiplier >= 2 ? '#ff9800' : player.scoreMultiplier >= 1.5 ? '#ffd700' : '#fff';
    drawText(player.comboHitCount, comboX, comboY, multColor, comboSize, 'center');
    drawText('HITS', comboX, comboY + 18, '#ccc', 10, 'center');
    if (player.scoreMultiplier > 1) {
      drawText('x' + player.scoreMultiplier, comboX, comboY + 32, multColor, 14, 'center');
    }
    ctx.globalAlpha = 1;
  }

  // === BOTTOM LEFT: Helper cooldowns ===
  const bottomBarY = isTouchDevice ? H - 175 : H - 38;
  drawRect(8, bottomBarY, 220, 30, 'rgba(0,0,0,0.6)');
  for (let i = 0; i < 4; i++) {
    const hx = 14 + i * 54;
    const hy = bottomBarY + 4;
    if (!helpers[i].unlocked) {
      // Locked helper — greyed out
      ctx.globalAlpha = 0.25;
      drawRect(hx, hy, 48, 22, 'rgba(0,0,0,0.3)');
      drawText((i+1) + ':?', hx + 4, hy + 16, '#555', 10);
      ctx.globalAlpha = 1;
      continue;
    }
    const ready = helperCooldowns[i] === 0;
    // Background
    drawRect(hx, hy, 48, 22, ready ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.3)');
    // Cooldown fill
    if (!ready) {
      drawRect(hx, hy, 48 * (1 - helperCooldowns[i] / helpers[i].cooldown), 22, helpers[i].color);
      ctx.globalAlpha = 0.3;
      drawRect(hx, hy, 48, 22, helpers[i].color);
      ctx.globalAlpha = 1;
    } else {
      drawRect(hx, hy, 48, 2, helpers[i].color);
    }
    ctx.globalAlpha = ready ? 1 : 0.4;
    drawText((i+1) + ':' + helpers[i].icon, hx + 4, hy + 16, '#fff', 10);
    ctx.globalAlpha = 1;
  }

  // === CONSUMABLE SLOTS (bottom right) ===
  if (player.consumables.length > 0) {
    drawRect(W - 200, bottomBarY, 192, 30, 'rgba(0,0,0,0.6)');
    for (let i = 0; i < player.consumables.length; i++) {
      const cx = W - 194 + i * 62;
      const cy = bottomBarY + 4;
      const effect = player.consumables[i];
      const ci = consumableItems.find(c => c.effect === effect);
      if (ci) {
        drawRect(cx, cy, 56, 22, 'rgba(255,255,255,0.1)');
        drawRect(cx, cy, 56, 2, ci.color);
        drawText((i+5) + ':' + ci.icon, cx + 4, cy + 16, '#fff', 9);
      }
    }
  }

  // (buff indicators moved into panel area above)

  // === Wave indicator ===
  if (!bossIntro && waveConfig.length > 1) {
    drawRect(W/2 - 50, 8, 100, 18, 'rgba(0,0,0,0.6)');
    drawText('WAVE ' + Math.min(currentWave, waveConfig.length) + '/' + waveConfig.length, W/2, 22, '#ff9800', 11, 'center');
  }

  // (end-lag bar shown in combo dots area)

  // === Speed boost indicator (center, only when active) ===
  if (player.speedBoost > 0) {
    drawRect(W/2 - 70, 60, 140, 20, 'rgba(0,0,0,0.6)');
    drawText('SPEED! ' + Math.ceil(player.speedBoost / 60) + 's', W/2, 76, '#76ff03', 12, 'center');
  }

  // === THREAT INDICATORS (off-screen enemy arrows) ===
  const allThreats = [];
  goons.forEach(g => {
    if (g.dead) return;
    if (g.windupTimer > 0) allThreats.push({ x: g.x, y: g.y, type: 'telegraph' });
  });
  if (boss && !boss.dead) {
    if (boss.bossState === 'attack') allThreats.push({ x: boss.x, y: boss.y, type: 'attack' });
    else if (boss.bossState === 'telegraph') allThreats.push({ x: boss.x, y: boss.y, type: 'telegraph' });
  }
  allThreats.forEach(t => {
    const margin = 200;
    if (t.x >= 0 && t.x <= W) return; // on-screen, skip
    if (Math.abs(t.x - (t.x < 0 ? 0 : W)) > margin) return; // too far
    const arrowColor = t.type === 'attack' ? '#f44336' : '#ffd700';
    const arrowX = t.x < 0 ? 16 : W - 16;
    const arrowY = Math.max(80, Math.min(H - 60, t.y));
    const dir = t.x < 0 ? -1 : 1;
    ctx.fillStyle = arrowColor;
    ctx.globalAlpha = 0.6 + Math.sin(gameTime * 0.15) * 0.3;
    ctx.beginPath();
    ctx.moveTo(arrowX + dir * 10, arrowY);
    ctx.lineTo(arrowX - dir * 6, arrowY - 8);
    ctx.lineTo(arrowX - dir * 6, arrowY + 8);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}

// ==========================================
// GAME OVER
// ==========================================
function drawGameOver() {
  ctx.fillStyle = 'rgba(10,0,0,0.95)';
  ctx.fillRect(0, 0, W, H);

  if (lives <= 0 && difficulty !== 'easy') {
    if (difficulty === 'hard') {
      // HARD: 0 lives = full game over, back to menu
      drawText('GAME OVER - FINE', W/2, 100, '#e53935', 32, 'center');
      drawText('Tutte le vite perse. Nessuna pieta\'.', W/2, 135, '#888', 12, 'center');

      const hardTaunts = [
        '"Ahahah Conte, sei finito! La difficile non perdona!"',
        '"Game over totale! Valle Aurelia e\' nostra per sempre!"',
        '"Pensavi di farcela in difficile? Illuso!"',
      ];
      const taunt = hardTaunts[Math.floor(gameTime / 240) % hardTaunts.length];
      drawText(taunt, W/2, 200, '#ff8a65', 13, 'center');
      drawText('- Pisellino', W/2, 225, '#ff6e40', 11, 'center');

      const restartBtnW = 260, restartBtnH = 40;
      const restartBtnX = W/2 - restartBtnW/2, restartBtnY = 300;
      const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
      drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#e94560' : 'rgba(233,69,96,0.3)');
      drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#e94560');
      drawText('RICOMINCIA DA CAPO', W/2, restartBtnY + 27, '#fff', 14, 'center');

      if (keys['Enter'] || keys['Space'] || (restartHover && mouseClick)) {
        // Full reset
        coins = 0; weapons = [starterWeapons[0]]; weaponTier = 0;
        jumpTier = 0; dodgeTier = 0; speedTier = 0;
        player.maxHp = 120; player.maxStamina = 100; player.speed = 4.0;
        player.upgrades = []; player.consumables = []; player.consumableTimers = {};
        helpers.forEach(h => { h.tier = 0; h.unlocked = false; });
        bossDefeated = [false, false, false, false, false];
        lives = 3; firstTime = true;
        state = 'menu';
        resetPlayer();
        bossIntro = false;
      }
    } else {
      // MEDIUM: 0 lives on this boss — back to Vanni
      drawText('SCONFITTA TOTALE', W/2, 100, '#e53935', 32, 'center');
      drawText('3 vite perse contro ' + levels[currentLevel].boss + '!', W/2, 135, '#888', 12, 'center');

      const finalTaunts = [
        '"Ahahah Conte, 3 tentativi e niente! Sei scarso forte!"',
        '"Torna a Vanni a allenarti, Contino... LOL"',
        '"Bro sei morto 3 volte, maybe prova a comprare qualcosa?"',
        '"Easy clap x3, troppo facile per ' + levels[currentLevel].boss + '!"',
      ];
      const taunt = finalTaunts[Math.floor(gameTime / 240) % finalTaunts.length];
      drawText(taunt, W/2, 200, '#ff8a65', 13, 'center');
      drawText('- Pisellino', W/2, 225, '#ff6e40', 11, 'center');

      drawText('Torna da Vanni, potenziati e riprova!', W/2, 270, '#aaa', 12, 'center');

      const restartBtnW = 260, restartBtnH = 40;
      const restartBtnX = W/2 - restartBtnW/2, restartBtnY = 320;
      const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
      drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#e94560' : 'rgba(233,69,96,0.3)');
      drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#e94560');
      drawText('TORNA DA VANNI', W/2, restartBtnY + 27, '#fff', 14, 'center');

      if (keys['Enter'] || keys['Space'] || (restartHover && mouseClick)) {
        lives = 3;
        state = 'hub';
        resetPlayer();
        bossIntro = false;
      }
    }
  } else {
    // Still have lives — normal game over
    drawText('GAME OVER', W/2, 120, '#e53935', 36, 'center');

    // Lives display
    if (difficulty === 'easy') {
      drawText('\u221E', W/2, 165, '#4caf50', 24, 'center');
      drawText('Vite infinite (facile)', W/2, 185, '#4caf50', 11, 'center');
    } else {
      for (let i = 0; i < 3; i++) {
        const lx = W/2 - 40 + i * 30;
        drawRect(lx, 145, 20, 20, i < lives ? '#e94560' : '#333');
        drawText(i < lives ? '\u2665' : '\u2661', lx + 10, 161, i < lives ? '#fff' : '#555', 14, 'center');
      }
      drawText('Vite rimaste: ' + lives, W/2, 185, '#ff8a80', 11, 'center');
    }

    // Pisellino special taunts
    if (currentLevel === 4) {
      const taunt = piselloTaunts[Math.floor(gameTime / 300) % piselloTaunts.length];
      drawText(taunt, W/2, 220, '#b0bec5', 14, 'center');
      drawText('- Pisellino', W/2, 245, '#78909c', 11, 'center');
    } else {
      drawText('Il Conte cade a ' + levels[currentLevel].name, W/2, 220, '#aaa', 14, 'center');
    }

    // Retry button (tappable)
    const retryBtnW = 180, retryBtnH = 36;
    const retryBtnX = W/2 - retryBtnW/2, retryBtnY = 290;
    const retryHover = mouseX >= retryBtnX && mouseX <= retryBtnX + retryBtnW && mouseY >= retryBtnY && mouseY <= retryBtnY + retryBtnH;
    drawRect(retryBtnX, retryBtnY, retryBtnW, retryBtnH, retryHover ? '#e94560' : 'rgba(233,69,96,0.3)');
    drawRect(retryBtnX, retryBtnY, retryBtnW, 2, '#e94560');
    drawText('RIPROVA', W/2, retryBtnY + 25, '#fff', 16, 'center');

    const backBtnW = 180, backBtnH = 36;
    const backBtnX = W/2 - backBtnW/2, backBtnY = 340;
    const backHover = mouseX >= backBtnX && mouseX <= backBtnX + backBtnW && mouseY >= backBtnY && mouseY <= backBtnY + backBtnH;
    drawRect(backBtnX, backBtnY, backBtnW, backBtnH, backHover ? '#555' : 'rgba(255,255,255,0.1)');
    drawText('TORNA A VANNI', W/2, backBtnY + 25, '#aaa', 13, 'center');

    if (keys['Enter'] || keys['Space'] || (retryHover && mouseClick)) {
      startLevel(currentLevel);
    }
    if (keys['Escape'] || (backHover && mouseClick)) {
      state = 'hub';
      resetPlayer();
      bossIntro = false;
    }
  }
  mouseClick = false;
}

// ==========================================
// SABI MODE — Secret Easter Egg
// ==========================================

const sabiJokesSabi = [
  "Ciao Bobbi! Benvenuto a Sbomboland!",
  "Sei il mio Sbombolone preferito!",
  "Bobbi loves u!",
  "A Sbomboland si mangia solo carbonara e popcorn",
  "Lo Sbombo e' forte in te oggi",
  "I'm in love with the Sbombo!",
];

const sabiJokesTotti = [
  "*scodinzola furiosamente* BOBBI!",
  "Totti deve cacare!",
  "Lo Sbombolo approva!",
  "Totti: re indiscusso di Sbomboland",
  "*lecca Cicca con entusiasmo*",
  "Sbombo mode: ACTIVATED",
];

function drawCicca(x, y, facing, animTimer) {
  const bob = Math.sin(animTimer * 0.15) * 2;
  const bx = x - 12, by = y - 20 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 28, 5);
  // Body — orange tabby
  drawRect(bx, by + 6, 24, 12, '#ff8a65');
  drawRect(bx + 2, by + 8, 20, 8, '#ffab91');
  // Stripes
  drawRect(bx + 4, by + 7, 3, 10, '#e64a19');
  drawRect(bx + 10, by + 7, 3, 10, '#e64a19');
  drawRect(bx + 16, by + 7, 3, 10, '#e64a19');
  // Head
  drawRect(bx + 4, by, 16, 10, '#ff8a65');
  // Ears — pointy triangles
  drawRect(bx + 4, by - 4, 4, 5, '#ff8a65');
  drawRect(bx + 5, by - 3, 2, 3, '#ffab91');
  drawRect(bx + 16, by - 4, 4, 5, '#ff8a65');
  drawRect(bx + 17, by - 3, 2, 3, '#ffab91');
  // Eyes — big green
  drawRect(bx + 7, by + 2, 3, 3, '#4caf50');
  drawRect(bx + 8, by + 3, 1, 1, '#111');
  drawRect(bx + 14, by + 2, 3, 3, '#4caf50');
  drawRect(bx + 15, by + 3, 1, 1, '#111');
  // Pink nose
  drawRect(bx + 11, by + 5, 2, 2, '#ff80ab');
  // Whiskers
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(bx + 5, by + 5); ctx.lineTo(bx - 2, by + 3);
  ctx.moveTo(bx + 5, by + 6); ctx.lineTo(bx - 2, by + 7);
  ctx.moveTo(bx + 19, by + 5); ctx.lineTo(bx + 26, by + 3);
  ctx.moveTo(bx + 19, by + 6); ctx.lineTo(bx + 26, by + 7);
  ctx.stroke();
  // Legs
  drawRect(bx + 2, by + 16, 4, 4, '#ff8a65');
  drawRect(bx + 18, by + 16, 4, 4, '#ff8a65');
  // Tail — swaying sine wave
  const tailSway = Math.sin(animTimer * 0.1) * 6 * facing;
  drawRect(bx + (facing === 1 ? -2 : 22), by + 8, 3, 2, '#ff8a65');
  drawRect(bx + (facing === 1 ? -5 : 25) + tailSway * 0.3, by + 6, 3, 2, '#ff8a65');
  drawRect(bx + (facing === 1 ? -8 : 28) + tailSway, by + 4, 3, 2, '#e64a19');
}

function drawSabiChar(x, y, animTimer) {
  const bob = Math.sin(animTimer * 0.04) * 2;
  const bx = x - 15, by = y - 52 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 34, 6);
  // Use drawPixelChar base — pink dress, light skin
  drawPixelChar(bx, by, 30, 52, '#ff69b4', '#ffe0b2', (px, py, pw, ph) => {
    // Blonde hair — long flowing
    drawRect(px + 2, py - 4, pw - 4, 8, '#ffd54f');
    drawRect(px, py, 3, 26, '#ffd54f'); // left side hair
    drawRect(px + pw - 3, py, 3, 26, '#ffd54f'); // right side hair
    drawRect(px + 2, py, pw - 4, 4, '#ffd54f'); // top hair
    // Hair highlights
    drawRect(px + 4, py - 2, 4, 3, '#ffe082');
    drawRect(px + pw - 8, py - 2, 4, 3, '#ffe082');
    // Blue eyes — override defaults
    drawRect(px + 8, py + 8, 5, 5, '#2196f3');
    drawRect(px + pw - 13, py + 8, 5, 5, '#2196f3');
    drawRect(px + 10, py + 10, 2, 2, '#0d47a1');
    drawRect(px + pw - 11, py + 10, 2, 2, '#0d47a1');
    // Pink cheeks (blush)
    drawRect(px + 5, py + 14, 4, 2, '#ff8a80');
    drawRect(px + pw - 9, py + 14, 4, 2, '#ff8a80');
    // Smile
    drawRect(px + 11, py + 15, 8, 2, '#e57373');
    // Heart on dress
    drawRect(px + 12, py + 30, 3, 3, '#f44336');
    drawRect(px + 16, py + 30, 3, 3, '#f44336');
    drawRect(px + 11, py + 33, 9, 3, '#f44336');
    drawRect(px + 12, py + 36, 7, 2, '#f44336');
    drawRect(px + 13, py + 38, 5, 1, '#f44336');
  });
}

function drawTottiDog(x, y, animTimer, wagSpeed) {
  const bob = Math.sin(animTimer * 0.06) * 1;
  const bx = x - 18, by = y - 26 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 40, 5);
  // Body — stocky gray brindle amstaff
  drawRect(bx, by + 6, 36, 16, '#78909c');
  drawRect(bx + 2, by + 8, 32, 12, '#546e7a');
  // Brindle pattern
  drawRect(bx + 6, by + 9, 4, 8, '#78909c');
  drawRect(bx + 14, by + 9, 4, 8, '#78909c');
  drawRect(bx + 22, by + 9, 4, 8, '#78909c');
  // Chest — lighter
  drawRect(bx + 8, by + 10, 10, 8, '#90a4ae');
  // Legs — short and muscular
  drawRect(bx + 2, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 10, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 20, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 28, by + 20, 6, 6, '#546e7a');
  // Head — big and broad
  drawRect(bx + 26, by - 2, 14, 12, '#78909c');
  drawRect(bx + 28, by, 10, 8, '#90a4ae');
  // Floppy ears
  drawRect(bx + 25, by - 4, 4, 6, '#546e7a');
  drawRect(bx + 38, by - 4, 4, 6, '#546e7a');
  // Eyes
  drawRect(bx + 30, by + 1, 3, 3, '#263238');
  drawRect(bx + 36, by + 1, 3, 3, '#263238');
  // Nose
  drawRect(bx + 33, by + 5, 4, 3, '#111');
  // Tongue out
  drawRect(bx + 34, by + 8, 3, 4, '#ef5350');
  // Wagging tail
  const tailWag = Math.sin(animTimer * 0.2 * wagSpeed) * 8;
  drawRect(bx - 4, by + 4 + tailWag * 0.3, 6, 3, '#78909c');
  drawRect(bx - 8, by + 2 + tailWag, 5, 3, '#546e7a');
}

function drawSpeechBubble(x, y, text, timer) {
  if (timer > 120) return;
  const alpha = timer < 80 ? 1 : Math.max(0, 1 - (timer - 80) / 40);
  ctx.globalAlpha = alpha;
  ctx.font = '9px monospace';
  const tw = ctx.measureText(text).width + 16;
  const bx = Math.max(4, Math.min(W - tw - 4, x - tw / 2));
  drawRect(bx, y - 28, tw, 20, 'rgba(255,255,255,0.92)');
  drawRect(bx, y - 28, tw, 2, '#ff69b4');
  drawText(text, bx + tw / 2, y - 13, '#333', 9, 'center');
  // Small triangle pointer
  drawRect(x - 3, y - 8, 6, 4, 'rgba(255,255,255,0.92)');
  ctx.globalAlpha = 1;
}

function drawSabi() {
  sabiTimer++;
  if (!sabiCicca) return;

  // === Background — Sbomboland sunset sky ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#7b1fa2');
  skyGrad.addColorStop(0.3, '#e91e63');
  skyGrad.addColorStop(0.6, '#ff9800');
  skyGrad.addColorStop(1, '#ffcc02');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Sun
  ctx.fillStyle = '#fff9c4';
  ctx.beginPath();
  ctx.arc(W - 120, 80, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff176';
  ctx.beginPath();
  ctx.arc(W - 120, 80, 32, 0, Math.PI * 2);
  ctx.fill();

  // Clouds
  for (let i = 0; i < 4; i++) {
    const cx = ((i * 230 + sabiTimer * 0.3) % (W + 100)) - 50;
    const cy = 40 + i * 25;
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(cx, cy, 18, 0, Math.PI * 2);
    ctx.arc(cx + 16, cy - 6, 14, 0, Math.PI * 2);
    ctx.arc(cx + 30, cy, 16, 0, Math.PI * 2);
    ctx.fill();
  }

  // Rolling hills (background)
  ctx.fillStyle = '#66bb6a';
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y - 40);
  for (let hx = 0; hx <= W; hx += 5) {
    ctx.lineTo(hx, GROUND_Y - 40 + Math.sin(hx * 0.008) * 25 + Math.sin(hx * 0.02) * 10);
  }
  ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();

  // Ground
  drawRect(0, GROUND_Y - 5, W, H - GROUND_Y + 5, '#4caf50');
  drawRect(0, GROUND_Y - 5, W, 3, '#388e3c');

  // Flowers on the ground
  for (let i = 0; i < 12; i++) {
    const fx = (i * 79 + 20) % W;
    const fy = GROUND_Y - 8 - Math.sin(i * 3.7) * 3;
    const fc = ['#ff69b4', '#ffeb3b', '#e040fb', '#ff5252', '#81d4fa'][i % 5];
    drawRect(fx, fy, 4, 4, fc);
    drawRect(fx + 1, fy - 3, 2, 3, '#66bb6a');
  }

  // Cozy house silhouette
  drawRect(60, GROUND_Y - 80, 70, 75, '#5d4037');
  drawRect(55, GROUND_Y - 80, 80, 5, '#4e342e');
  // Roof triangle (as rects)
  drawRect(65, GROUND_Y - 95, 60, 5, '#4e342e');
  drawRect(72, GROUND_Y - 100, 46, 5, '#4e342e');
  drawRect(80, GROUND_Y - 105, 30, 5, '#4e342e');
  drawRect(88, GROUND_Y - 108, 14, 5, '#4e342e');
  // Window glow
  drawRect(70, GROUND_Y - 60, 16, 14, '#fff9c4');
  drawRect(104, GROUND_Y - 60, 16, 14, '#fff9c4');
  // Door
  drawRect(85, GROUND_Y - 35, 20, 30, '#3e2723');
  // Heart on door
  drawRect(91, GROUND_Y - 28, 3, 3, '#f44336');
  drawRect(96, GROUND_Y - 28, 3, 3, '#f44336');
  drawRect(90, GROUND_Y - 25, 10, 3, '#f44336');
  drawRect(91, GROUND_Y - 22, 8, 2, '#f44336');
  drawRect(93, GROUND_Y - 20, 4, 1, '#f44336');

  // SBOMBOLAND sign
  drawRect(750, GROUND_Y - 50, 4, 50, '#795548');
  drawRect(720, GROUND_Y - 60, 70, 18, '#fff9c4');
  drawRect(720, GROUND_Y - 60, 70, 2, '#ff69b4');
  drawText('SBOMBOLAND', 755, GROUND_Y - 47, '#e91e63', 8, 'center');

  // Floating hearts + sparkles
  for (let i = 0; i < 6; i++) {
    const hx = (i * 150 + sabiTimer * 0.5 + i * 37) % W;
    const hy = 160 + Math.sin(sabiTimer * 0.02 + i * 2) * 40;
    const hs = 3 + Math.sin(sabiTimer * 0.03 + i) * 1;
    ctx.globalAlpha = 0.4 + Math.sin(sabiTimer * 0.04 + i) * 0.2;
    drawRect(hx, hy, hs, hs, '#ff69b4');
    drawRect(hx + hs + 1, hy, hs, hs, '#ff69b4');
    drawRect(hx - 1, hy + hs, hs * 2 + 2, hs, '#ff69b4');
    drawRect(hx, hy + hs * 2, hs * 2, hs * 0.6, '#ff69b4');
    ctx.globalAlpha = 1;
  }
  // Sparkles
  for (let i = 0; i < 5; i++) {
    const sx = (i * 190 + sabiTimer * 0.7 + i * 53) % W;
    const sy = 100 + Math.sin(sabiTimer * 0.03 + i * 1.5) * 60;
    ctx.globalAlpha = 0.3 + Math.sin(sabiTimer * 0.05 + i * 2.1) * 0.3;
    drawRect(sx, sy, 2, 2, '#fff');
    drawRect(sx - 1, sy + 1, 1, 1, '#fff9c4');
    ctx.globalAlpha = 1;
  }

  // === Draw characters ===
  drawSabiChar(sabiSabi.x, sabiSabi.y, sabiSabi.animTimer);
  drawTottiDog(sabiTotti.x, sabiTotti.y, sabiTotti.animTimer, sabiCicca && Math.abs(sabiCicca.x - sabiTotti.x) < 60 ? 3 : 1);
  drawCicca(sabiCicca.x, sabiCicca.y, sabiCicca.facing, sabiCicca.animTimer);

  // === Player movement (Cicca the cat) ===
  const speed = 2.5;
  if (keys['ArrowLeft'] || keys['KeyA']) {
    sabiCicca.vx = -speed;
    sabiCicca.facing = -1;
    sabiCicca.animTimer++;
  } else if (keys['ArrowRight'] || keys['KeyD']) {
    sabiCicca.vx = speed;
    sabiCicca.facing = 1;
    sabiCicca.animTimer++;
  } else {
    sabiCicca.vx = 0;
  }
  sabiCicca.x += sabiCicca.vx;
  sabiCicca.x = Math.max(20, Math.min(W - 20, sabiCicca.x));

  // Update character anim timers
  sabiSabi.animTimer++;
  sabiTotti.animTimer++;

  // === Interaction — speech bubbles ===
  const distToSabi = Math.abs(sabiCicca.x - sabiSabi.x);
  const distToTotti = Math.abs(sabiCicca.x - sabiTotti.x);

  // Show interaction prompts
  if (distToSabi < 60) {
    ctx.globalAlpha = 0.5 + Math.sin(sabiTimer * 0.1) * 0.3;
    drawText('[SPACE]', sabiSabi.x, sabiSabi.y - 62, '#fff', 8, 'center');
    ctx.globalAlpha = 1;
  }
  if (distToTotti < 60) {
    ctx.globalAlpha = 0.5 + Math.sin(sabiTimer * 0.1) * 0.3;
    drawText('[SPACE]', sabiTotti.x, sabiTotti.y - 36, '#fff', 8, 'center');
    ctx.globalAlpha = 1;
  }

  // Trigger joke on Space press
  if (keysJustPressed['Space']) {
    if (distToSabi < 60) {
      if (!sabiSwordUnlocked) {
        sabiDialogueCount++;
        if (sabiDialogueCount >= 10) {
          // === SBOMBO SWORD UNLOCK ===
          sabiSwordUnlocked = true;
          sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
          sabiMessages.push({ text: 'Bobbi, ti meriti questo... LA SPADA DELLO SBOMBO!', target: 'sabi', timer: 0 });
          playSFX('victory_jingle');
          screenFlash = 30;
          flashColor = '#ffd700';
          screenShake = 12;
          spawnParticles(sabiSabi.x, sabiSabi.y - 30, '#ffd700', 25, 8);
          spawnParticles(sabiSabi.x, sabiSabi.y - 30, '#ff69b4', 20, 6);
          // Replace weapon with Sbombo Sword
          weapons[0] = {
            name: 'Spada dello Sbombo',
            damage: 80,
            range: 90,
            speed: 4,
            crit: 50,
            comboHits: 6,
            poise: 30,
            activeFrames: 10,
            comboWindow: 18,
            endLag: 6,
            special: 'sbombo',
            color: '#ff69b4',
            desc: 'La leggendaria spada di Sbomboland',
            icon: '\u2665',
            glow: true
          };
          weaponTier = 3;
        } else {
          const joke = sabiJokesSabi[Math.floor(Math.random() * sabiJokesSabi.length)];
          sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
          sabiMessages.push({ text: joke, target: 'sabi', timer: 0 });
          playSFX('coin');
        }
      } else {
        // Post-unlock dialogue
        const postUnlock = ['Usa la Spada dello Sbombo, Bobbi!', 'Vai e sbomba tutti!', 'La spada e\' parte di te ora...', 'Nessuno puo\' fermarti!', 'Sbomba con amore <3'];
        const msg = postUnlock[Math.floor(Math.random() * postUnlock.length)];
        sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
        sabiMessages.push({ text: msg, target: 'sabi', timer: 0 });
        playSFX('coin');
      }
    }
    if (distToTotti < 60) {
      const joke = sabiJokesTotti[Math.floor(Math.random() * sabiJokesTotti.length)];
      sabiMessages = sabiMessages.filter(m => m.target !== 'totti');
      sabiMessages.push({ text: joke, target: 'totti', timer: 0 });
      playSFX('coin');
    }
  }

  // Draw and update speech bubbles
  sabiMessages.forEach(m => {
    m.timer++;
    if (m.target === 'sabi') {
      drawSpeechBubble(sabiSabi.x, sabiSabi.y - 60, m.text, m.timer);
    } else {
      drawSpeechBubble(sabiTotti.x, sabiTotti.y - 34, m.text, m.timer);
    }
  });
  sabiMessages = sabiMessages.filter(m => m.timer < 120);

  // === UI text ===
  // Title — floating
  const titleBob = Math.sin(sabiTimer * 0.03) * 4;
  drawText('~ SBOMBOLAND ~', W / 2, 30 + titleBob, '#ff69b4', 22, 'center');
  drawText('~ SBOMBOLAND ~', W / 2 + 1, 31 + titleBob, '#ffd54f', 22, 'center');

  // Sbombo counter
  if (!sabiSwordUnlocked) {
    drawText('Sbombi: ' + sabiDialogueCount + '/10', W - 90, 30, '#ff69b4', 11, 'center');
  } else {
    drawText('\u2665 SPADA SBLOCCATA \u2665', W - 100, 30, '#ffd700', 11, 'center');
  }

  // Bottom hints
  drawText('ESC per tornare al gioco', W / 2, H - 20, 'rgba(255,255,255,0.6)', 10, 'center');
  drawText('Dedicato a Sabina con amore <3', W / 2, H - 8, '#ff69b4', 9, 'center');

  // Arrow keys hint (fades after a few seconds)
  if (sabiTimer < 180) {
    ctx.globalAlpha = Math.max(0, 1 - sabiTimer / 180);
    drawText('Usa le frecce per muovere Cicca!', W / 2, H - 40, '#fff', 10, 'center');
    ctx.globalAlpha = 1;
  }

  // === ESC to return ===
  if (keys['Escape']) {
    state = sabiPreviousState;
  }
}

// ==========================================
// VICTORY
// ==========================================
let victoryTimer = 0; // guard timer to prevent instant restart
let victorySongStarted = false;
let freestyleFadeTimer = 0; // countdown for smooth crossfade to freestyle

function startVictorySong() {
  if (victorySongStarted) return;
  victorySongStarted = true;
  // Don't stop 8-bit music yet — start a fade timer for smooth transition
  freestyleFadeTimer = 30; // ~0.5s fade
}

function stopVictorySong() {
  victorySongStarted = false;
  freestyleVideo.pause();
  freestyleVideo.currentTime = 0;
}

function drawVictory() {
  victoryTimer++;

  // Let 8-bit fanfare play for ~4 seconds, then crossfade to freestyle
  if (victoryTimer === 240) startVictorySong();

  // Smooth crossfade: fade out 8-bit music, then start freestyle
  if (freestyleFadeTimer > 0) {
    freestyleFadeTimer--;
    if (freestyleFadeTimer === 0) {
      stopMusic();
      freestyleVideo.currentTime = 0;
      freestyleVideo.play().catch(() => {});
    }
  }

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1b5e20');
  grad.addColorStop(1, '#0d0d1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Fireworks
  if (gameTime % 20 === 0) {
    const fx = 100 + Math.random() * (W - 200);
    const fy = 50 + Math.random() * 200;
    const colors = ['#f44336','#ffeb3b','#4caf50','#2196f3','#e040fb','#ff9800'];
    spawnParticles(fx, fy, colors[Math.floor(Math.random() * colors.length)], 15, 6);
  }
  drawParticles();
  updateParticles();

  // Scrolling credits with fade-in
  const fadeIn = Math.min(1, victoryTimer / 60);
  ctx.globalAlpha = fadeIn;

  const bounce = Math.sin(gameTime * 0.05) * 5;
  drawText('VITTORIA!', W/2, 80 + bounce, '#ffd700', 42, 'center');
  drawText('Il Conte ha conquistato Valle Aurelia!', W/2, 130, '#fff', 16, 'center');
  drawText('La gang e\' stata sconfitta. Prati e\' salvo.', W/2, 155, '#aaa', 14, 'center');

  drawText('Daniele "il Conte" - EROE DI PRATI', W/2, 200, '#ffcc80', 20, 'center');

  // Boss defeated list
  drawText('Boss sconfitti:', W/2, 245, '#e94560', 14, 'center');
  levels.forEach((l, i) => {
    const bossAlpha = Math.min(1, Math.max(0, (victoryTimer - 60 - i * 30) / 30));
    ctx.globalAlpha = bossAlpha * fadeIn;
    drawText(l.boss + ' (' + l.name + ')', W/2, 268 + i * 22, '#4caf50', 12, 'center');
  });
  ctx.globalAlpha = fadeIn;

  // Credits section
  const creditsY = 385;
  drawText('- CREDITS -', W/2, creditsY, '#ffd700', 14, 'center');
  drawText('Un gioco da conti...anzi, del Conte!', W/2, creditsY + 18, '#ccc', 11, 'center');
  drawText('Sviluppatore: Cicca', W/2, creditsY + 36, '#aaa', 11, 'center');
  drawText('Musica: Cicca & Daniele', W/2, creditsY + 50, '#aaa', 11, 'center');
  drawText('Ambientato a Prati, Roma', W/2, creditsY + 64, '#aaa', 11, 'center');
  drawText('Grazie per aver giocato!', W/2, creditsY + 84, '#ffcc80', 13, 'center');

  drawText('Coins raccolti: ' + coins, W/2, creditsY + 104, '#ffd700', 12, 'center');

  ctx.globalAlpha = 1;

  // Only show restart prompt after 3 seconds
  if (victoryTimer > 180) {
    const restartBtnW = 260, restartBtnH = 36;
    const restartBtnX = W/2 - restartBtnW/2, restartBtnY = H - 50;
    const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
    drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#ffd700' : 'rgba(255,215,0,0.2)');
    drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#ffd700');
    drawText('RICOMINCIA', W/2, restartBtnY + 25, restartHover ? '#1a1a2e' : '#ffd700', 16, 'center');

    if (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || (restartHover && mouseClick)) {
      // Reset everything
      coins = 0;
      player.weapon = 0;
      weapons = [starterWeapons[0]];
      weaponTier = 0;
      jumpTier = 0; dodgeTier = 0; speedTier = 0;
      player.maxHp = 120;
      player.maxStamina = 100;
      player.speed = 4.0;
      player.upgrades = [];
      player.consumables = [];
      player.consumableTimers = {};
      helpers.forEach(h => { h.tier = 0; h.unlocked = false; });
      bossDefeated = [false, false, false, false, false];
      lives = 3;
      firstTime = true;
      victoryTimer = 0;
      freestyleFadeTimer = 0;
      stopVictorySong();
      state = 'menu';
    }
  }
}

// ==========================================
// MAIN GAME LOOP
// ==========================================
function update() {
  // Skip game updates while freestyle video is playing
  if (freestylePlaying) return;

  gameTime++;

  // Music management per state
  switch(state) {
    case 'menu': playTrack('menu'); break;
    case 'difficultySelect': case 'weaponSelect': case 'helperSelect': playTrack('menu'); break;
    case 'tutorial': playTrack('hub'); break;
    case 'hub': case 'shop': case 'upgrade': playTrack('hub'); break;
    case 'moves': break; // keep whatever music was playing
    case 'dialogue':
      // During dialogue, keep appropriate music playing (don't let it die)
      if (currentTrackName) playTrack(currentTrackName);
      break;
    case 'level':
      if (bossIntro && bossIntroTimer <= 0) {
        const bossTrackMap = ['boss_lafed', 'boss_gioacchino', 'boss_dale', 'boss_ciccio', 'boss_pisellino'];
        playTrack(bossTrackMap[currentLevel] || 'boss_lafed');
      } else if (bossIntro && bossIntroTimer > 0) {
        const buildupMap = ['boss_buildup_0', 'boss_buildup_1', 'boss_buildup_2', 'boss_buildup_3', 'boss_buildup_4'];
        playTrack(buildupMap[currentLevel] || 'boss_buildup_4');
      } else {
        playTrack('level');
      }
      break;
    case 'gameover': playTrack('gameover'); break;
    case 'victory': if (!victorySongStarted) playTrack('victory'); break;
    case 'sabi': playTrack('sabi'); break;
  }

  switch(state) {
    case 'menu': break;
    case 'difficultySelect': break;
    case 'weaponSelect': break;
    case 'helperSelect': break;
    case 'moves': break;
    case 'tutorial': updateTutorial(); break;
    case 'hub': break;
    case 'shop': break;
    case 'upgrade': break;
    case 'dialogue': break;
    case 'level': updateLevel(); break;
    case 'gameover': break;
    case 'victory': break;
    case 'sabi': break;
  }

  // Screen shake
  if (screenShake > 0) screenShake--;
  if (screenFlash > 0) screenFlash--;

}

function draw() {
  ctx.save();

  // Screen shake
  if (screenShake > 0) {
    const sx = (Math.random() - 0.5) * screenShake;
    const sy = (Math.random() - 0.5) * screenShake;
    ctx.translate(sx, sy);
  }

  switch(state) {
    case 'menu': drawMenu(); break;
    case 'difficultySelect': drawDifficultySelect(); break;
    case 'weaponSelect': drawWeaponSelect(); break;
    case 'helperSelect': drawHelperSelect(); break;
    case 'moves': drawMovesScreen(); break;
    case 'tutorial': drawTutorial(); break;
    case 'hub': drawHub(); break;
    case 'shop': drawShop(); break;
    case 'upgrade': drawUpgradeScreen(); break;
    case 'dialogue': drawDialogue(); break;
    case 'level': drawLevel(); break;
    case 'gameover': drawGameOver(); break;
    case 'victory': drawVictory(); break;
    case 'sabi': drawSabi(); break;
  }

  // Screen flash
  if (screenFlash > 0) {
    ctx.globalAlpha = screenFlash / 20;
    ctx.fillStyle = flashColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function gameLoop() {
  if (hitstopFrames > 0) {
    hitstopFrames--;
    draw(); // Still draw, but freeze gameplay for impact feel
  } else {
    update();
    draw();
  }
  // Clear just-pressed keys AFTER both update() and draw() so draw-phase code (hub) can read them
  Object.keys(keysJustPressed).forEach(k => delete keysJustPressed[k]);
  mouseClick = false;
  requestAnimationFrame(gameLoop);
}

// Start
gameLoop();

</script>
</body>
</html>
