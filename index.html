<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>La Guerra di Valle Aurelia</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { background: #1a1a2e; width: 100%; height: 100%; overflow: hidden; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
body { display: flex; justify-content: center; align-items: center; font-family: monospace; }
canvas { border: 3px solid #e94560; image-rendering: pixelated; max-width: 100vw; max-height: 100dvh; width: 100vw; height: auto; }
@media (min-aspect-ratio: 900/550) {
  canvas { width: auto; height: 100dvh; }
}
@media (min-width: 1000px) and (min-height: 700px) and (hover: hover) {
  canvas { min-width: min(98vw, 170vh); }
}
@supports (padding: env(safe-area-inset-bottom)) {
  canvas { max-height: calc(100dvh - env(safe-area-inset-bottom)); }
}
@media (pointer: coarse) {
  canvas { border: none; width: 100vw; height: 100dvh; object-fit: contain; }
}
#ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); pointer-events: none; }
#freestyle-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; display: none; justify-content: center; align-items: center; flex-direction: column; }
#freestyle-overlay.active { display: flex; }
#freestyle-video { max-width: 100%; max-height: 90vh; }
#freestyle-hint { color: #555; font-family: monospace; font-size: 12px; margin-top: 8px; }
#freestyle-close { position: absolute; top: 12px; right: 16px; background: rgba(255,255,255,0.15); color: #fff; border: 1px solid #555; font-family: monospace; font-size: 18px; padding: 8px 18px; cursor: pointer; z-index: 1000; border-radius: 4px; }
</style>
</head>
<body>
<div id="freestyle-overlay">
  <button id="freestyle-close" onclick="stopFreestyleVideo()">X CHIUDI</button>
  <video id="freestyle-video" src="prati_freestyle.mp4" preload="none" playsinline></video>
  <div id="freestyle-hint">ESC per tornare</div>
</div>
<canvas id="game" width="900" height="550"></canvas>
<script>
// ==========================================
// LA GUERRA DI VALLE AURELIA
// A game about il Conte vs the gang
// ==========================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 900, H = 550;

// Input
const keys = {};
const keysJustPressed = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) keysJustPressed[e.code] = true;
  keys[e.code] = true;
  e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

let mouseX = 0, mouseY = 0, mouseClick = false;
canvas.addEventListener('mousemove', e => {
  const r = getCanvasContentRect();
  mouseX = (e.clientX - r.left) * (W / r.width);
  mouseY = (e.clientY - r.top) * (H / r.height);
});
canvas.addEventListener('click', e => {
  const r = getCanvasContentRect();
  mouseX = (e.clientX - r.left) * (W / r.width);
  mouseY = (e.clientY - r.top) * (H / r.height);
  mouseClick = true;
});

// Account for object-fit: contain letterboxing when converting coordinates
function getCanvasContentRect() {
  const r = canvas.getBoundingClientRect();
  const canvasAspect = W / H;
  const elemAspect = r.width / r.height;
  if (elemAspect > canvasAspect) {
    const rW = r.height * canvasAspect;
    return { left: r.left + (r.width - rW) / 2, top: r.top, width: rW, height: r.height };
  } else {
    const rH = r.width / canvasAspect;
    return { left: r.left, top: r.top + (r.height - rH) / 2, width: r.width, height: rH };
  }
}

// Touch device detection
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
const mobileMenuStates = new Set([
  'menu', 'upgrade', 'hub', 'moves', 'tutorial'
]);
// When inside mobile.html iframe, the HTML overlay handles all controls — disable canvas touch buttons
const inMobileWrapper = (window.self !== window.top);

// Virtual button definitions
const touchButtons = {
  // Left side: movement + ultra on top
  left:    { x: 4,   y: H - 126, w: 120, h: 106, key: 'KeyA', label: '\u25C0', color: '#888', justPress: false },
  right:   { x: 128, y: H - 126, w: 120, h: 106, key: 'KeyD', label: '\u25B6', color: '#888', justPress: false },
  ultra:   { x: 4,   y: H - 240, w: 244, h: 96,  key: 'KeyQ', label: 'ULTRA', color: '#ffd700', justPress: true },
  // Right side: jump on top, dodge + ATK at bottom
  jump:    { x: W - 270, y: H - 248, w: 264, h: 98, key: 'KeyW', label: 'JUMP', color: '#4caf50', justPress: false },
  dodge:   { x: W - 270, y: H - 140, w: 128, h: 116, key: 'KeyX', label: 'X', color: '#2196f3', justPress: true },
  attack:  { x: W - 138, y: H - 140, w: 132, h: 116, key: 'KeyZ', label: 'ATK', color: '#e94560', justPress: true },
  // Helpers — centered between left and right controls
  helper1: { x: 310, y: H - 84, w: 62, h: 52, key: 'Digit1', label: '1', color: '#4caf50', justPress: true },
  helper2: { x: 378, y: H - 84, w: 62, h: 52, key: 'Digit2', label: '2', color: '#4caf50', justPress: true },
  helper3: { x: 446, y: H - 84, w: 62, h: 52, key: 'Digit3', label: '3', color: '#4caf50', justPress: true },
  helper4: { x: 514, y: H - 84, w: 62, h: 52, key: 'Digit4', label: '4', color: '#4caf50', justPress: true },
  // Consumables — right of helpers, slightly separated
  // Utility
  tab:     { x: W - 95, y: 36, w: 38, h: 28, key: 'Tab', label: 'TAB', color: '#555', justPress: true },
  enter:   { x: W/2 - 50, y: H - 50, w: 100, h: 38, key: 'Enter', label: 'OK', color: '#4caf50', justPress: true },
  pause:   { x: W - 52, y: 36, w: 38, h: 28, key: 'Escape', label: 'II', color: '#666', justPress: true }
};

const activeTouches = {};
const touchBtnState = {}; // track which button each touch is pressing

function hitTestButton(tx, ty) {
  const validBtns = getTouchButtonsForState();
  for (const name of validBtns) {
    const b = touchButtons[name];
    if (tx >= b.x && tx <= b.x + b.w && ty >= b.y && ty <= b.y + b.h) {
      return name;
    }
  }
  return null;
}

function getTouchButtonsForState() {
  if (state === 'level') return ['attack', 'dodge', 'jump', 'left', 'right', 'ultra', 'helper1', 'helper2', 'helper3', 'helper4', 'tab', 'pause'];
  if (state === 'tutorial') return ['attack', 'dodge', 'jump', 'left', 'right', 'ultra', 'enter'];
  if (state === 'sabi') return ['left', 'right', 'attack', 'pause'];
  if (state === 'casino') return ['enter', 'tab', 'pause'];
  if (state === 'hub') return ['enter'];
  if (state === 'shop' || state === 'upgrade') return ['enter', 'tab', 'pause'];
  if (state === 'dialogue') return ['enter'];
  if (state === 'menu' || state === 'difficultySelect' || state === 'weaponSelect' || state === 'helperSelect') return ['enter'];
  if (state === 'gameover' || state === 'victory') return ['enter'];
  return [];
}

function handleTouchDown(tx, ty, id) {
  const btnName = hitTestButton(tx, ty);
  if (btnName) {
    const b = touchButtons[btnName];
    touchBtnState[id] = btnName;
    keys[b.key] = true;
    if (b.justPress) keysJustPressed[b.key] = true;
  } else {
    // No button hit — treat as mouse for UI
    mouseX = tx;
    mouseY = ty;
    mouseClick = true;
  }
}

function handleTouchUp(id) {
  const btnName = touchBtnState[id];
  if (btnName) {
    const b = touchButtons[btnName];
    keys[b.key] = false;
    delete touchBtnState[id];
  }
  delete activeTouches[id];
}

function handleTouchMove(tx, ty, id) {
  const oldBtn = touchBtnState[id];
  const newBtn = hitTestButton(tx, ty);
  if (oldBtn !== newBtn) {
    // Released old button
    if (oldBtn) {
      keys[touchButtons[oldBtn].key] = false;
      delete touchBtnState[id];
    }
    // Pressed new button
    if (newBtn) {
      const b = touchButtons[newBtn];
      touchBtnState[id] = newBtn;
      keys[b.key] = true;
      if (b.justPress) keysJustPressed[b.key] = true;
    }
  }
  // Always update mouse position for UI hover
  mouseX = tx;
  mouseY = ty;
}

// Skip canvas touch listeners when inside mobile wrapper — the overlay handles all input
if (!inMobileWrapper) {
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const r = getCanvasContentRect();
  for (const t of e.changedTouches) {
    const tx = (t.clientX - r.left) * (W / r.width);
    const ty = (t.clientY - r.top) * (H / r.height);
    activeTouches[t.identifier] = { x: tx, y: ty };
    handleTouchDown(tx, ty, t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const r = getCanvasContentRect();
  for (const t of e.changedTouches) {
    const tx = (t.clientX - r.left) * (W / r.width);
    const ty = (t.clientY - r.top) * (H / r.height);
    activeTouches[t.identifier] = { x: tx, y: ty };
    handleTouchMove(tx, ty, t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    handleTouchUp(t.identifier);
  }
}, { passive: false });
canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    handleTouchUp(t.identifier);
  }
}, { passive: false });
}

// ==========================================
// MUSIC & SOUND ENGINE (Web Audio API)
// ==========================================
let audioCtx = null;
let musicGain = null;
let sfxGain = null;
let currentTrack = null;
let musicPlaying = false;
let musicEnabled = true;
let audioStarted = false;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.25;
  musicGain.connect(audioCtx.destination);
  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.3;
  sfxGain.connect(audioCtx.destination);
  audioStarted = true;
}

// Start audio on first user interaction (browser policy)
function tryInitAudio() {
  if (!audioStarted) {
    initAudio();
  }
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
  // Auto-play menu music as soon as audio is available
  if (audioStarted && !musicPlaying && state === 'menu') {
    playTrack('menu');
  }
}
// Try immediately (some browsers allow it)
try { initAudio(); } catch(e) {}
window.addEventListener('keydown', tryInitAudio, { once: false });
canvas.addEventListener('click', tryInitAudio, { once: false });
canvas.addEventListener('touchstart', tryInitAudio, { once: false });

// Note frequencies
const NOTE = {
  E2:82.41,A2:110.00,Bb2:116.54,
  C3:130.81,D3:146.83,Eb3:155.56,E3:164.81,F3:174.61,Fs3:185.00,G3:196.00,Ab3:207.65,A3:220.00,Bb3:233.08,B3:246.94,
  C4:261.63,Cs4:277.18,D4:293.66,Eb4:311.13,E4:329.63,F4:349.23,Fs4:369.99,G4:392.00,Ab4:415.30,A4:440.00,Bb4:466.16,B4:493.88,
  C5:523.25,Cs5:554.37,D5:587.33,Eb5:622.25,E5:659.26,F5:698.46,Fs5:739.99,G5:783.99,Ab5:830.61,A5:880.00,Bb5:932.33,B5:987.77,
  C6:1046.50,R:0
};

// Sound effects
// Create a self-cleaning oscillator+gain pair that disconnects after playing
let activeSFXCount = 0;
const MAX_CONCURRENT_SFX = 20;
function createSFXNode(wave, dest) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = wave;
  o.connect(g); g.connect(dest);
  activeSFXCount++;
  o.onended = () => { try { g.disconnect(); o.disconnect(); } catch(e) {} activeSFXCount--; };
  return { o, g };
}

function playSFX(type) {
  if (!audioCtx || !audioStarted) return;
  if (activeSFXCount >= MAX_CONCURRENT_SFX) return; // prevent audio node buildup
  const now = audioCtx.currentTime;

  switch(type) {
    case 'hit': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.1);
      g.gain.setValueAtTime(0.3, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      o.start(now); o.stop(now + 0.15);
      break;
    }
    case 'hurt': {
      const { o, g } = createSFXNode('sawtooth', sfxGain);
      o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.2);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
      o.start(now); o.stop(now + 0.25);
      break;
    }
    case 'coin': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(NOTE.E5, now);
      o.frequency.setValueAtTime(NOTE.A5, now + 0.08);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o.start(now); o.stop(now + 0.2);
      break;
    }
    case 'dodge': {
      const { o, g } = createSFXNode('sine', sfxGain);
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
      o.start(now); o.stop(now + 0.12);
      break;
    }
    case 'boss_appear': {
      for (let i = 0; i < 4; i++) {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.setValueAtTime([NOTE.C4, NOTE.E4, NOTE.G4, NOTE.C5][i], now + i * 0.12);
        g.gain.setValueAtTime(0.2, now + i * 0.12);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.2);
      }
      break;
    }
    case 'death': {
      for (let i = 0; i < 5; i++) {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.setValueAtTime(300 - i * 40, now + i * 0.15);
        g.gain.setValueAtTime(0.2, now + i * 0.15);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
        o.start(now + i * 0.15); o.stop(now + i * 0.15 + 0.25);
      }
      break;
    }
    case 'victory_jingle': {
      const melody = [NOTE.C5, NOTE.E5, NOTE.G5, NOTE.C6, NOTE.G5, NOTE.C6];
      melody.forEach((f, i) => {
        const { o, g } = createSFXNode('square', sfxGain);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.2, now + i * 0.12);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.12 + 0.15);
        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.2);
      });
      break;
    }
    case 'helper': {
      const { o, g } = createSFXNode('triangle', sfxGain);
      o.frequency.setValueAtTime(NOTE.G4, now);
      o.frequency.setValueAtTime(NOTE.C5, now + 0.08);
      o.frequency.setValueAtTime(NOTE.E5, now + 0.16);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      o.start(now); o.stop(now + 0.3);
      break;
    }
    case 'perfect_dodge': {
      const { o, g } = createSFXNode('sine', sfxGain);
      o.frequency.setValueAtTime(NOTE.C5, now);
      o.frequency.setValueAtTime(NOTE.E5, now + 0.06);
      o.frequency.setValueAtTime(NOTE.G5, now + 0.12);
      o.frequency.setValueAtTime(NOTE.C6, now + 0.18);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      o.start(now); o.stop(now + 0.3);
      break;
    }
    case 'stomp': {
      const { o, g } = createSFXNode('square', sfxGain);
      o.frequency.setValueAtTime(120, now);
      o.frequency.exponentialRampToValueAtTime(50, now + 0.15);
      g.gain.setValueAtTime(0.25, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o.start(now); o.stop(now + 0.2);
      break;
    }
    case 'victory_sweep': {
      // Smooth ascending chime arpeggio that wraps up the arcade music
      const notes = [NOTE.C4, NOTE.E4, NOTE.G4, NOTE.C5, NOTE.E5, NOTE.G5, NOTE.C6];
      notes.forEach((f, i) => {
        const { o, g } = createSFXNode('sine', sfxGain);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.18 - i * 0.02, now + i * 0.1);
        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.35);
        o.start(now + i * 0.1); o.stop(now + i * 0.1 + 0.4);
      });
      // Soft pad underneath
      const { o: pad, g: padG } = createSFXNode('sine', sfxGain);
      pad.frequency.value = NOTE.C4;
      padG.gain.setValueAtTime(0.12, now);
      padG.gain.linearRampToValueAtTime(0.08, now + 0.5);
      padG.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
      pad.start(now); pad.stop(now + 1.0);
      break;
    }
  }
}

// ==========================================
// MUSIC TRACKS - Chiptune style
// ==========================================

// Each track: array of { melody, bass, tempo (BPM) }
// Melody/bass: arrays of [note, duration_in_beats]

const TRACKS = {
  // Menu: Roman saltarello - dramatic minor, Mediterranean ornaments
  menu: {
    tempo: 125,
    melody: [
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],[NOTE.E4,1],
      [NOTE.F4,1],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.C4,1],[NOTE.D4,1],
      [NOTE.E4,1],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,2],[NOTE.R,1],[NOTE.D4,1],
      [NOTE.A4,1],[NOTE.C5,1],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.F4,1],[NOTE.E4,1],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.D4,1],[NOTE.E4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.E3,1],[NOTE.A3,1],[NOTE.D3,2],[NOTE.A3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.D3,2],[NOTE.E3,2],
      [NOTE.A3,1],[NOTE.E3,1],[NOTE.A3,2],[NOTE.F3,2],[NOTE.E3,2],
      [NOTE.D3,2],[NOTE.E3,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Hub (Bar Vanni): warm mandolin arpeggios, relaxed Italian bar
  hub: {
    tempo: 105,
    melody: [
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.E4,0.5],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.B4,0.5],[NOTE.G4,0.5],[NOTE.D4,0.5],[NOTE.G4,1],
      [NOTE.F4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.F4,0.5],[NOTE.C4,0.5],[NOTE.F4,1],
      [NOTE.E4,0.5],[NOTE.Ab4,0.5],[NOTE.B4,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],
      [NOTE.G4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.E4,1],
      [NOTE.F4,0.5],[NOTE.A4,0.5],[NOTE.C5,1],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.E3,2],[NOTE.G3,2],[NOTE.D3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.E3,2],[NOTE.B3,2],
      [NOTE.A3,2],[NOTE.E3,2],[NOTE.G3,2],[NOTE.D3,2],
      [NOTE.F3,2],[NOTE.E3,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'triangle',
    bassWave: 'sine'
  },

  // Level (goon fight): fast tarantella, driving rhythm
  level: {
    tempo: 165,
    melody: [
      [NOTE.A4,0.5],[NOTE.B4,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,1],[NOTE.C5,0.5],[NOTE.D5,0.5],
      [NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.A5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,1],
      [NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,1],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.D5,1],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.B4,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.R,1],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,1],
      [NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],[NOTE.F3,1],
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,1],
      [NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'square',
    bassWave: 'square'
  },

  // Boss: LaFed (rugby rapper) - swaggering rhythm, cocky melody
  boss_lafed: {
    tempo: 150,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.G4,0.5],[NOTE.A4,1],[NOTE.R,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.E4,0.5],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.D5,1],[NOTE.C5,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.E4,1],[NOTE.R,1],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,1],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.E4,1],[NOTE.D4,1],
      [NOTE.E4,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,1],[NOTE.G4,0.5],[NOTE.E4,0.5],
      [NOTE.D4,1],[NOTE.E4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.G3,1],[NOTE.R,0.5],[NOTE.G3,0.5],
      [NOTE.F3,1],[NOTE.R,0.5],[NOTE.F3,0.5],[NOTE.E3,1],[NOTE.R,0.5],[NOTE.E3,0.5],
      [NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.D3,1],[NOTE.R,0.5],[NOTE.D3,0.5],
      [NOTE.E3,1],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.A3,1],[NOTE.R,0.5],[NOTE.A3,0.5],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'square'
  },

  // Boss: Gioacchino (pub brawler) - dark, menacing waltz-like, heavy
  boss_gioacchino: {
    tempo: 140,
    melody: [
      [NOTE.D4,1],[NOTE.F4,1],[NOTE.A4,1],[NOTE.D5,1],[NOTE.Cs5,0.5],[NOTE.D5,0.5],
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.F4,1],
      [NOTE.E4,1],[NOTE.F4,0.5],[NOTE.G4,0.5],[NOTE.A4,1],[NOTE.Bb4,1],
      [NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.D4,2],
      [NOTE.D5,1],[NOTE.Cs5,0.5],[NOTE.D5,0.5],[NOTE.F5,1],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.Cs5,1],[NOTE.A4,1],[NOTE.Bb4,1],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.F4,1],
      [NOTE.E4,1],[NOTE.D4,1],[NOTE.A3,2],
    ],
    bass: [
      [NOTE.D3,2],[NOTE.A3,2],[NOTE.Bb3,2],[NOTE.A3,2],
      [NOTE.G3,2],[NOTE.D3,2],[NOTE.E3,2],[NOTE.A3,2],
      [NOTE.D3,2],[NOTE.F3,2],[NOTE.Bb3,2],[NOTE.A3,2],
      [NOTE.G3,2],[NOTE.A3,2],[NOTE.D3,2],[NOTE.R,2],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Boss: Il Dale (dumb brute) - slow, heavy stomps, simple but crushing
  boss_dale: {
    tempo: 120,
    melody: [
      [NOTE.E4,2],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,2],
      [NOTE.R,1],[NOTE.A3,0.5],[NOTE.E4,0.5],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.A4,2],[NOTE.R,1],[NOTE.A4,0.5],[NOTE.Bb4,0.5],
      [NOTE.A4,1],[NOTE.G4,1],[NOTE.F4,1],[NOTE.E4,1],
      [NOTE.D4,2],[NOTE.R,1],[NOTE.D4,0.5],[NOTE.E4,0.5],
      [NOTE.F4,1],[NOTE.E4,1],[NOTE.D4,1],[NOTE.C4,1],
      [NOTE.E4,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.F4,1],
      [NOTE.E4,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.A3,2],[NOTE.R,2],[NOTE.A3,2],[NOTE.R,2],
      [NOTE.F3,2],[NOTE.R,2],[NOTE.E3,2],[NOTE.R,2],
      [NOTE.D3,2],[NOTE.R,2],[NOTE.D3,2],[NOTE.R,2],
      [NOTE.E3,2],[NOTE.R,2],[NOTE.A3,2],[NOTE.R,2],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Boss: Ciccio Ruver (fiery pizzaiolo) - fast, fiery tarantella, aggressive
  boss_ciccio: {
    tempo: 180,
    melody: [
      [NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.A5,0.5],[NOTE.E5,0.5],[NOTE.C5,0.5],
      [NOTE.D5,0.5],[NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.F5,0.5],[NOTE.D5,0.5],[NOTE.A4,0.5],
      [NOTE.E5,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,1],
      [NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,0.5],[NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],[NOTE.E5,1],[NOTE.R,1],
      [NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.B4,0.5],[NOTE.A4,0.5],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.A5,1],[NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
      [NOTE.E4,1],[NOTE.A4,1],[NOTE.R,1],[NOTE.R,1],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],
      [NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],
      [NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.A3,0.5],[NOTE.E3,1],
      [NOTE.A3,0.5],[NOTE.E3,0.5],[NOTE.F3,0.5],[NOTE.C3,0.5],[NOTE.D3,0.5],[NOTE.A3,0.5],
      [NOTE.A3,1],[NOTE.E3,1],[NOTE.A3,1],[NOTE.D3,1],
      [NOTE.F3,1],[NOTE.E3,1],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'square'
  },

  // Boss: Pisellino (final boss) - chaotic, manic, shifting tempo feel, unhinged
  boss_pisellino: {
    tempo: 185,
    melody: [
      [NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],
      [NOTE.A4,1],[NOTE.R,0.5],[NOTE.C4,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],
      [NOTE.B4,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.Ab4,0.5],[NOTE.B4,0.5],
      [NOTE.C5,1],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],[NOTE.C5,0.5],
      [NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.Eb5,0.5],[NOTE.E5,0.5],[NOTE.B4,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],
      [NOTE.A4,1],[NOTE.R,0.5],[NOTE.C4,0.5],[NOTE.E4,0.5],[NOTE.A4,0.5],
      [NOTE.B4,1],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],[NOTE.B4,0.5],
      [NOTE.A4,1],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.A4,0.5],
    ],
    bass: [
      [NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],
      [NOTE.F3,0.5],[NOTE.R,0.5],[NOTE.F3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A3,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'sawtooth'
  },

  // LaFed buildup: cocky swagger, rhythmic hip-hop drums feel
  boss_buildup_0: {
    tempo: 90,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.R,1.5],[NOTE.G4,0.5],[NOTE.R,0.5],
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.A4,1],[NOTE.R,1],[NOTE.G4,0.5],[NOTE.E4,0.5],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.Bb4,1],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.E4,0.5],[NOTE.A4,2],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.G3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A2,1],[NOTE.R,1],[NOTE.E3,1],[NOTE.R,1],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.A2,1],[NOTE.R,1],
    ],
    melodyWave: 'square',
    bassWave: 'square'
  },

  // Gioacchino buildup: dark prison march, heavy stomps
  boss_buildup_1: {
    tempo: 70,
    melody: [
      [NOTE.D4,2],[NOTE.R,2],[NOTE.D4,1],[NOTE.F4,1],[NOTE.R,2],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.Bb3,1],[NOTE.A3,1],[NOTE.R,2],[NOTE.D4,2],
      [NOTE.F4,1],[NOTE.E4,0.5],[NOTE.D4,0.5],[NOTE.Cs4,2],[NOTE.D4,2],
      [NOTE.A3,1],[NOTE.D4,1],[NOTE.F4,1],[NOTE.A4,1],[NOTE.R,2],[NOTE.D4,2],
    ],
    bass: [
      [NOTE.D3,2],[NOTE.R,2],[NOTE.D3,2],[NOTE.R,2],
      [NOTE.A2,2],[NOTE.R,2],[NOTE.D3,1],[NOTE.R,1],[NOTE.D3,1],[NOTE.R,1],
      [NOTE.D3,1],[NOTE.R,0.5],[NOTE.D3,0.5],[NOTE.R,1],[NOTE.A2,1],[NOTE.D3,1],[NOTE.R,1],
      [NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.D3,0.5],[NOTE.R,0.5],[NOTE.A2,1],[NOTE.D3,1],[NOTE.R,2],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Dale buildup: exotic capoeira percussion, rhythmic and tense
  boss_buildup_2: {
    tempo: 80,
    melody: [
      [NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.R,0.5],[NOTE.D4,0.5],[NOTE.R,0.5],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,1],
      [NOTE.A4,0.5],[NOTE.R,0.5],[NOTE.G4,0.5],[NOTE.F4,0.5],[NOTE.E4,1],[NOTE.R,1],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.A4,1],[NOTE.Ab4,0.5],[NOTE.A4,0.5],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,1],
    ],
    melodyWave: 'triangle',
    bassWave: 'square'
  },

  // Ciccio buildup: furnace inferno, rising heat, heavy tremolo
  boss_buildup_3: {
    tempo: 95,
    melody: [
      [NOTE.A3,1],[NOTE.R,1],[NOTE.A3,0.5],[NOTE.Bb3,0.5],[NOTE.A3,0.5],[NOTE.R,0.5],
      [NOTE.C4,1],[NOTE.R,1],[NOTE.C4,0.5],[NOTE.D4,0.5],[NOTE.C4,0.5],[NOTE.R,0.5],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.E4,1],[NOTE.A4,1],
    ],
    bass: [
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],
      [NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],
      [NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,0.5],[NOTE.E3,0.5],[NOTE.A2,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'sawtooth'
  },

  // Pisellino buildup: manic chaos, unhinged tritones, building dread
  boss_buildup_4: {
    tempo: 85,
    melody: [
      [NOTE.A3,2],[NOTE.R,2],[NOTE.Bb3,1],[NOTE.A3,1],[NOTE.R,2],
      [NOTE.E4,1],[NOTE.R,1],[NOTE.F4,1],[NOTE.E4,0.5],[NOTE.Eb4,0.5],[NOTE.E4,2],
      [NOTE.A3,1],[NOTE.R,1],[NOTE.Eb4,2],[NOTE.R,1],[NOTE.A3,1],
      [NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.E4,0.5],[NOTE.F4,0.5],[NOTE.A4,2],[NOTE.Bb4,1],[NOTE.A4,1],
    ],
    bass: [
      [NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.E3,1],[NOTE.R,1],[NOTE.E3,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.A2,1],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,1],[NOTE.E3,1],[NOTE.A2,1],[NOTE.R,1],[NOTE.A2,1],[NOTE.R,1],
      [NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.A2,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.E3,0.5],[NOTE.R,0.5],[NOTE.A2,1],[NOTE.E3,1],
    ],
    melodyWave: 'sawtooth',
    bassWave: 'triangle'
  },

  // Victory: triumphant Roman fanfare, major key celebration
  victory: {
    tempo: 140,
    melody: [
      [NOTE.C5,1],[NOTE.E5,1],[NOTE.G5,1],[NOTE.C6,2],
      [NOTE.B5,0.5],[NOTE.A5,0.5],[NOTE.G5,1],[NOTE.E5,1],
      [NOTE.F5,1],[NOTE.G5,1],[NOTE.A5,1],[NOTE.G5,1],
      [NOTE.E5,1],[NOTE.C5,1],[NOTE.D5,1],[NOTE.E5,1],
      [NOTE.C5,1],[NOTE.E5,1],[NOTE.G5,1],[NOTE.C6,1],
      [NOTE.A5,1],[NOTE.G5,1],[NOTE.E5,1],[NOTE.C5,1],
      [NOTE.D5,1],[NOTE.E5,1],[NOTE.G5,2],
      [NOTE.C5,2],[NOTE.R,2],
    ],
    bass: [
      [NOTE.C3,2],[NOTE.G3,2],[NOTE.C3,2],[NOTE.E3,2],
      [NOTE.F3,2],[NOTE.C3,2],[NOTE.G3,2],[NOTE.C3,2],
      [NOTE.C3,2],[NOTE.G3,2],[NOTE.A3,2],[NOTE.E3,2],
      [NOTE.F3,2],[NOTE.G3,2],[NOTE.C3,4],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Game over: somber Roman lament
  gameover: {
    tempo: 75,
    melody: [
      [NOTE.A4,2],[NOTE.Ab4,1],[NOTE.A4,1],[NOTE.G4,2],[NOTE.F4,2],
      [NOTE.E4,2],[NOTE.D4,2],[NOTE.C4,2],[NOTE.D4,1],[NOTE.E4,1],
      [NOTE.A3,4],[NOTE.R,4],
    ],
    bass: [
      [NOTE.A3,4],[NOTE.F3,4],[NOTE.D3,4],[NOTE.E3,2],[NOTE.A3,2],
      [NOTE.R,4],
    ],
    melodyWave: 'triangle',
    bassWave: 'sine'
  },

  // Sabi mode: cute, warm, playful Animal Crossing / Stardew Valley vibe
  sabi: {
    tempo: 110,
    melody: [
      // Playful C major arpeggios — bouncy and cheerful
      [NOTE.C5,0.5],[NOTE.E5,0.5],[NOTE.G5,0.5],[NOTE.C6,0.5],
      [NOTE.B5,0.5],[NOTE.G5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],
      [NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.C6,0.5],[NOTE.A5,0.5],
      [NOTE.G5,1],[NOTE.E5,0.5],[NOTE.C5,0.5],
      [NOTE.D5,0.5],[NOTE.F5,0.5],[NOTE.A5,0.5],[NOTE.G5,0.5],
      [NOTE.E5,0.5],[NOTE.C5,0.5],[NOTE.D5,0.5],[NOTE.E5,0.5],
      [NOTE.C5,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.B4,0.5],
      [NOTE.C5,1],[NOTE.E5,0.5],[NOTE.G5,0.5],
    ],
    bass: [
      // Gentle bouncy bass
      [NOTE.C3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
      [NOTE.E3,1],[NOTE.G3,0.5],[NOTE.E3,0.5],
      [NOTE.F3,1],[NOTE.C3,0.5],[NOTE.F3,0.5],
      [NOTE.G3,1],[NOTE.C3,0.5],[NOTE.G3,0.5],
      [NOTE.A3,1],[NOTE.E3,0.5],[NOTE.A3,0.5],
      [NOTE.F3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
      [NOTE.D3,1],[NOTE.G3,0.5],[NOTE.D3,0.5],
      [NOTE.C3,1],[NOTE.G3,0.5],[NOTE.C3,0.5],
    ],
    melodyWave: 'square',
    bassWave: 'triangle'
  },

  // Casino (Bingo degli Ubaldi): smoky lounge jazz, minor key, cool and sleazy
  casino: {
    tempo: 92,
    melody: [
      // Smoky jazz melody — Dm7 / Am7 / Bb / A7 feel
      [NOTE.D5,1],[NOTE.R,0.5],[NOTE.F5,0.5],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.A4,0.5],
      [NOTE.Bb4,1],[NOTE.A4,0.5],[NOTE.G4,0.5],[NOTE.A4,1],[NOTE.R,1],
      [NOTE.D5,0.5],[NOTE.E5,0.5],[NOTE.F5,1],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.Cs4,0.5],[NOTE.D4,0.5],
      [NOTE.A4,1.5],[NOTE.R,0.5],[NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],
      [NOTE.F5,1],[NOTE.E5,0.5],[NOTE.D5,0.5],[NOTE.C5,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,0.5],
      [NOTE.A4,1],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.G4,1],[NOTE.R,1],
      [NOTE.D4,0.5],[NOTE.F4,0.5],[NOTE.A4,0.5],[NOTE.D5,0.5],[NOTE.Cs5,0.5],[NOTE.D5,0.5],[NOTE.A4,1],
      [NOTE.G4,0.5],[NOTE.A4,0.5],[NOTE.Bb4,0.5],[NOTE.A4,0.5],[NOTE.D4,1],[NOTE.R,1],
    ],
    bass: [
      // Walking bass line — jazzy, steady
      [NOTE.D3,1],[NOTE.F3,0.5],[NOTE.A3,0.5],[NOTE.D3,1],[NOTE.A3,1],
      [NOTE.Bb3,1],[NOTE.F3,0.5],[NOTE.Bb3,0.5],[NOTE.A3,1],[NOTE.E3,1],
      [NOTE.D3,1],[NOTE.E3,0.5],[NOTE.F3,0.5],[NOTE.G3,1],[NOTE.A3,1],
      [NOTE.Bb3,0.5],[NOTE.A3,0.5],[NOTE.G3,0.5],[NOTE.F3,0.5],[NOTE.E3,1],[NOTE.A3,1],
      [NOTE.D3,1],[NOTE.A3,0.5],[NOTE.D3,0.5],[NOTE.F3,1],[NOTE.A3,1],
      [NOTE.Bb3,1],[NOTE.G3,0.5],[NOTE.E3,0.5],[NOTE.A3,1],[NOTE.D3,1],
      [NOTE.G3,1],[NOTE.F3,0.5],[NOTE.E3,0.5],[NOTE.D3,1],[NOTE.A3,1],
      [NOTE.Bb3,0.5],[NOTE.A3,0.5],[NOTE.G3,0.5],[NOTE.F3,0.5],[NOTE.D3,1],[NOTE.R,1],
    ],
    melodyWave: 'triangle',
    bassWave: 'sine'
  }
};

// Music player
let melodyTimeout = null;
let bassTimeout = null;
let activeMelodyOsc = null;
let activeBassOsc = null;
let activeMelodyGain = null;
let activeBassGain = null;
let currentTrackName = '';
let musicHeartbeat = 0; // frames since last melody note scheduled
let lastMusicCheckTime = 0;
let musicGeneration = 0; // incremented on each playTrack call to kill old scheduler chains

function stopMusic() {
  musicPlaying = false;
  currentTrackName = '';
  clearTimeout(melodyTimeout);
  clearTimeout(bassTimeout);
  try {
    if (activeMelodyOsc) { activeMelodyOsc.onended = null; activeMelodyOsc.stop(); activeMelodyOsc.disconnect(); activeMelodyOsc = null; }
    if (activeBassOsc) { activeBassOsc.onended = null; activeBassOsc.stop(); activeBassOsc.disconnect(); activeBassOsc = null; }
    if (activeMelodyGain) { activeMelodyGain.disconnect(); activeMelodyGain = null; }
    if (activeBassGain) { activeBassGain.disconnect(); activeBassGain = null; }
  } catch(e) {}
}

function playTrack(name) {
  if (!audioCtx || !audioStarted || !musicEnabled) return;
  // If same track and playing, check heartbeat for stalled music
  if (currentTrackName === name && musicPlaying) {
    musicHeartbeat++;
    if (musicHeartbeat > 300) { // ~5 seconds without a note = stalled
      musicPlaying = false; // force restart
    } else {
      return;
    }
  }

  stopMusic();
  const track = TRACKS[name];
  if (!track) return;

  currentTrackName = name;
  musicPlaying = true;
  musicGeneration++; // kill any old scheduler chains
  const gen = musicGeneration;

  const beatLen = 60 / track.tempo;

  // Play melody voice
  function scheduleMelody(noteIndex) {
    if (gen !== musicGeneration) return; // old chain from previous playTrack — die
    if (!musicPlaying || currentTrackName !== name) return;
    if (noteIndex >= track.melody.length) noteIndex = 0;
    musicHeartbeat = 0; // reset heartbeat on each note

    const [freq, dur] = track.melody[noteIndex];
    const durMs = dur * beatLen * 1000;

    try {
      if (activeMelodyOsc) { activeMelodyOsc.stop(); activeMelodyOsc.disconnect(); }
      if (activeMelodyGain) { activeMelodyGain.disconnect(); }
    } catch(e) {}

    if (freq > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = track.melodyWave || 'square';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime + dur * beatLen * 0.3);
      gain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + dur * beatLen * 0.95);
      osc.connect(gain);
      gain.connect(musicGain);
      osc.start();
      osc.onended = () => { try { gain.disconnect(); osc.disconnect(); } catch(e) {} };
      activeMelodyOsc = osc;
      activeMelodyGain = gain;
      setTimeout(() => { try { osc.stop(); } catch(e) {} }, durMs + 50);
    }

    melodyTimeout = setTimeout(() => scheduleMelody(noteIndex + 1), durMs);
  }

  // Play bass voice
  function scheduleBass(noteIndex) {
    if (gen !== musicGeneration) return; // old chain from previous playTrack — die
    if (!musicPlaying || currentTrackName !== name) return;
    if (noteIndex >= track.bass.length) noteIndex = 0;

    const [freq, dur] = track.bass[noteIndex];
    const durMs = dur * beatLen * 1000;

    try {
      if (activeBassOsc) { activeBassOsc.stop(); activeBassOsc.disconnect(); }
      if (activeBassGain) { activeBassGain.disconnect(); }
    } catch(e) {}

    if (freq > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = track.bassWave || 'triangle';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.14, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + dur * beatLen * 0.9);
      osc.connect(gain);
      gain.connect(musicGain);
      osc.start();
      osc.onended = () => { try { gain.disconnect(); osc.disconnect(); } catch(e) {} };
      activeBassOsc = osc;
      activeBassGain = gain;
      setTimeout(() => { try { osc.stop(); } catch(e) {} }, durMs + 50);
    }

    bassTimeout = setTimeout(() => scheduleBass(noteIndex + 1), durMs);
  }

  scheduleMelody(0);
  scheduleBass(0);
}

// Toggle music with M key
window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    musicEnabled = !musicEnabled;
    if (!musicEnabled) stopMusic();
  }
});

// ==========================================
// GAME STATE
// ==========================================
let state = 'menu'; // menu, difficultySelect, tutorial, weaponSelect, hub, dialogue, level, shop, upgrade, casino, gameover, victory
let difficulty = 'medium'; // 'easy', 'medium', 'hard'
const DIFF_HP = { easy: 0.61, medium: 0.76, hard: 0.84 };
const DIFF_DMG = { easy: 0.54, medium: 0.765, hard: 0.84 };
let tutorialStep = 0;
let tutorialDummy = null;
let tutorialTimer = 0;
let firstTime = true;
let cheatBuffer = '';
var showCredits = false;
let codeInput = '';
let freestylePlaying = false;
const freestyleOverlay = document.getElementById('freestyle-overlay');
const freestyleVideo = document.getElementById('freestyle-video');

function startFreestyleVideo() {
  freestylePlaying = true;
  freestyleOverlay.classList.add('active');
  freestyleVideo.currentTime = 0;
  freestyleVideo.play();
  stopMusic();
}

function stopFreestyleVideo() {
  freestylePlaying = false;
  freestyleOverlay.classList.remove('active');
  freestyleVideo.pause();
  freestyleVideo.currentTime = 0;
}

// Close video on ESC
document.addEventListener('keydown', function(e) {
  if (e.code === 'Escape' && freestylePlaying) {
    stopFreestyleVideo();
    e.preventDefault();
  }
});

// When video ends, return to game
freestyleVideo.addEventListener('ended', function() {
  stopFreestyleVideo();
});
let currentLevel = 0;
let coins = 0;
let lives = 3;
let totalKills = 0;
let dialogueLines = [];
let dialogueIndex = 0;
let dialogueCallback = null;
let screenShake = 0;
let screenFlash = 0;
let flashColor = '#fff';
let gameTime = 0;
let helperCooldowns = [0, 0, 0, 0];
let bossDefeated = [false, false, false, false, false];
let particles = [];
let projectiles = [];
let goons = [];
let boss = null;
let bossPhase = 0;
let reginaActive = false;
let regina = null;
let mariusoActive = false;
let mariuso = null;

// Sabi mode state
let sabiTimer = 0;
let sabiCicca = null;
let sabiSabi = null;
let sabiTotti = null;
let sabiMessages = [];
let sabiPreviousState = 'menu';
let sabiDialogueCount = 0;
let sabiSwordUnlocked = false;

// Upgrade system
let upgradeChoices = []; // 3 choices shown after level victory
let levelScore = 0;
let stylePoints = 0;
let levelDamageTaken = 0;
let levelStartTime = 0;
let lastLevelGrade = '';
let lastLevelBreakdown = null;

const UPGRADE_POOL = [
  // Statistiche — each has a unique accent color
  { name: '+15% Danno', cat: 'stat', desc: 'Tutti gli attacchi fanno 15% danno in piu\'', effect: 'dmg15', icon: '\u2694', color: '#f44336' },
  { name: '+20 HP Max', cat: 'stat', desc: 'Aumenta la vita massima di 20', effect: 'hp20', icon: '\u2665', color: '#e91e63' },
  { name: '+20 Stamina', cat: 'stat', desc: 'Aumenta la stamina massima di 20', effect: 'st20', icon: '\u2605', color: '#ffc107' },
  { name: '+25% Regen Stamina', cat: 'stat', desc: 'La stamina si ricarica il 25% piu\' veloce', effect: 'stregen', icon: '\u21BB', color: '#8bc34a' },
  { name: '+10% Velocita\'', cat: 'stat', desc: 'Ti muovi il 10% piu\' veloce', effect: 'spd10', icon: '\u00BB', color: '#00bcd4' },
  { name: '+15% Critico', cat: 'stat', desc: 'Tutte le armi +15% chance critico', effect: 'crit15', icon: '\u25C6', color: '#ff9800' },
  { name: 'Pelle Dura', cat: 'stat', desc: 'Ricevi 15% danno in meno', effect: 'armor15', icon: '\u25A0', color: '#607d8b' },
  { name: 'Colpo Pesante', cat: 'stat', desc: '+25% danno poise, stagger piu\' veloce', effect: 'poise25', icon: '\u25B2', color: '#9c27b0' },
  { name: 'Combo Extra', cat: 'mossa', desc: '+1 colpo a tutte le combo', effect: 'comboext', icon: '\u221E', color: '#e040fb' },
  // Potenziamenti Ultra — attivi solo durante modalita' Ultra (Q)
  { name: 'Ultra Fuoco', cat: 'mod', desc: 'Ultra: ogni colpo brucia il nemico (3s)', effect: 'ultraFire', icon: '\u2666', color: '#ff5722' },
  { name: 'Ultra Ghiaccio', cat: 'mod', desc: 'Ultra: ogni colpo rallenta il nemico del 30%', effect: 'ultraIce', icon: '\u2733', color: '#4fc3f7' },
  { name: 'Ultra Fulmine', cat: 'mod', desc: 'Ultra: fulmina un nemico vicino ad ogni colpo', effect: 'ultraShock', icon: '\u2191', color: '#ffeb3b' },
  { name: 'Ultra Vampiro', cat: 'mod', desc: 'Ultra: cura 8% danno inflitto, -10% ricarica Q', effect: 'ultraVampire', icon: '\u2020', color: '#b71c1c' },
];
let levelTimer = 0;
let comboCount = 0;
let comboTimer = 0;
let damageNumbers = [];
let selectedHelper = -1;
let hitstopFrames = 0;
let dodgeCounter = 0;
let phaseTransitionTimer = 0;
let phaseTransitionText = '';
let phaseTransitionColor = '#e94560';
let waveClearTimer = 0;
let currentWave = 0;
let waveBreatherTimer = 0;
let waveConfig = []; // array of enemy counts per wave

// ==========================================
// PLAYER
// ==========================================
const player = {
  x: 100, y: 400, w: 36, h: 56,
  vx: 0, vy: 0,
  hp: 120, maxHp: 120,
  stamina: 100, maxStamina: 100,
  speed: 4.0,
  weapon: 0, // always 0 — weapons[0] is current weapon
  facing: 1, // 1 right, -1 left
  attacking: false,
  attackTimer: 0,
  attackCooldown: 0,
  dodging: false,
  dodgeTimer: 0,
  dodgeCooldown: 0,
  invincible: 0,
  grounded: true,
  animFrame: 0,
  animTimer: 0,
  stunTimer: 0,
  speedBoost: 0,
  dead: false,
  // Combo chain state
  comboStep: 0,        // current hit in chain (0 = not attacking)
  comboWindowTimer: 0, // frames left in combo window to chain next hit
  endLagTimer: 0,      // frames of end-lag after combo finishes/drops
  attackBuffered: false,// input buffer for next combo hit
  attackActiveTimer: 0, // frames left of active hitbox
  comboChainCount: 0,  // number of full combo chains completed without getting hit (for coin bonus)
  jumpAttacking: false, // aerial attack flag
  // Stamina
  staminaRegenDelay: 0, // frames until stamina starts regenerating
  exhaustedTimer: 0, // can't attack while exhausted
  sameTargetHits: 0, // same-target damage penalty
  sameTargetTimer: 0, // frames since last hit on same target
  lastHitTarget: null,
  reloadTimer: 0, // ammo reload countdown for ranged weapons
  // Combo counter (scoring)
  comboHitCount: 0,
  comboHitTimer: 0,
  scoreMultiplier: 1,
  // Upgrades
  upgrades: [],
  // Ultra system
  ultraCharge: 0, ultraMaxCharge: 100, ultraActive: false,
  ultraTimer: 0, ultraDuration: 300, ultraAvailable: false
};

// Weapons — each has a unique feel via combo count, poise damage, and a special mechanic
// comboHits: number of hits in combo chain
// poise: poise damage per hit
// activeFrames: frames the hitbox is out per hit
// comboWindow: frames after active ends where you can chain
// endLag: frames of end-lag after last hit (dropped combo = 8-12)
// special: unique mechanic identifier

// 4 starter weapons — player picks one at game start
const starterWeapons = [
  { name: 'Sanpietrino',    damage: 14, range: 50,  speed: 8,  crit: 15,
    comboHits: 4, poise: 8, activeFrames: 6, comboWindow: 13, endLag: 13,
    special: 'critCombo', desc: 'Veloce, 4 colpi. Crit cresce nel combo.',
    color: '#9e9e9e', icon: 'S' },
  { name: 'Cacciavite',     damage: 19, range: 48,  speed: 9,  crit: 12,
    comboHits: 3, poise: 8, activeFrames: 7, comboWindow: 13, endLag: 15,
    special: 'bleed', desc: 'Bilanciato. Sanguinamento. Ultra: potenziato.',
    color: '#ff8a65', icon: 'C' },
  { name: 'Spranga',        damage: 24, range: 65,  speed: 13, crit: 7,
    comboHits: 3, poise: 14, activeFrames: 8, comboWindow: 13, endLag: 20,
    special: 'reachControl', desc: 'Pesante, lungo raggio. Colpo doppio.',
    color: '#795548', icon: 'P' },
  { name: 'Fionda',         damage: 12, range: 180, speed: 16, crit: 8,
    comboHits: 3, poise: 2, activeFrames: 6, comboWindow: 10, endLag: 20,
    special: 'pierce', desc: 'Ranged. 3o colpo perfora (Ultra).', ranged: true,
    color: '#a1887f', icon: 'F', maxAmmo: 4, reloadFrames: 90 }
];

// Rare weapons (from gacha)
const rareWeapons = [
  { name: 'Machete',        damage: 24, range: 55,  speed: 12, crit: 10,
    comboHits: 3, poise: 12, activeFrames: 7, comboWindow: 16, endLag: 20,
    special: 'executioner', desc: 'Ultra: 2x danno su nemici sotto 25% HP.',
    color: '#b0bec5', icon: 'M' },
  { name: 'Catena',         damage: 20, range: 85,  speed: 18, crit: 8,
    comboHits: 3, poise: 15, activeFrames: 10, comboWindow: 18, endLag: 22,
    special: 'crowdPull', desc: 'Sempre AoE. Ultra: attira nemici vicini.',
    color: '#757575', icon: 'K' },
  { name: 'Bottiglia Rotta',damage: 20, range: 38,  speed: 6,  crit: 25,
    comboHits: 3, poise: 6, activeFrames: 5, comboWindow: 12, endLag: 18,
    special: 'bleed', desc: 'Rapidissima, alta crit. Ultra: sanguinamento.',
    color: '#4caf50', icon: 'B' }
];

// Legendary weapons (from gacha, very rare)
const legendaryWeapons = [
  { name: 'La Lupa',        damage: 38, range: 65,  speed: 10, crit: 30,
    comboHits: 3, poise: 18, activeFrames: 8, comboWindow: 16, endLag: 20,
    special: 'legendaryShockwave', desc: 'Ultra: onda d\'urto devastante.',
    color: '#ffd700', icon: 'L' },
  { name: 'Pistola del Nonno', damage: 30, range: 300, speed: 20, crit: 20,
    comboHits: 3, poise: 5, activeFrames: 6, comboWindow: 14, endLag: 20,
    special: 'pierce', desc: 'Ranged leggendaria. Tutti i colpi perforano.', ranged: true,
    color: '#333', icon: 'G', maxAmmo: 4, reloadFrames: 75 }
];

const manganelloWeapon = {
  name: 'Manganello', damage: 21, range: 55, speed: 9, crit: 14,
  comboHits: 3, poise: 14, activeFrames: 7, comboWindow: 14, endLag: 17,
  special: 'interrogation',
  desc: 'Arma di Michele. Ultra: rallenta tutti i nemici.',
  color: '#263238', icon: 'R'
};

// Active weapon — single-element array, weapons[0] is always current weapon
let weapons = [starterWeapons[0]]; // default, replaced at weapon select

// Weapon selection state
let weaponSelectIndex = 0;
let weaponSelectReady = false;
let weaponSelectTimer = 0;
let helperSelectIndex = 0;
let helperSelectReady = false;
let helperSelectTimer = 0;

// Weapon upgrade tier (0-3)
let weaponTier = 0;
const WEAPON_UPGRADE_COSTS = [95, 190, 380];

// Player stat upgrade tiers (0-3 each), purchased in shop tab 3
let healthTier = 0, dodgeTier = 0, speedTier = 0;
const STAT_UPGRADE_COSTS = [65, 160, 320];
const HP_VALUES = [120, 140, 165, 195];
const JUMP_FORCES = [-13.0, -14.2, -15.4, -16.5];
const DODGE_COOLDOWNS = [48, 40, 33, 26];
const SPEED_VALUES = [4.0, 4.4, 4.8, 5.3];

// Shop tab: 0 = Potenzia Arma, 1 = Potenzia Helper, 2 = La Ruota, 3 = Potenzia Stats
let shopTab = 0;

// Gacha state
let gachaSpinning = false;
let gachaSpinTimer = 0;
let gachaResult = null;
let gachaResultTimer = 0;
const GACHA_COST = 40;

const gachaJokes = [
  '"Aho, ma che te credevi? T\'hanno fregato!"',
  '"Niente, come la Roma in Champions."',
  '"Vanni: \'Riprova, va\'... tanto li sordi so\' mia.\'"',
  '"Hai vinto... \'na bella presa per culo."',
  '"Gira gira... e niente. Come er 64 ar capolinea."',
  '"Ma che giri a vuoto come \'na lavatrice!"',
  '"Vanni se sta a ride... de te."',
  '"Hai beccato l\'aria de Roma Nord. Congratulazioni."',
  '"Come dice mi nonna: chi nun risica, perde lo stesso."',
  '"Jackpot de niente! Come trovà posto ar Pigneto er sabato."'
];

// ==========================================
// CASINO — Bingo degli Ubaldi
// ==========================================
let casinoTab = 0; // 0=poker, 1=slots
let casinoFirstVisit = true;

// Poker state
let pokerPhase = 'idle'; // 'idle' | 'hold' | 'redraw' | 'result'
let pokerRedrawAnim = 0;
let pokerDeck = [];
let pokerHand = [null, null, null, null, null];
let pokerHeld = [false, false, false, false, false];
let pokerBet = 5;
let pokerResult = '';
let pokerWinAmount = 0;
let pokerResultTimer = 0;
let pokerDealAnim = 0;
let pokerNpcComment = '';
let pokerNpcCommentTimer = 0;

// Slot state
let slotPhase = 'idle'; // 'idle' | 'spinning' | 'result'
let slotReels = [0, 0, 0];
let slotTargetReels = [0, 0, 0];
let slotSpinTimers = [0, 0, 0];
let slotBet = 5;
let slotResult = '';
let slotWinAmount = 0;
let slotResultTimer = 0;
let slotNpcComment = '';
let slotNpcCommentTimer = 0;

// Casino dialogue
let casinoDialogueActive = false;
let casinoDialogueLines = [];
let casinoDialogueIndex = 0;
let casinoDialogueCooldown = 0;

// Card constants
const CARD_SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
const CARD_RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const SUIT_SYMBOLS = { hearts: '\u2665', diamonds: '\u2666', clubs: '\u2663', spades: '\u2660' };
const SUIT_COLORS = { hearts: '#e94560', diamonds: '#e94560', clubs: '#333', spades: '#333' };

// Poker payouts (Jacks or Better) — ~90% EV with optimal play
const POKER_PAYOUTS = {
  'Royal Flush': 250,
  'Straight Flush': 50,
  'Four of a Kind': 25,
  'Full House': 8,
  'Flush': 5,
  'Straight': 4,
  'Three of a Kind': 3,
  'Two Pair': 2,
  'Jacks or Better': 1,
  'Nothing': 0
};

// Slot symbols and payouts
const SLOT_SYMBOLS = [
  { name: 'Cuore', symbol: '\u2665', color: '#e94560' },
  { name: 'Stella', symbol: '\u2605', color: '#ffd700' },
  { name: 'Sette', symbol: '7', color: '#4caf50' },
  { name: 'Nota', symbol: '\u266B', color: '#9c27b0' },
  { name: 'Soldi', symbol: '$', color: '#ff9800' },
  { name: 'Casa', symbol: '\u2302', color: '#2196f3' },
  { name: 'Niente', symbol: '-', color: '#666' }
];
// Slot payouts — EV = (111 + 18*11) / 343 = 309/343 = ~0.901
const SLOT_PAYOUTS_3 = [38, 25, 18, 14, 10, 6, 0]; // 3-of-a-kind multipliers
const SLOT_PAYOUTS_2 = [5, 3, 2, 1, 0, 0, 0]; // pair multipliers (best symbols only)

// Bet limits
const POKER_BET_MIN = 5, POKER_BET_MAX = 100, POKER_BET_STEP = 5;
const SLOT_BET_MIN = 5, SLOT_BET_MAX = 50, SLOT_BET_STEP = 5;


const helpers = [
  { name: 'Pirox', desc: 'STUN tutti 2s', cooldown: 720, color: '#e040fb', icon: 'P', tier: 0, unlocked: false, unlockCost: 40,
    tiers: [
      { cost: 65, desc: 'Stun +50%, area piu\' grande' },
      { cost: 125, desc: 'Spacca poise: 3x danno poise' },
      { cost: 250, desc: 'Raduno: nemici stunnati -30% poise' }
    ]},
  { name: 'Tommy', desc: 'Coltellata al boss', cooldown: 900, color: '#ff6e40', icon: 'T', tier: 0, unlocked: false, unlockCost: 40,
    tiers: [
      { cost: 65, desc: 'Danno +50%, attacca piu\' spesso' },
      { cost: 125, desc: 'Combo assist: attacca staggerati' },
      { cost: 250, desc: 'Grido: +30% danno per 4s ogni 30s' }
    ]},
  { name: 'Cicca', desc: 'Cura +35 HP', cooldown: 540, color: '#ff8a65', icon: 'C', tier: 0, unlocked: false, unlockCost: 40,
    tiers: [
      { cost: 65, desc: 'Cura +50%' },
      { cost: 125, desc: 'Buff attacco: +20% danno per 5s' },
      { cost: 250, desc: 'Revive: auto-cura se muori (1x)' }
    ]},
  { name: 'Il Mostro', desc: 'Speed x2 8sec', cooldown: 720, color: '#76ff03', icon: 'M', tier: 0, unlocked: false, unlockCost: 40,
    tiers: [
      { cost: 65, desc: 'Durata speed +50%' },
      { cost: 125, desc: 'Speed +20% velocita\' attacco' },
      { cost: 250, desc: 'Scia: lasci danno quando boost' }
    ]},
];
let helperReviveUsed = false; // Cicca tier 3 one-time per level
let warCryTimer = 0; // Tommy tier 3 buff timer
let warCryCooldown = 0; // Tommy tier 3 cooldown

// ==========================================
// LEVEL DATA
// ==========================================
const levels = [
  {
    name: 'Via Plava',
    boss: 'LaFed',
    bossColor: '#ffd54f',
    bossHp: 300,
    subtitle: 'Il rugbista narcisista',
    bgColor: '#1a1a30',
    groundColor: '#3a3a4a',
    goonCount: 3,
    music: 'level1',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 1.25, spranga: 0.85, fionda: 0.85 },
    bossLines: [
      '"Ao\', ma lo sai chi so\' io?"',
      '"Sono pazzo... sono pazzo di te..."',
      '"Sei la mia musa e per questo che resto!"',
      '"Preparate Conte, che te asfarto!"'
    ],
    defeatLines: [
      '"No... i miei capelli... il mio gel..."',
      '"Aspetta che me rifaccio la riga..."'
    ]
  },
  {
    name: 'Down Under Pub',
    boss: 'Gioacchino',
    bossColor: '#6d4c41',
    bossHp: 440,
    subtitle: 'Il bastone e la sorella',
    bgColor: '#1b2631',
    groundColor: '#2c3e50',
    goonCount: 4,
    music: 'level2',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 0.85, spranga: 1.3, fionda: 1.0 },
    bossLines: [
      '"Ao\' Conte, in gabbia c\'ho imparato a mena\'!"',
      '"REGINAAAA! Famme \'n pezzo de carneeee!"',
      '"Te faccio vede\' come se gioca ar quartiere!"',
      '"So\' stato in gabbia 3 anni, nun me fai paura!"'
    ],
    defeatLines: [
      '"Regina... me rimanneno in gabbia..."',
      '"Torno ar pub a beve\'... o forse in cella..."'
    ]
  },
  {
    name: 'Piazza Bainsizza',
    boss: 'Il Dale',
    bossColor: '#90a4ae',
    bossHp: 530,
    subtitle: 'La capoeira de Piazza Bainsizza',
    bgColor: '#263238',
    groundColor: '#37474f',
    goonCount: 5,
    music: 'level3',
    weaponMatchups: { sanpietrino: 1.25, cacciavite: 1.0, spranga: 0.85, fionda: 0.9 },
    bossLines: [
      '"Te faccio vede\' er giro der Dale!"',
      '"Capoeira de strada, Conte! Rimbalzo sui muri!"',
      '"Dale! Dale! DALEEEE! Nun te fermi mai!"'
    ],
    defeatLines: [
      '"Ma... so\' caduto dar muro..."',
      '"Vabbè me ne torno a gira\' in piazza..."'
    ]
  },
  {
    name: 'Pizzarium',
    boss: 'Ciccio Ruver',
    bossColor: '#ff7043',
    bossHp: 620,
    subtitle: 'Il pizzaiolo col mohawk',
    bgColor: '#3e2723',
    groundColor: '#4e342e',
    goonCount: 5,
    music: 'level4',
    weaponMatchups: { sanpietrino: 0.85, cacciavite: 1.0, spranga: 1.0, fionda: 1.2 },
    bossLines: [
      '"A\' Conte! Te faccio na pizza speciale!"',
      '"Margherita in faccia, offering del giorno!"',
      '"Col mohawk ce spacco, col forno pure!"'
    ],
    defeatLines: [
      '"La pizza... fredda... come il mio cuore..."',
      '"Chi gestisce er Pizzarium mo\'?!"'
    ]
  },
  {
    name: 'Piazza Mazzini',
    boss: 'Pisellino',
    bossColor: '#b0bec5',
    bossHp: 920,
    subtitle: 'Il fantasma di Valle Aurelia',
    bgColor: '#0d0d1a',
    groundColor: '#1a1a2e',
    goonCount: 6,
    music: 'level5',
    weaponMatchups: { sanpietrino: 1.0, cacciavite: 1.1, spranga: 1.1, fionda: 0.8 },
    bossLines: [
      '"Yo Conte... you think you\'re ready? Nun ce crede manco te..."',
      '"I\'m the final boss bro, er Pisellino non perdona"',
      '"MARIUSOOO! Uncle! Come help me destroy this kid!"',
      '"This is MY piazza, capito? Piazza Mazzini is MINE"'
    ],
    defeatLines: [
      '"No way bro... impossible... ma come..."',
      '"Uncle Mariuso... we lost... it\'s over zio..."',
      '"GG Conte... you earned Piazza Mazzini... for now..."'
    ]
  }
];

// Weapon matchup system: maps weapon name → matchup category
function getWeaponMatchupKey(weaponName) {
  const n = weaponName.toLowerCase();
  if (n === 'sanpietrino') return 'sanpietrino';
  if (n === 'cacciavite' || n === 'machete' || n === 'bottiglia rotta') return 'cacciavite';
  if (n === 'spranga' || n === 'catena' || n === 'la lupa') return 'spranga';
  if (n === 'fionda' || n === 'pistola del nonno') return 'fionda';
  return 'sanpietrino'; // fallback
}

function getBossMatchupMult() {
  const lvl = levels[currentLevel];
  if (!lvl || !lvl.weaponMatchups) return 1;
  const key = getWeaponMatchupKey(weapons[player.weapon].name);
  return lvl.weaponMatchups[key] || 1;
}

// ==========================================
// ENVIRONMENTAL HAZARDS (one per level)
// ==========================================
let hazards = [];
const HAZARD_DEFS = [
  // L0: Puddle — slows movement 30%
  { type: 'puddle', x: 450, y: 426, w: 100, h: 8, color: '#1565c0', label: 'PUDDLE' },
  // L1: No hazard
  null,
  // L2: Dumpster fire — periodic fire burst
  { type: 'fire', x: 350, y: 410, w: 40, h: 20, color: '#bf360c', label: 'FIRE', timer: 0 },
  // L3: Ledge — enemies near edge can be knocked off
  { type: 'ledge', x: 850, y: 430, w: 50, h: 10, color: '#ff5722', label: 'LEDGE' },
  // L4: Electrical panel — interactable AoE shock
  { type: 'panel', x: 200, y: 395, w: 30, h: 35, color: '#ffeb3b', label: 'PANEL', cooldown: 0 }
];

function initHazards(levelIdx) {
  const def = HAZARD_DEFS[levelIdx];
  if (!def) { hazards = []; return; }
  hazards = [Object.assign({}, def)];
  if (def.type === 'cart') hazards[0].hp = def.maxHp;
  if (def.type === 'panel') hazards[0].cooldown = 0;
  if (def.type === 'fire') hazards[0].timer = 0;
}

function updateHazards() {
  hazards.forEach(h => {
    if (h.type === 'puddle') {
      // Slow anyone inside
      if (Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 15) {
        player.speedBoost = Math.min(player.speedBoost, 0); // cancel speed boost
        player.x += (player.x > h.x + h.w/2 ? 1 : -1) * 0; // no push, just slow
        // Apply slow via temporary flag
        player.hazardSlow = true;
      } else {
        player.hazardSlow = false;
      }
      // Goons are not affected by puddles
      goons.forEach(g => { g.hazardSlow = false; });
    }
    if (h.type === 'cart') {
      if (h.hp <= 0) return; // already destroyed
      // Player melee can destroy it
      if (player.attackActiveTimer > 0 && Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 30) {
        h.hp -= 10;
        spawnParticles(h.x + h.w/2, h.y, '#8d6e63', 4, 2);
        if (h.hp <= 0) {
          // Drop health pickup
          spawnParticles(h.x + h.w/2, h.y, '#4caf50', 10, 4);
          player.hp = Math.min(player.maxHp, player.hp + 25);
          spawnDamageNumber(h.x + h.w/2, h.y - 20, '+25 HP', '#4caf50');
          showQuickText('Cart destroyed! +25 HP', '#4caf50');
        }
      }
      // Block movement
      if (h.hp > 0) {
        if (Math.abs(player.x - (h.x + h.w/2)) < h.w/2 + 15 && player.y >= GROUND_Y - 5) {
          player.x = player.x < h.x + h.w/2 ? h.x - 16 : h.x + h.w + 16;
        }
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < h.w/2 + 10) {
            g.x = g.x < h.x + h.w/2 ? h.x - 11 : h.x + h.w + 11;
          }
        });
      }
    }
    if (h.type === 'fire') {
      h.timer++;
      if (h.timer % 300 === 0) { // Every 5 seconds
        // Fire burst — damage anyone nearby
        const burstRange = 70;
        spawnParticles(h.x + h.w/2, h.y - 10, '#ff6f00', 20, 6);
        spawnParticles(h.x + h.w/2, h.y - 20, '#f44336', 12, 4);
        if (Math.abs(player.x - (h.x + h.w/2)) < burstRange) {
          hurtPlayer(8);
          spawnDamageNumber(player.x, player.y - 50, 'BURN!', '#ff6f00');
        }
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < burstRange) {
            g.hp -= 15;
            g.hitFlash = 10;
            spawnDamageNumber(g.x, g.y - 40, 'BURN!', '#ff6f00');
            if (g.hp <= 0 && !g.isBoss) { g.dead = true; totalKills++; }
          }
        });
      }
      // Ambient fire particles
      if (h.timer % 10 === 0) {
        spawnParticles(h.x + h.w/2 + (Math.random()-0.5)*20, h.y - 5, '#ff6f00', 2, 2);
      }
    }
    if (h.type === 'ledge') {
      // Check if any entity is knocked into the ledge area
      goons.forEach(g => {
        if (!g.dead && g.x > h.x && Math.abs(g.knockbackVx || 0) > 2) {
          g.dead = true;
          totalKills++;
          spawnParticles(g.x, g.y - 20, '#ff5722', 15, 5);
          spawnDamageNumber(g.x, g.y - 50, 'FALL!', '#ff5722');
          spawnCoinPickup(g.x - 20, g.y - 30, 10);
          playSFX('coin');
        }
      });
      // Player warning
      if (player.x > h.x - 20 && Math.abs(player.knockbackVx || 0) > 3) {
        hurtPlayer(30);
        player.x = h.x - 30;
        spawnDamageNumber(player.x, player.y - 50, 'EDGE!', '#ff5722');
      }
    }
    if (h.type === 'panel') {
      h.cooldown = Math.max(0, h.cooldown - 1);
      // Player activates with attack when near
      if (h.cooldown === 0 && player.attackActiveTimer > 0 && Math.abs(player.x - (h.x + h.w/2)) < 40) {
        h.cooldown = 1800; // 30 seconds
        // Shock all enemies in range
        const shockRange = 150;
        spawnParticles(h.x + h.w/2, h.y - 10, '#ffeb3b', 25, 8);
        screenShake = 10;
        screenFlash = 8;
        flashColor = '#ffeb3b';
        showQuickText('ELECTRIC SHOCK!', '#ffeb3b');
        goons.forEach(g => {
          if (!g.dead && Math.abs(g.x - (h.x + h.w/2)) < shockRange) {
            g.hp -= 25;
            g.stunTimer = Math.max(g.stunTimer || 0, 60);
            g.hitFlash = 15;
            spawnDamageNumber(g.x, g.y - 40, 'SHOCK!', '#ffeb3b');
            if (g.hp <= 0 && !g.isBoss) { g.dead = true; totalKills++; }
          }
        });
        if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0 && Math.abs(boss.x - (h.x + h.w/2)) < shockRange) {
          boss.hp -= 25;
          boss.hitFlash = 15;
          spawnDamageNumber(boss.x, boss.y - 60, 'SHOCK!', '#ffeb3b');
        }
      }
    }
  });
}

function drawHazards() {
  hazards.forEach(h => {
    if (h.type === 'puddle') {
      ctx.globalAlpha = 0.4;
      drawRect(h.x, h.y, h.w, h.h, '#1565c0');
      // Ripple effect
      ctx.globalAlpha = 0.2;
      const ripple = Math.sin(gameTime * 0.05) * 3;
      drawRect(h.x + ripple, h.y - 1, h.w - ripple * 2, 2, '#42a5f5');
      ctx.globalAlpha = 1;
    }
    if (h.type === 'cart' && h.hp > 0) {
      drawRect(h.x, h.y, h.w, h.h, '#8d6e63');
      drawRect(h.x + 2, h.y + 2, h.w - 4, 8, '#4caf50'); // fruit
      drawRect(h.x + 5, h.y + 5, 8, 6, '#f44336'); // apple
      drawRect(h.x + 18, h.y + 4, 10, 7, '#fdd835'); // banana
      drawRect(h.x + 35, h.y + 5, 8, 6, '#ff9800'); // orange
      // HP bar
      const hpPct = h.hp / h.maxHp;
      drawRect(h.x, h.y - 6, h.w, 4, '#333');
      drawRect(h.x, h.y - 6, h.w * hpPct, 4, '#4caf50');
    }
    if (h.type === 'fire') {
      drawRect(h.x, h.y, h.w, h.h, '#4e342e'); // dumpster
      drawRect(h.x + 3, h.y + 3, h.w - 6, 4, '#6d4c41');
      // Warning glow when burst is near
      const untilBurst = 300 - (h.timer % 300);
      if (untilBurst < 60) {
        ctx.globalAlpha = 0.3 + (1 - untilBurst / 60) * 0.5;
        drawRect(h.x - 20, h.y - 30, h.w + 40, h.h + 30, '#ff6f00');
        ctx.globalAlpha = 1;
      }
    }
    if (h.type === 'ledge') {
      // Danger stripes at edge
      ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.1) * 0.2;
      for (let i = 0; i < 5; i++) {
        drawRect(h.x + i * 10, GROUND_Y - 2 - i * 3, 8, 3, i % 2 ? '#ff5722' : '#ffeb3b');
      }
      ctx.globalAlpha = 1;
      drawText('DANGER', h.x + 15, GROUND_Y - 20, '#ff5722', 8, 'center');
    }
    if (h.type === 'panel') {
      drawRect(h.x, h.y, h.w, h.h, '#37474f');
      // Lightning bolt icon
      const ready = h.cooldown === 0;
      const panelColor = ready ? '#ffeb3b' : '#666';
      drawRect(h.x + 8, h.y + 5, 14, 25, panelColor);
      drawText('!', h.x + h.w/2, h.y + h.h/2 + 4, '#000', 16, 'center');
      if (!ready) {
        drawText(Math.ceil(h.cooldown / 60) + 's', h.x + h.w/2, h.y - 6, '#aaa', 8, 'center');
      } else {
        drawText('HIT', h.x + h.w/2, h.y - 6, '#ffeb3b', 8, 'center');
      }
    }
  });
}

// ==========================================
// PISELLINO DEATH TAUNTS (romanesco + english)
// ==========================================
const piselloTaunts = [
  '"Lol bro, you died? Ma sei scarso forte..."',
  '"Game over amico, torna a Vanni a piagne\'"',
  '"You call yourself il Conte? More like il Pollo hahaha"',
  '"Daje Conte retry... oh wait, sei morto again"',
  '"Bro honestly just uninstall, nun fa per te"',
  '"Rest in pepperoni Conte, aahahah get it?"',
  '"Ma che stai a fa\'? Go back to school bro"',
  '"Easy clap, too easy, er Pisellino colpisce ancora"',
  '"You thought this was gonna be easy? Welcome to Valle Aurelia baby"',
  '"Mariuso says ciao ciao, e pure io"'
];

// ==========================================
// DRAWING FUNCTIONS
// ==========================================

function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

function drawText(text, x, y, color, size, align) {
  ctx.fillStyle = color || '#fff';
  let s = size || 16;
  if (isTouchDevice && mobileMenuStates.has(state) && s < 16) s = Math.round(s * 1.15);
  ctx.font = s + 'px monospace';
  ctx.textAlign = align || 'left';
  ctx.fillText(text, x, y);
}

function drawPixelChar(x, y, w, h, bodyColor, headColor, features) {
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(x - 2, y + h - 4, w + 4, 6);
  // Dark outline for contrast against backgrounds
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(x + 1, y - 1, w - 2, h + 2);
  // Legs
  drawRect(x + 6, y + h - 16, 8, 16, '#333');
  drawRect(x + w - 14, y + h - 16, 8, 16, '#333');
  // Body
  drawRect(x + 2, y + 20, w - 4, h - 36, bodyColor);
  // Head
  drawRect(x + 4, y, w - 8, 22, headColor);
  // Eyes
  drawRect(x + 8, y + 8, 5, 5, '#fff');
  drawRect(x + w - 13, y + 8, 5, 5, '#fff');
  drawRect(x + 10, y + 10, 2, 2, '#111');
  drawRect(x + w - 11, y + 10, 2, 2, '#111');
  // Extra features
  if (features) features(x, y, w, h);
}

function drawConte(p) {
  const bx = p.x - p.w/2, by = p.y - p.h;
  const flip = p.facing;

  // Dodge effect
  if (p.dodging) {
    ctx.globalAlpha = 0.5;
  }
  // Invincibility flash
  if (p.invincible > 0 && Math.floor(gameTime / 4) % 2 === 0) {
    ctx.globalAlpha = 0.3;
  }

  // Bob animation
  const bob = p.grounded ? Math.sin(p.animTimer * 0.1) * 2 : -4;

  drawPixelChar(bx, by + bob, p.w, p.h, '#1a1a1a', '#ffcc80', (x, y, w, h) => {
    // AS Roma hat (dark red with gold trim)
    drawRect(x, y - 6, w, 5, '#8b0000');
    drawRect(x - 2, y - 2, w + 4, 4, '#8b0000');
    drawRect(x + 2, y - 8, 6, 3, '#ffc107'); // Roma lupetto badge
    // Hair peeking out
    drawRect(x + 2, y, w - 4, 3, '#3e2723');
    // Sunglasses (YO code) — aviator style
    if (hasSunglasses) {
      const sx = x, sy = y, sw = w;
      // Frame bridge (gold metal)
      drawRect(sx + sw/2 - 3, sy + 8, 6, 2, '#bfa24a');
      // Left lens frame
      drawRect(sx + 5, sy + 7, 11, 7, '#222');
      // Right lens frame
      drawRect(sx + sw - 16, sy + 7, 11, 7, '#222');
      // Left lens (dark gradient look)
      drawRect(sx + 6, sy + 8, 9, 5, '#1a1a2e');
      drawRect(sx + 6, sy + 8, 9, 2, '#2a2a4e'); // lighter top for gradient
      // Right lens
      drawRect(sx + sw - 15, sy + 8, 9, 5, '#1a1a2e');
      drawRect(sx + sw - 15, sy + 8, 9, 2, '#2a2a4e');
      // Lens shine (subtle reflection)
      drawRect(sx + 7, sy + 9, 3, 1, 'rgba(255,255,255,0.25)');
      drawRect(sx + sw - 14, sy + 9, 3, 1, 'rgba(255,255,255,0.25)');
      // Temple arms going to ears (gold)
      drawRect(sx + 3, sy + 9, 3, 2, '#bfa24a');
      drawRect(sx + sw - 6, sy + 9, 3, 2, '#bfa24a');
      // Nose pads
      drawRect(sx + sw/2 - 2, sy + 10, 1, 2, '#bfa24a');
      drawRect(sx + sw/2 + 1, sy + 10, 1, 2, '#bfa24a');
    }
    // Stone Island shirt - dark navy/black
    drawRect(x + 2, y + 20, w - 4, h - 36, '#1a1a2e');
    // Stone Island compass badge on arm
    drawRect(x + w - 6, y + 22, 8, 8, '#81c784'); // green badge
    drawRect(x + w - 4, y + 24, 4, 4, '#fff');     // compass center
    // Jacket arms
    drawRect(x - 2, y + 22, 5, 18, '#1a1a2e');
    drawRect(x + w - 3, y + 22, 5, 18, '#1a1a2e');

    // Weapon in hand
    if (p.attacking && p.attackTimer > 0) {
      const wx = flip === 1 ? x + w : x - 20;
      const wy = y + 25;
      const weap = weapons[p.weapon];
      const tier = weaponTier;
      ctx.fillStyle = getWeaponColor(p.weapon);
      if (weap && weap.ranged) { // Ranged weapon — unique per weapon
        drawRangedInHand(ctx, weap, wx, wy, flip, tier, p.attackTimer);
      } else {
        const swingAngle = (p.attackTimer / 12) * Math.PI;
        ctx.save();
        ctx.translate(wx + 5 * flip, wy);
        ctx.rotate(swingAngle * flip * -1);
        drawWeaponInHand(ctx, weap, weap.range * 0.6, flip, tier);
        // Tier 1+: orange outline glow on swing
        if (tier >= 1) {
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = '#ff8a65';
          ctx.lineWidth = 2;
          ctx.strokeRect(-2 * flip, -5, (weap.range * 0.6 + 4) * flip, 10);
          ctx.globalAlpha = 1;
        }
        // Tier 2+: spark particles trail
        if (tier >= 2) {
          for (let sp = 0; sp < 3; sp++) {
            const spx = Math.random() * weap.range * 0.5 * flip;
            const spy = (Math.random() - 0.5) * 14;
            ctx.fillStyle = ['#ffeb3b', '#ff8a65', '#fff'][sp % 3];
            ctx.fillRect(spx, spy, 2, 2);
          }
        }
        // Tier 3: golden afterimage trail
        if (tier >= 3) {
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = '#ffd700';
          const prevAngle = ((p.attackTimer + 2) / 12) * Math.PI;
          ctx.save();
          ctx.rotate((prevAngle - swingAngle) * flip * -1);
          ctx.fillRect(0, -4, weap.range * 0.6 * flip, 8);
          ctx.restore();
          ctx.globalAlpha = 1;
        }
        ctx.restore();
        // Sbombo sword sparkle trail
        if (weap.special === 'sbombo') {
          ctx.fillStyle = '#ff69b4';
          for (let s = 0; s < 4; s++) {
            const sx = Math.random() * weap.range * 0.8 * flip;
            const sy = (Math.random() - 0.5) * 20;
            ctx.fillRect(wx + sx, wy + sy, 3, 3);
          }
        }
      }
    }
  });

  // Sbombo sword floating hearts aura
  if (weapons[p.weapon] && weapons[p.weapon].special === 'sbombo') {
    for (let h = 0; h < 3; h++) {
      const hAngle = gameTime * 0.04 + h * (Math.PI * 2 / 3);
      const hx = p.x + Math.cos(hAngle) * 22;
      const hy = p.y - p.h / 2 + Math.sin(hAngle * 1.5) * 10 + bob;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#ff69b4';
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u2665', hx, hy);
      ctx.globalAlpha = 1;
    }
  }

  // Ultra golden glow aura
  if (p.ultraActive) {
    const ultraGlow = 0.25 + Math.sin(gameTime * 0.12) * 0.15;
    ctx.globalAlpha = ultraGlow;
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(p.x, p.y - p.h/2 + bob, 34, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
  }
  // Weapon glow effect (tier 3 upgrade)
  if (weapons[p.weapon] && weapons[p.weapon].glow) {
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.08) * 0.1;
    ctx.fillStyle = weapons[p.weapon].color || '#ffd700';
    ctx.beginPath();
    ctx.arc(p.x, p.y - p.h/2 + bob, 28, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;

  // HP bar above head
  const barW = 40;
  const hpRatio = p.hp / p.maxHp;
  drawRect(bx - 2, by - 14 + bob, barW, 6, '#333');
  drawRect(bx - 2, by - 14 + bob, barW * hpRatio, 6, hpRatio > 0.3 ? '#4caf50' : '#f44336');
  drawText('IL CONTE', bx - 5, by - 18 + bob, '#ffc107', 9, 'left');
}

function getWeaponColor(idx) {
  const w = weapons[idx];
  return w && w.color ? w.color : '#ffcc80';
}

// Draw unique melee weapon shape in hand during swing
function drawWeaponInHand(ctx, weap, length, flip, tier) {
  const col = weap.color || '#ffcc80';
  ctx.fillStyle = col;
  ctx.strokeStyle = col;
  ctx.lineWidth = 2;
  const f = flip;
  switch (weap.name) {
    case 'Sanpietrino': {
      // Chunky irregular cobblestone on short handle
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(0, -2, 12 * f, 4); // short handle
      ctx.fillStyle = '#9e9e9e';
      ctx.beginPath();
      ctx.moveTo(12 * f, -7);
      ctx.lineTo(18 * f, -9);
      ctx.lineTo(24 * f, -6);
      ctx.lineTo(26 * f, 0);
      ctx.lineTo(23 * f, 7);
      ctx.lineTo(16 * f, 8);
      ctx.lineTo(12 * f, 5);
      ctx.closePath();
      ctx.fill();
      // Highlight chip
      ctx.fillStyle = '#bdbdbd';
      ctx.fillRect(16 * f, -4, 5 * f, 4);
      break;
    }
    case 'Cacciavite': {
      // Wide handle then thin shaft
      ctx.fillStyle = '#ff8a65';
      // Handle (wide, rounded)
      ctx.fillRect(0, -5, 10 * f, 10);
      ctx.fillRect(2 * f, -6, 6 * f, 12);
      // Metal shaft (thin)
      ctx.fillStyle = '#cfd8dc';
      ctx.fillRect(10 * f, -2, length * 0.5 * f, 4);
      // Tip
      ctx.fillStyle = '#90a4ae';
      ctx.fillRect((10 + length * 0.5) * f, -1, 4 * f, 2);
      break;
    }
    case 'Spranga': {
      // Long thick iron pipe with slight bend
      ctx.fillStyle = '#795548';
      const pipeLen = length * 0.6;
      ctx.fillRect(0, -4, pipeLen * 0.6 * f, 8);
      // Slight bend
      ctx.save();
      ctx.translate(pipeLen * 0.6 * f, 0);
      ctx.rotate(0.15 * f);
      ctx.fillRect(0, -4, pipeLen * 0.5 * f, 8);
      ctx.restore();
      // Highlight stripe
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(4 * f, -4, pipeLen * 0.5 * f, 2);
      break;
    }
    case 'Machete': {
      // Wide curved blade tapering to point
      ctx.fillStyle = '#455a64';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      ctx.fillStyle = '#b0bec5';
      ctx.beginPath();
      ctx.moveTo(8 * f, -5);
      ctx.lineTo(20 * f, -7);
      ctx.lineTo(32 * f, -4);
      ctx.lineTo(38 * f, 0);
      ctx.lineTo(32 * f, 3);
      ctx.lineTo(8 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Edge highlight
      ctx.strokeStyle = '#eceff1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(10 * f, -6);
      ctx.lineTo(34 * f, -3);
      ctx.stroke();
      break;
    }
    case 'Catena': {
      // Series of linked oval chain segments
      ctx.fillStyle = '#757575';
      const links = 6;
      for (let i = 0; i < links; i++) {
        const lx = (i * 9 + 2) * f;
        ctx.beginPath();
        ctx.ellipse(lx, (i % 2 === 0 ? -1 : 1), 5, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        // Inner hole
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.ellipse(lx, (i % 2 === 0 ? -1 : 1), 2, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#757575';
      }
      break;
    }
    case 'Bottiglia Rotta': {
      // Bottle neck + jagged glass top
      ctx.fillStyle = '#2e7d32';
      // Bottle neck (grip)
      ctx.fillRect(0, -3, 10 * f, 6);
      ctx.fillRect(2 * f, -4, 6 * f, 8);
      // Broken glass shards
      ctx.fillStyle = '#4caf50';
      ctx.beginPath();
      ctx.moveTo(10 * f, -5);
      ctx.lineTo(16 * f, -8);
      ctx.lineTo(14 * f, -2);
      ctx.lineTo(20 * f, -6);
      ctx.lineTo(18 * f, 0);
      ctx.lineTo(22 * f, -3);
      ctx.lineTo(19 * f, 4);
      ctx.lineTo(15 * f, 6);
      ctx.lineTo(10 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Glass highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(12 * f, -5, 3 * f, 3);
      break;
    }
    case 'La Lupa': {
      // Ornate golden sword with crossguard
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      // Crossguard
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(7 * f, -8, 4 * f, 16);
      // Blade
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(11 * f, -4);
      ctx.lineTo(40 * f, -2);
      ctx.lineTo(44 * f, 0);
      ctx.lineTo(40 * f, 2);
      ctx.lineTo(11 * f, 4);
      ctx.closePath();
      ctx.fill();
      // Blade center line
      ctx.strokeStyle = '#fff8e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(12 * f, 0);
      ctx.lineTo(42 * f, 0);
      ctx.stroke();
      // Pommel gem
      ctx.fillStyle = '#c62828';
      ctx.beginPath();
      ctx.arc(-2 * f, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
    }
    case 'Spada dello Sbombo': {
      // Pink sparkle sword with heart pommel
      ctx.fillStyle = '#e91e63';
      ctx.fillRect(0, -3, 8 * f, 6); // grip
      // Crossguard (hearts)
      ctx.fillStyle = '#ff69b4';
      ctx.fillRect(7 * f, -7, 4 * f, 14);
      // Blade
      ctx.fillStyle = '#ff69b4';
      ctx.beginPath();
      ctx.moveTo(11 * f, -5);
      ctx.lineTo(48 * f, -2);
      ctx.lineTo(54 * f, 0);
      ctx.lineTo(48 * f, 2);
      ctx.lineTo(11 * f, 5);
      ctx.closePath();
      ctx.fill();
      // Sparkle center
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(14 * f, 0);
      ctx.lineTo(50 * f, 0);
      ctx.stroke();
      // Heart pommel
      ctx.fillStyle = '#ff69b4';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u2665', -4 * f, 4);
      break;
    }
    default: {
      // Fallback rectangle
      ctx.fillRect(0, -3, length * f, 6);
      break;
    }
  }
}

// Draw unique ranged weapon in hand
function drawRangedInHand(ctx, weap, wx, wy, flip, tier, attackTimer) {
  const f = flip;
  switch (weap.name) {
    case 'Fionda': {
      // Y-shaped slingshot fork
      ctx.fillStyle = '#8d6e63';
      // Handle
      ctx.fillRect(wx, wy, 8 * f, 8);
      // Fork prongs
      ctx.strokeStyle = '#795548';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(wx + 8 * f, wy + 2);
      ctx.lineTo(wx + 18 * f, wy - 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(wx + 8 * f, wy + 6);
      ctx.lineTo(wx + 18 * f, wy + 14);
      ctx.stroke();
      // Elastic band
      ctx.strokeStyle = '#ff8a65';
      ctx.lineWidth = 1.5;
      const pullBack = attackTimer > 3 ? -6 : 0;
      ctx.beginPath();
      ctx.moveTo(wx + 18 * f, wy - 6);
      ctx.lineTo(wx + (12 + pullBack) * f, wy + 4);
      ctx.lineTo(wx + 18 * f, wy + 14);
      ctx.stroke();
      break;
    }
    case 'Pistola del Nonno': {
      // Revolver silhouette
      ctx.fillStyle = '#333';
      // Barrel
      ctx.fillRect(wx + 6 * f, wy, 20 * f, 5);
      // Body
      ctx.fillRect(wx, wy, 14 * f, 8);
      // Cylinder (round)
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.arc(wx + 10 * f, wy + 3, 4, 0, Math.PI * 2);
      ctx.fill();
      // Grip (angled down)
      ctx.fillStyle = '#5d4037';
      ctx.save();
      ctx.translate(wx + 4 * f, wy + 8);
      ctx.rotate(0.3 * f);
      ctx.fillRect(0, 0, 6 * f, 10);
      ctx.restore();
      // Muzzle flash
      if (attackTimer > 3) {
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(wx + 28 * f, wy - 4, 12 * f, 14);
      }
      break;
    }
    default: {
      // Fallback generic gun
      ctx.fillStyle = weap.color || '#ffcc80';
      ctx.fillRect(wx, wy, 25 * f, 6);
      if (attackTimer > 3) {
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(wx + 28 * f, wy - 4, 12 * f, 14);
      }
      break;
    }
  }
}

// Draw mobile touch buttons overlay
function drawTouchButtons() {
  if (!isTouchDevice || inMobileWrapper) return;
  const btns = getTouchButtonsForState();
  if (btns.length === 0) return;
  ctx.save();
  for (const name of btns) {
    // Skip ultra button if ultra not available
    if (name === 'ultra' && !(player.ultraCharge >= 100 && !player.ultraActive)) continue;
    const b = touchButtons[name];
    // Hidden buttons are hit areas only (e.g. helper bar overlay)
    if (b.hidden) continue;
    const pressed = Object.values(touchBtnState).includes(name);
    const alpha = pressed ? 0.55 : 0.3;
    ctx.globalAlpha = alpha;
    // Rounded rect background
    const r = 8;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.moveTo(b.x + r, b.y);
    ctx.lineTo(b.x + b.w - r, b.y);
    ctx.quadraticCurveTo(b.x + b.w, b.y, b.x + b.w, b.y + r);
    ctx.lineTo(b.x + b.w, b.y + b.h - r);
    ctx.quadraticCurveTo(b.x + b.w, b.y + b.h, b.x + b.w - r, b.y + b.h);
    ctx.lineTo(b.x + r, b.y + b.h);
    ctx.quadraticCurveTo(b.x, b.y + b.h, b.x, b.y + b.h - r);
    ctx.lineTo(b.x, b.y + r);
    ctx.quadraticCurveTo(b.x, b.y, b.x + r, b.y);
    ctx.closePath();
    ctx.fill();
    // Border
    ctx.globalAlpha = pressed ? 0.8 : 0.5;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Label
    ctx.globalAlpha = pressed ? 1 : 0.7;
    ctx.fillStyle = '#fff';
    ctx.font = (b.w >= 50 ? '14' : '11') + 'px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2);
  }
  ctx.globalAlpha = 1;
  ctx.textBaseline = 'alphabetic';
  ctx.restore();
}

// Draw on-screen keyboard for credits code entry (mobile)
function drawCreditsKeyboard(baseY) {
  if (!isTouchDevice) return;
  const rows = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['Z','X','C','V','B','N','M','DEL']
  ];
  const kw = 42, kh = 36, gap = 3;
  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];
    const totalW = row.length * (kw + gap) - gap;
    const startX = W / 2 - totalW / 2;
    const ky = baseY + r * (kh + gap);
    for (let c = 0; c < row.length; c++) {
      const kx = startX + c * (kw + gap);
      const letter = row[c];
      const isDelKey = letter === 'DEL';
      const keyW = isDelKey ? kw + 14 : kw;
      const hov = mouseX >= kx && mouseX <= kx + keyW && mouseY >= ky && mouseY <= ky + kh;
      drawRect(kx, ky, keyW, kh, hov ? 'rgba(255,255,255,0.25)' : 'rgba(255,255,255,0.1)');
      drawText(letter, kx + keyW / 2, ky + 24, hov ? '#fff' : '#aaa', isDelKey ? 10 : 13, 'center');
      if (mouseClick && hov) {
        if (isDelKey) {
          codeInput = codeInput.slice(0, -1);
        } else {
          if (codeInput.length < 12) codeInput += letter;
        }
        mouseClick = false;
      }
    }
  }
}

function drawBossChar(b, level) {
  if (!b || b.dead) return;
  const bx = b.x - b.w/2, by = b.y - b.h;
  const flash = b.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0;
  const telegraphing = b.bossState === 'telegraph';

  if (flash) ctx.globalAlpha = 0.5;
  // Telegraph warning — red pulsing tint
  if (telegraphing) {
    const telPulse = Math.sin(gameTime * 0.25) * 0.15 + 0.75;
    ctx.globalAlpha = telPulse;
  }
  // Recovery visual cue — green pulsing (safe to punish)
  if (b.bossState === 'recovery') {
    const recPulse = Math.sin(gameTime * 0.2) * 0.15 + 0.75;
    ctx.globalAlpha = recPulse;
  }

  switch(currentLevel) {
    case 0: drawLaFed(bx, by, b); break;
    case 1: drawGioacchino(bx, by, b); break;
    case 2: drawDale(bx, by, b); break;
    case 3: drawCiccioRuver(bx, by, b); break;
    case 4: drawPisellino(bx, by, b); break;
  }

  ctx.globalAlpha = 1.0;

  // Telegraph warning overlay — thick red pulsing border + red circle "!"
  if (telegraphing) {
    const telPulse = Math.sin(gameTime * 0.25) * 0.2 + 0.7;
    ctx.globalAlpha = telPulse;
    ctx.strokeStyle = '#f44336';
    ctx.lineWidth = 4;
    ctx.strokeRect(bx - 4, by - 4, b.w + 8, b.h + 8);
    ctx.lineWidth = 1;
    // Red circle with "!" above boss
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath();
    ctx.arc(b.x, by - 18, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
    drawText('!', b.x, by - 12, '#fff', 22, 'center');
  }
  // Recovery overlay — green glow + border + "PUNISCI!" text
  if (b.bossState === 'recovery') {
    const recPulse = Math.sin(gameTime * 0.2) * 0.15 + 0.55;
    // Green glow around boss
    ctx.globalAlpha = recPulse * 0.5;
    ctx.fillStyle = '#4caf50';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 0.9, 0, Math.PI * 2);
    ctx.fill();
    // Green border
    ctx.globalAlpha = recPulse;
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 3;
    ctx.strokeRect(bx - 3, by - 3, b.w + 6, b.h + 6);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 1.0;
    // "PUNISCI!" text above boss
    const textPulse = Math.sin(gameTime * 0.15) * 0.2 + 0.8;
    ctx.globalAlpha = textPulse;
    drawText('PUNISCI!', b.x, by - 16, '#4caf50', 16, 'center');
    ctx.globalAlpha = 1.0;
  }
  // Super armor glow during charge attacks (orange/red pulsing aura)
  if (b.bossState === 'attack' && b.currentMove && b.currentMove.superArmor) {
    const armorPulse = 0.35 + Math.sin(gameTime * 0.15) * 0.15;
    ctx.globalAlpha = armorPulse;
    ctx.fillStyle = '#ff6f00';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 1.0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#f44336';
    ctx.fillRect(bx - 3, by - 3, b.w + 6, b.h + 6);
    ctx.globalAlpha = 1.0;
  }

  // Ciccio tank mode fire aura (phase 3)
  if (b.ciccioTank) {
    const firePulse = 0.15 + Math.sin(gameTime * 0.1) * 0.08;
    ctx.globalAlpha = firePulse;
    ctx.fillStyle = '#ff6f00';
    ctx.beginPath();
    ctx.arc(b.x, b.y - b.h / 2, b.w * 0.9, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
    // Fire particles constantly
    if (gameTime % 4 === 0) spawnParticles(b.x + (Math.random()-0.5)*b.w, b.y - Math.random()*b.h, '#f44336', 1, 2);
  }

  // Boss HP bar is drawn in HUD (outside zoom transform) — see drawBossHpBar()
}

function drawBossHpBar() {
  if (!boss || boss.dead || !bossIntro) return;
  const b = boss;
  const barW = 260;
  const hpRatio = b.hp / b.maxHp;
  const barX = W/2 - barW/2;
  drawRect(barX - 4, 6, barW + 8, 36, 'rgba(0,0,0,0.85)');
  drawRect(barX - 4, 6, barW + 8, 2, '#e94560');
  drawText(levels[currentLevel].boss.toUpperCase(), W/2, 22, '#ff8a80', 12, 'center');
  if (b.bossPhase > 1) drawText('PHASE ' + b.bossPhase, W/2 + 100, 22, '#ffd700', 9, 'center');
  drawRect(barX, 28, barW, 10, '#333');
  drawRect(barX, 28, barW * hpRatio, 10, hpRatio > 0.3 ? '#e53935' : '#ff6f00');
  // Boss poise bar
  if (b.poise !== undefined && b.poise < b.maxPoise) {
    const poiseR = Math.max(0, b.poise / b.maxPoise);
    drawRect(barX, 39, barW, 3, '#555');
    drawRect(barX, 39, barW * poiseR, 3, b.staggerTimer > 0 ? '#ff9800' : '#ffeb3b');
  }
  // Phase markers at 60% and 30% HP
  [0.6, 0.3].forEach(t => {
    drawRect(barX + barW * t - 1, 26, 2, 14, '#ffd700');
  });
}

function drawLaFed(x, y, b) {
  drawPixelChar(x, y, b.w, b.h, '#fff', '#ffe0b2', (px, py, w, h) => {
    // Blond hair
    drawRect(px + 2, py - 4, w - 4, 10, '#ffd54f');
    // Rugby jersey stripes
    drawRect(px + 4, py + 28, w - 8, 4, '#1565c0');
    drawRect(px + 4, py + 36, w - 8, 4, '#1565c0');
    // Muscular arms
    drawRect(px - 6, py + 22, 10, 18, '#ffe0b2');
    drawRect(px + w - 4, py + 22, 10, 18, '#ffe0b2');
    // Blue eyes
    drawRect(px + 10, py + 10, 2, 2, '#2196f3');
    drawRect(px + w - 11, py + 10, 2, 2, '#2196f3');
    // Smirk
    drawRect(px + 10, py + 16, w - 20, 2, '#e65100');
  });
}

function drawGioacchino(x, y, b) {
  drawPixelChar(x, y, b.w, b.h, '#424242', '#5d4037', (px, py, w, h) => {
    // Short hair
    drawRect(px + 4, py - 2, w - 8, 6, '#212121');
    // Baton in hand
    drawRect(px + w, py + 22, 30, 5, '#795548');
    // Tough expression
    drawRect(px + 8, py + 16, 6, 2, '#d32f2f');
  });
}

function drawDale(x, y, b) {
  // Dale is TALL
  drawPixelChar(x, y, b.w, b.h, '#607d8b', '#ffcc80', (px, py, w, h) => {
    // Messy hair
    drawRect(px + 2, py - 5, w - 4, 8, '#8d6e63');
    drawRect(px + 8, py - 8, 6, 6, '#8d6e63');
    // Dumb expression - mouth open
    drawRect(px + 10, py + 15, w - 20, 6, '#111');
    // Crossed eyes
    drawRect(px + 11, py + 10, 2, 2, '#111');
    drawRect(px + w - 12, py + 9, 2, 2, '#111');
  });
}

function drawCiccioRuver(x, y, b) {
  const scale = b.w / 52; // scale factor based on phase 3 growth
  drawPixelChar(x, y, b.w + Math.floor(8 * scale), b.h, '#fff', '#ffcc80', (px, py, w, h) => {
    // Mohawk
    for (let i = 0; i < 7; i++) {
      const sx = Math.floor(10 * scale + i * 3 * scale);
      const spikeH = Math.floor((12 + i * 2) * scale);
      drawRect(px + sx, py - Math.floor(10 * scale) - Math.floor(i * 2 * scale), Math.floor(4 * scale), spikeH, '#d32f2f');
      // Phase 3: orange flame tips on mohawk spikes
      if (b.bossPhase >= 3) {
        const flicker = Math.sin(gameTime * 0.3 + i) * 2;
        drawRect(px + sx, py - Math.floor(10 * scale) - Math.floor(i * 2 * scale) - Math.floor(4 * scale) + flicker, Math.floor(4 * scale), Math.floor(4 * scale), '#ff6f00');
      }
    }
    // Pizza apron
    drawRect(px + Math.floor(2 * scale), py + Math.floor(22 * scale), w - Math.floor(4 * scale), Math.floor(25 * scale), '#fff');
    drawRect(px + Math.floor(8 * scale), py + Math.floor(26 * scale), w - Math.floor(16 * scale), Math.floor(2 * scale), '#f44336');
    // Slightly wider body (overweight)
    drawRect(px - Math.floor(4 * scale), py + Math.floor(24 * scale), Math.floor(8 * scale), Math.floor(16 * scale), '#fff');
    drawRect(px + w - Math.floor(4 * scale), py + Math.floor(24 * scale), Math.floor(8 * scale), Math.floor(16 * scale), '#fff');
    // Flour on face
    drawRect(px + Math.floor(6 * scale), py + Math.floor(6 * scale), Math.floor(4 * scale), Math.floor(3 * scale), '#fafafa');
  });
}

function drawPisellino(x, y, b) {
  // Ghost-like, tall and skinny — drawn at original size then scaled 1.5x
  const ghostAlpha = 0.85 + Math.sin(gameTime * 0.05) * 0.15;
  ctx.globalAlpha *= ghostAlpha;
  const sc = 1.5;
  const ow = 38, oh = 72; // original dimensions
  // Center the scaled drawing on the hitbox
  const cx = x + b.w / 2, cy = y + b.h;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(sc, sc);
  ctx.translate(-ow / 2, -oh);

  // Extra tall, skinny body
  drawRect(8, 22, ow - 16, oh - 22, '#37474f');
  // Skinny legs
  drawRect(10, oh - 18, 5, 18, '#263238');
  drawRect(ow - 15, oh - 18, 5, 18, '#263238');
  // Head - pale
  drawRect(6, 0, ow - 12, 24, '#cfd8dc');
  // Dark eyes
  drawRect(10, 8, 6, 6, '#111');
  drawRect(ow - 16, 8, 6, 6, '#111');
  drawRect(12, 10, 2, 2, '#f44336');
  drawRect(ow - 14, 10, 2, 2, '#f44336');
  // Thin mouth - sinister grin
  drawRect(10, 18, ow - 20, 2, '#b71c1c');
  // Hood
  drawRect(2, -4, ow - 4, 10, '#263238');
  drawRect(0, -2, 6, 14, '#263238');
  drawRect(ow - 6, -2, 6, 14, '#263238');

  ctx.restore();

  // Moped nearby (drawn at world scale, not character scale)
  if (b.onMoped) {
    drawRect(b.x - 45, b.y - 30, 90, 22, '#616161');
    drawRect(b.x - 52, b.y - 15, 18, 18, '#333');
    drawRect(b.x + 34, b.y - 15, 18, 18, '#333');
    drawRect(b.x - 30, b.y - 45, 12, 22, '#757575');
  }
}

function drawRegina(r) {
  if (!r || r.dead) return;
  const x = r.x - r.w/2, y = r.y - r.h;
  drawPixelChar(x, y, r.w, r.h, '#e91e63', '#6d4c41', (px, py, w, h) => {
    // Long hair
    drawRect(px, py - 2, 6, 20, '#212121');
    drawRect(px + w - 6, py - 2, 6, 20, '#212121');
    // Angry expression
    drawRect(px + 8, py + 6, 8, 2, '#fff');
    drawRect(px + w - 16, py + 6, 8, 2, '#fff');
  });
  // HP bar
  const hpR = r.hp / r.maxHp;
  drawRect(x, y - 10, 30, 4, '#333');
  drawRect(x, y - 10, 30 * hpR, 4, '#e91e63');
  drawText('REGINA', x, y - 14, '#e91e63', 8);
}

function drawMariuso(m) {
  if (!m || m.dead) return;
  const x = m.x - m.w/2, y = m.y - m.h;
  // Mariuso - big, angry uncle
  drawPixelChar(x, y, m.w + 10, m.h, '#4a148c', '#ffcc80', (px, py, w, h) => {
    // Bald with stubble
    drawRect(px + 4, py - 2, w - 8, 6, '#5d4037');
    // Angry brows
    drawRect(px + 6, py + 5, 8, 3, '#333');
    drawRect(px + w - 14, py + 5, 8, 3, '#333');
    // Big fists
    drawRect(px - 8, py + 22, 12, 12, '#ffcc80');
    drawRect(px + w - 4, py + 22, 12, 12, '#ffcc80');
    // Scar
    drawRect(px + 6, py + 12, 2, 8, '#b71c1c');
  });
  // HP bar
  const hpR = m.hp / m.maxHp;
  drawRect(x, y - 10, 40, 5, '#333');
  drawRect(x, y - 10, 40 * hpR, 5, '#7b1fa2');
  drawText('MARIUSO', x - 5, y - 15, '#ce93d8', 9);
}

// ==========================================
// PARTICLE SYSTEM
// ==========================================
const MAX_PARTICLES = 200;
const MAX_DAMAGE_NUMBERS = 30;

function spawnParticles(x, y, color, count, speed) {
  // If near cap, reduce spawn count
  const headroom = MAX_PARTICLES - particles.length;
  const actualCount = Math.min(count, Math.max(1, headroom));
  for (let i = 0; i < actualCount; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * (speed || 4),
      vy: (Math.random() - 0.8) * (speed || 4),
      life: 30 + Math.random() * 30,
      color: color,
      size: 2 + Math.random() * 4
    });
  }
  // Hard cap: drop oldest if over limit
  if (particles.length > MAX_PARTICLES) {
    particles.splice(0, particles.length - MAX_PARTICLES);
  }
}

function spawnArmorSpark(x, y) {
  if (particles.length >= MAX_PARTICLES) return;
  for (let i = 0; i < 5; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.8) * 5,
      life: 8,
      color: '#fff',
      size: 1 + Math.random() * 2
    });
  }
}

function spawnDamageNumber(x, y, dmg, color) {
  if (damageNumbers.length >= MAX_DAMAGE_NUMBERS) damageNumbers.shift();
  damageNumbers.push({ x, y, vy: -2, text: dmg.toString(), life: 40, color: color || '#ff0' });
}

function updateParticles() {
  // Swap-and-pop removal for O(1) per particle
  let i = 0;
  while (i < particles.length) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) {
      particles[i] = particles[particles.length - 1];
      particles.pop();
    } else {
      i++;
    }
  }
  let j = 0;
  while (j < damageNumbers.length) {
    const d = damageNumbers[j];
    d.y += d.vy;
    d.life--;
    if (d.life <= 0) {
      damageNumbers[j] = damageNumbers[damageNumbers.length - 1];
      damageNumbers.pop();
    } else {
      j++;
    }
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 60;
    drawRect(p.x, p.y, p.size, p.size, p.color);
  });
  ctx.globalAlpha = 1;
  damageNumbers.forEach(d => {
    ctx.globalAlpha = d.life / 40;
    drawText(d.text, d.x, d.y, d.color, 16, 'center');
  });
  ctx.globalAlpha = 1;
}

// ==========================================
// COIN PICKUP SYSTEM
// ==========================================
let coinPickups = [];

function spawnCoinPickup(x, y, value) {
  // Chain bonus multiplier based on player's combo chain count
  const chainMult = Math.min(2.0, 1.0 + player.comboChainCount * 0.5);
  const finalValue = Math.round(value * chainMult * 0.95);
  // Scatter into multiple physical coins
  const numCoins = Math.min(8, Math.max(1, Math.floor(finalValue / 4)));
  const perCoin = Math.floor(finalValue / numCoins);
  for (let i = 0; i < numCoins; i++) {
    coinPickups.push({
      x: x + (Math.random() - 0.5) * 20,
      y: y,
      vx: (Math.random() - 0.5) * 6,
      vy: -3 - Math.random() * 4,
      value: perCoin + (i === 0 ? finalValue % numCoins : 0),
      life: 300, // 5 seconds at 60fps
      grounded: false,
      size: Math.min(6, 3 + Math.floor(perCoin / 5))
    });
  }
}

function updateCoinPickups() {
  for (let i = coinPickups.length - 1; i >= 0; i--) {
    const c = coinPickups[i];
    c.life--;
    if (c.life <= 0) { coinPickups.splice(i, 1); continue; }

    if (!c.grounded) {
      c.vy += 0.3;
      c.x += c.vx;
      c.y += c.vy;
      if (c.y >= GROUND_Y - 2) {
        c.y = GROUND_Y - 2;
        c.vy *= -0.4; // bounce
        c.vx *= 0.7;
        if (Math.abs(c.vy) < 0.5) c.grounded = true;
      }
    }

    // Player pickup (30px radius)
    if (!player.dead && Math.abs(c.x - player.x) < 30 && Math.abs(c.y - player.y + 20) < 30) {
      // Replay penalty: replaying beaten levels gives 40% coins
      const replayMult = isReplayLevel ? 0.4 : 1.0;
      const coinValue = Math.floor(c.value * player.scoreMultiplier * replayMult);
      coins += coinValue;
      levelScore += coinValue * 2;
      playSFX('coin');
      spawnParticles(c.x, c.y, '#ffd700', 3, 2);
      coinPickups.splice(i, 1);
    }
  }
}

function drawCoinPickups() {
  coinPickups.forEach(c => {
    // Flash warning in last second (60 frames)
    if (c.life < 60 && Math.floor(c.life / 6) % 2 === 0) {
      ctx.globalAlpha = 0.4;
    } else {
      ctx.globalAlpha = 1;
    }
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    ctx.arc(c.x - 1, c.y - 1, c.size * 0.5, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// ==========================================
// PROJECTILE SYSTEM
// ==========================================
function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (p.gravity) p.vy += 0.15;
    p.life--;

    // Check if it hits player
    if (p.hostile && !player.dead && player.invincible <= 0 && !isDodgeInvincible()) {
      if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y + 20) < 30) {
        hurtPlayer(p.damage || 10);
        spawnParticles(p.x, p.y, '#f44336', 5);
        projectiles.splice(i, 1);
        continue;
      }
    }

    if (p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y > H + 50) {
      projectiles.splice(i, 1);
    }
  }
}

function drawProjectiles() {
  projectiles.forEach(p => {
    if (p.type === 'meat') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate((120 - p.life) * 0.15);
      drawRect(-7, -5, 14, 10, '#6d4c41');
      drawRect(-5, -3, 10, 6, '#d32f2f');
      drawRect(-3, -2, 3, 3, '#ffcdd2');
      drawRect(1, 0, 3, 2, '#ffcdd2');
      drawRect(5, -2, 4, 3, '#eee');
      ctx.restore();
    } else if (p.type === 'pizza') {
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f44336';
      ctx.beginPath();
      ctx.arc(p.x - 2, p.y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x + 3, p.y + 2, 2, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'scarf') {
      drawRect(p.x - 8, p.y - 3, 16, 6, '#64b5f6');
      drawRect(p.x - 6, p.y - 1, 12, 2, '#fff');
    } else if (p.type === 'bullet') {
      drawRect(p.x - 3, p.y - 1, 6, 3, '#ffeb3b');
    } else if (p.type === 'shockwave') {
      ctx.globalAlpha = p.life / 45;
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (p.type === 'sbombo_wave') {
      ctx.globalAlpha = p.life / 40;
      // Pink heart-shaped shockwave
      ctx.fillStyle = '#ff69b4';
      ctx.beginPath();
      ctx.arc(p.x - 5, p.y - 3, 10, 0, Math.PI * 2);
      ctx.arc(p.x + 5, p.y - 3, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(p.x - 14, p.y);
      ctx.lineTo(p.x, p.y + 14);
      ctx.lineTo(p.x + 14, p.y);
      ctx.fill();
      // Inner glow
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath();
      ctx.arc(p.x, p.y - 2, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else {
      drawRect(p.x - 4, p.y - 4, 8, 8, p.color || '#fff');
    }
  });
}

// ==========================================
// HELPER EFFECTS
// ==========================================
function activateHelper(idx) {
  if (!helpers[idx].unlocked) return;
  if (helperCooldowns[idx] > 0) return;
  helperCooldowns[idx] = helpers[idx].cooldown;
  playSFX('helper');

  const tier = helpers[idx].tier;
  switch(idx) {
    case 0: { // Pirox DJ Drop (CC)
      screenShake = 20;
      screenFlash = 10;
      flashColor = '#e040fb';
      spawnParticles(W/2, H/2, '#e040fb', 30, 8);
      spawnHelperVisual(0, W/2, GROUND_Y);
      const stunDur = tier >= 1 ? 180 : 120; // +50% at tier 1
      if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) { boss.stunTimer = stunDur; }
      goons.forEach(g => {
        if (!g.dead) {
          g.stunTimer = stunDur;
          if (tier >= 2 && g.poise !== undefined) g.poise = Math.max(0, g.poise - g.maxPoise * 0.5); // poise shatter
          if (tier >= 3) { // Rally: nearby enemies lose 30% poise
            goons.forEach(o => { if (!o.dead && o !== g && Math.abs(o.x - g.x) < 150 && o.poise !== undefined) o.poise *= 0.7; });
          }
        }
      });
      if (reginaActive && regina) regina.stunTimer = stunDur;
      if (mariusoActive && mariuso) mariuso.stunTimer = stunDur;
      showQuickText('PIROX DJ DROP! Tutti storditi!', '#e040fb');
      break;
    }
    case 1: { // Tommy knife rush (Damage)
      spawnHelperVisual(1, (boss && bossIntro && bossIntroTimer <= 0) ? boss.x : player.x + player.facing * 80, GROUND_Y);
      const baseDmg = tier >= 1 ? (52 + Math.random() * 38) : (35 + Math.random() * 25); // +50% at tier 1
      if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) {
        boss.hp -= baseDmg;
        boss.hitFlash = 10;
        spawnDamageNumber(boss.x, boss.y - boss.h, Math.floor(baseDmg), '#ff6e40');
        spawnParticles(boss.x, boss.y - boss.h/2, '#ff6e40', 15);
        showQuickText('Tommy col coltello! SLASH!', '#ff6e40');
      }
      // Tier 2: auto-attack staggered enemies
      if (tier >= 2) {
        goons.forEach(g => {
          if (!g.dead && g.staggerTimer > 0) {
            g.hp -= baseDmg * 0.5;
            g.hitFlash = 10;
            spawnDamageNumber(g.x, g.y - (g.h || 50), Math.floor(baseDmg * 0.5), '#ff6e40');
            if (g.hp <= 0) { g.dead = true; totalKills++; spawnCoinPickup(g.x, g.y - 20, 7); }
          }
        });
      }
      // Tier 3: war cry buff
      if (tier >= 3) { warCryTimer = 240; showQuickText('WAR CRY! +30% DMG 4s!', '#ff6e40'); }
      break;
    }
    case 2: { // Cicca the cat (Heal)
      const healAmt = tier >= 1 ? 52 : 35; // +50% at tier 1
      player.hp = Math.min(player.maxHp, player.hp + healAmt);
      spawnParticles(player.x, player.y - 30, '#76ff03', 10);
      spawnHelperVisual(2, player.x, GROUND_Y);
      // Tier 2: attack buff
      if (tier >= 2) { warCryTimer = Math.max(warCryTimer, 300); showQuickText('Cicca cura +' + healAmt + ' HP + ATK buff!', '#76ff03'); }
      else showQuickText('Cicca miagola e ti cura! +' + healAmt + ' HP', '#76ff03');
      break;
    }
    case 3: { // Il Mostro speed boost — arrives on moped
      const boostDur = tier >= 1 ? 720 : 480; // +50% at tier 1
      player.speedBoost = boostDur;
      spawnParticles(player.x, player.y - 30, '#76ff03', 15);
      spawnHelperVisual(3, player.x, GROUND_Y);
      showQuickText('"Danie\' Balduina Prati, panoramica in 3 minuti dajeeee!"', '#76ff03');
      break;
    }
  }
}

let quickText = '';
let quickTextColor = '#fff';
let quickTextTimer = 0;

// Active helper visuals on screen
let activeHelperVisuals = []; // {type, x, y, timer, maxTimer, facing}

function spawnHelperVisual(type, targetX, targetY) {
  activeHelperVisuals.push({
    type: type,
    x: type === 2 ? -30 : (type === 3 ? W + 40 : player.x + (Math.random() > 0.5 ? -60 : 60)),
    y: GROUND_Y,
    targetX: targetX,
    timer: 0,
    maxTimer: type === 0 ? 150 : type === 1 ? 100 : type === 2 ? 120 : 90,
    facing: 1,
    phase: 0
  });
}

function updateHelperVisuals() {
  for (let i = activeHelperVisuals.length - 1; i >= 0; i--) {
    const h = activeHelperVisuals[i];
    h.timer++;
    h.facing = h.targetX > h.x ? 1 : -1;

    switch(h.type) {
      case 0: // Pirox DJ - walks to center, drops bass, walks away
        if (h.timer < 40) h.x += (W/2 - h.x) * 0.08;
        else if (h.timer === 40) h.phase = 1;
        else if (h.timer > 110) h.x += h.facing * 4;
        break;
      case 1: // Tommy - stumbles in drunk, slashes, might fall
        if (h.timer < 30) {
          h.x += (h.targetX - h.x) * 0.1;
          h.y = GROUND_Y + Math.sin(h.timer * 0.5) * 3; // wobble
        }
        else if (h.timer === 30) h.phase = 1;
        else if (h.timer > 60) {
          h.x += h.facing * -3; // stumble away
          h.y = GROUND_Y + Math.sin(h.timer * 0.3) * 5;
        }
        break;
      case 2: // Cicca - black cat runs across screen
        h.x += 5;
        h.y = GROUND_Y + Math.sin(h.timer * 0.3) * 2;
        // Drop healing sparkles near player
        if (Math.abs(h.x - player.x) < 60 && h.timer % 5 === 0) {
          spawnParticles(h.x, h.y - 10, '#76ff03', 2, 2);
        }
        break;
      case 3: // Il Mostro - arrives on moped behind player, roars, rides off
        if (h.timer < 20) {
          h.x = player.x - 80 + h.timer * 2;
        } else if (h.timer === 20) {
          h.phase = 1;
          screenShake = 8;
        } else if (h.timer > 60) {
          h.x += 6; // rides off to the right on moped
        }
        break;
    }

    if (h.timer >= h.maxTimer) activeHelperVisuals.splice(i, 1);
  }
}

function drawHelperVisuals() {
  activeHelperVisuals.forEach(h => {
    const alpha = h.timer > h.maxTimer - 20 ? (h.maxTimer - h.timer) / 20 : 1;
    ctx.globalAlpha = alpha;

    switch(h.type) {
      case 0: // Pirox DJ
        drawPixelChar(h.x - 18, h.y - 52, 36, 52, '#9c27b0', '#ffcc80', (px, py, w, hh) => {
          // Headphones
          drawRect(px, py - 2, w, 4, '#e040fb');
          drawRect(px - 3, py + 2, 6, 8, '#e040fb');
          drawRect(px + w - 3, py + 2, 6, 8, '#e040fb');
          // Sunglasses
          drawRect(px + 6, py + 8, w - 12, 5, '#111');
        });
        // Turntable
        if (h.phase === 1) {
          drawRect(h.x - 25, h.y - 25, 50, 8, '#333');
          ctx.fillStyle = '#e040fb';
          ctx.beginPath();
          ctx.arc(h.x, h.y - 22, 12, 0, Math.PI * 2);
          ctx.fill();
          // Bass waves
          for (let w = 0; w < 3; w++) {
            ctx.strokeStyle = '#e040fb';
            ctx.globalAlpha = alpha * (0.5 - w * 0.15);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(h.x, h.y - 30, 30 + w * 20 + (h.timer - 40) * 2, -0.5, 0.5);
            ctx.stroke();
          }
          drawText('BASS DROP!', h.x, h.y - 60, '#e040fb', 14, 'center');
        }
        break;

      case 1: // Tommy drunk
        drawPixelChar(h.x - 16, h.y - 50, 32, 50, '#8d6e63', '#ffcc80', (px, py, w, hh) => {
          // Messy hair
          drawRect(px + 2, py - 4, w - 4, 8, '#5d4037');
          drawRect(px + w - 6, py - 6, 8, 6, '#5d4037');
          // Drunk blush
          drawRect(px + 4, py + 12, 6, 4, '#e57373');
          drawRect(px + w - 10, py + 12, 6, 4, '#e57373');
          // Bottle in other hand
          drawRect(px - 6, py + 20, 5, 14, '#4caf50');
        });
        // Knife
        if (h.phase === 1) {
          const kx = h.x + h.facing * 25;
          drawRect(kx, h.y - 35, 4, 20, '#bdbdbd');
          drawRect(kx - 1, h.y - 18, 6, 8, '#795548');
          spawnParticles(kx, h.y - 35, '#ff6e40', 2, 3);
        }
        // Drunk text
        if (h.timer % 40 < 20) drawText('*hic*', h.x, h.y - 58, '#ff6e40', 10, 'center');
        break;

      case 2: // Cicca orange tabby cat
        // Cat body
        drawRect(h.x - 10, h.y - 14, 20, 10, '#ff8a65');
        drawRect(h.x - 6, h.y - 12, 3, 8, '#e64a19'); // stripe
        drawRect(h.x + 3, h.y - 12, 3, 8, '#e64a19'); // stripe
        // Head
        drawRect(h.x - 7, h.y - 20, 12, 10, '#ff8a65');
        // Ears
        drawRect(h.x - 7, h.y - 24, 4, 5, '#ff8a65');
        drawRect(h.x + 3, h.y - 24, 4, 5, '#ff8a65');
        // Eyes
        drawRect(h.x - 4, h.y - 17, 3, 3, '#4caf50');
        drawRect(h.x + 2, h.y - 17, 3, 3, '#4caf50');
        // Nose
        drawRect(h.x, h.y - 14, 2, 2, '#ff80ab');
        // Tail
        const tailWave = Math.sin(h.timer * 0.3) * 8;
        drawRect(h.x + 10, h.y - 18 + tailWave, 3, 12, '#ff8a65');
        // Legs running
        const legOff = Math.sin(h.timer * 0.8) * 3;
        drawRect(h.x - 6, h.y - 4, 3, 4 + legOff, '#ff8a65');
        drawRect(h.x + 4, h.y - 4, 3, 4 - legOff, '#ff8a65');
        drawText('Miao!', h.x, h.y - 30, '#4caf50', 9, 'center');
        break;

      case 3: // Il Mostro on moped
        // Moped
        drawRect(h.x - 30, h.y - 18, 60, 14, '#616161');
        drawRect(h.x - 35, h.y - 8, 12, 12, '#333'); // back wheel
        drawRect(h.x + 23, h.y - 8, 12, 12, '#333'); // front wheel
        drawRect(h.x - 20, h.y - 28, 8, 14, '#757575'); // handlebar
        drawRect(h.x + 15, h.y - 24, 12, 8, '#f44336'); // headlight
        // Big hulking figure on moped
        drawPixelChar(h.x - 24, h.y - 68, 48, 50, '#33691e', '#ffcc80', (px, py, w, hh) => {
          // Massive arms gripping handlebars
          drawRect(px - 10, py + 14, 14, 20, '#33691e');
          drawRect(px + w - 4, py + 14, 14, 20, '#33691e');
          // Angry face
          drawRect(px + 8, py + 6, 10, 4, '#fff');
          drawRect(px + w - 18, py + 6, 10, 4, '#fff');
          drawRect(px + 10, py + 8, 3, 2, '#111');
          drawRect(px + w - 14, py + 8, 3, 2, '#111');
        });
        if (h.phase === 1 && h.timer < 50) {
          drawText('DAJEEEE!', h.x, h.y - 78, '#76ff03', 16, 'center');
          // Speed lines
          for (let s = 0; s < 5; s++) {
            ctx.globalAlpha = alpha * 0.3;
            drawRect(h.x - 50 - s * 15, h.y - 50 + s * 8, 30 + s * 10, 2, '#76ff03');
          }
        }
        break;
    }
    ctx.globalAlpha = 1;
  });
}

function showQuickText(text, color) {
  quickText = text;
  quickTextColor = color || '#fff';
  quickTextTimer = 120;
}

// ==========================================
// COMBAT
// ==========================================
function isDodgeInvincible() {
  // i-frames only during frames 3-9 of dodge (dodgeTimer 4-10 out of 12)
  return player.dodging && player.dodgeTimer >= 4 && player.dodgeTimer <= 10;
}

function hurtPlayer(dmg) {
  if (player.invincible > 0 || isDodgeInvincible() || player.dead) return;
  dmg *= DIFF_DMG[difficulty];
  if (player.upgrades.some(u => u.effect === 'armor15')) dmg *= 0.85;
  player.hp -= dmg;
  player.invincible = 20;
  levelDamageTaken += dmg;
  player.comboChainCount = 0; // reset chain bonus on hit
  player.comboHitCount = 0; // reset combo counter on hit
  player.comboHitTimer = 0;
  player.scoreMultiplier = 1;
  // Ultra charge drain on taking damage (reduced penalty)
  if (!player.ultraActive) {
    player.ultraCharge = Math.max(0, player.ultraCharge - 12);
    if (player.ultraCharge < player.ultraMaxCharge) player.ultraAvailable = false;
  }
  screenShake = 8;
  spawnParticles(player.x, player.y - 30, '#f44336', 8);
  spawnDamageNumber(player.x, player.y - player.h, Math.floor(dmg), '#f44336');
  playSFX('hurt');
  if (player.hp <= 0) {
    // Cicca tier 3: emergency revive (once per level)
    if (helpers[2].tier >= 3 && !helperReviveUsed) {
      helperReviveUsed = true;
      player.hp = Math.floor(player.maxHp * 0.3);
      player.invincible = 90;
      screenFlash = 15;
      flashColor = '#76ff03';
      spawnParticles(player.x, player.y - 30, '#76ff03', 20, 5);
      showQuickText('CICCA EMERGENCY REVIVE!', '#76ff03');
      playSFX('helper');
      return;
    }
    player.hp = 0;
    player.dead = true;
    screenFlash = 20;
    flashColor = '#f44336';
    playSFX('death');
  }
}

// Combo damage multipliers per step: balanced scaling, no single hit dominates
const COMBO_DMG_MULT = [0.8, 0.9, 1.0, 1.15]; // rewards completing combos without overpowered finisher
const DROPPED_END_LAG = 10; // 8-12 average

// Start or continue a combo chain hit
function playerAttack() {
  if (player.dead || player.stunTimer > 0 || player.endLagTimer > 0) return;
  if (player.reloadTimer > 0) return; // can't attack while reloading

  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;

  // If currently in active frames, buffer input
  if (player.attackActiveTimer > 0) {
    player.attackBuffered = true;
    return;
  }

  // If in combo window, advance to next hit (allowed even when exhausted — finish what you started)
  if (player.comboWindowTimer > 0 && player.comboStep > 0 && player.comboStep < maxHits) {
    launchComboHit(player.comboStep);
    return;
  }

  // Exhaustion blocks starting NEW combos only
  if (player.exhaustedTimer > 0) return;

  // Start fresh combo if not in one
  if (player.comboStep === 0) {
    player.comboStep = 1;
    launchComboHit(0);
  }
}

function launchComboHit(stepIndex) {
  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;

  // Stamina cost: all hits cost 12 (7 during Ultra)
  let staminaPenalty = false;
  const staminaCost = player.ultraActive ? 7 : 12;
  if (player.stamina < staminaCost) {
    staminaPenalty = true; // low stamina: 30% damage, 50% more end-lag
  } else {
    player.stamina = Math.max(0, player.stamina - staminaCost);
    player.staminaRegenDelay = Math.max(player.staminaRegenDelay, 20);
  }
  // Exhaustion check
  if (player.stamina <= 0 && player.exhaustedTimer <= 0) {
    player.exhaustedTimer = 60;
    showQuickText('ESAUSTO!', '#ff8f00');
  }

  player.attacking = true;
  player.attackActiveTimer = weap.activeFrames;
  player.attackTimer = weap.activeFrames;
  player.comboWindowTimer = 0;
  player.attackBuffered = false;
  player.comboStep = stepIndex + 1;

  // Calculate damage
  const dmgMult = COMBO_DMG_MULT[Math.min(stepIndex, 3)];
  // Crit: Sanpietrino critCombo special grows crit chance per step
  let critBonus = 0;
  if (weap.special === 'critCombo') {
    critBonus = stepIndex === 1 ? 15 : stepIndex >= 2 ? 35 : 0;
  }
  const upgCrit = player.upgrades.some(u => u.effect === 'crit15') ? 15 : 0;
  const isCrit = Math.random() * 100 < ((weap.crit || 0) + critBonus + upgCrit);
  const dcMult = dodgeCounter > 0 ? 1.5 : 1;
  const staminaMult = staminaPenalty ? 0.3 : 1;
  const upgDmg = player.upgrades.some(u => u.effect === 'dmg15') ? 1.15 : 1;
  const ultraMult = player.ultraActive ? 1.5 : 1;
  const amaroMult = drinkBuff ? 1.1 : 1;
  let dmg = weap.damage * 0.95 * dmgMult * (isCrit ? 2 : 1) * dcMult * staminaMult * upgDmg * ultraMult * amaroMult;
  const poiseMult = player.upgrades.some(u => u.effect === 'poise25') ? 1.25 : 1;
  const effectivePoise = Math.round(weap.poise * poiseMult);

  // Executioner special: 2.0x on enemies <25% HP during Ultra
  const isExecutioner = weap.special === 'executioner' && player.ultraActive;

  // Range modifiers for Bastone reachControl
  let range = weap.range;
  let hitBothSides = false;
  if (weap.special === 'reachControl') {
    if (stepIndex === 0) range = weap.range * 1.3; // hit 1 extended range
    if (stepIndex === 1) hitBothSides = true;       // hit 2 sweeps both sides
  }

  // Catena crowdPull: always AoE (already hits all in range), Ultra pulls enemies in
  const isCrowdPull = weap.special === 'crowdPull' && player.ultraActive;

  // Ranged weapon shoots projectile(s) — uses ammo system
  if (weap.ranged) {
    // Ammo check: decrement and trigger reload if empty
    if (weap.maxAmmo) {
      if (weap.currentAmmo === undefined) weap.currentAmmo = weap.maxAmmo;
      if (weap.currentAmmo <= 0) return; // shouldn't happen, but safety
      weap.currentAmmo--;
      if (weap.currentAmmo <= 0) {
        player.reloadTimer = weap.reloadFrames || 90;
      }
    }
    const isPiercing = weap.special === 'pierce' ? (weap.name === 'Pistola del Nonno' || (stepIndex >= 2 && player.ultraActive)) : false;
    projectiles.push({
      x: player.x + player.facing * 20,
      y: player.y - 28,
      vx: player.facing * 8,
      vy: 0,
      life: 40,
      damage: dmg,
      hostile: false,
      type: 'bullet',
      piercing: isPiercing,
      poiseDmg: effectivePoise
    });
    playSFX('hit');
    return;
  }

  // Melee hit detection
  const attackX = player.x + player.facing * range * 0.5;
  const hitTargets = [];

  const checkTarget = (t, extraW) => {
    if (!t || t.dead) return;
    const tw = extraW || (t.w || 30) / 2;
    const forwardHit = Math.abs(attackX - t.x) < range * 0.7 + tw && Math.abs(player.y - t.y) < 50;
    // Both-sides hit for Bastone
    let reverseHit = false;
    if (hitBothSides) {
      const reverseX = player.x - player.facing * range * 0.5;
      reverseHit = Math.abs(reverseX - t.x) < range * 0.7 + tw && Math.abs(player.y - t.y) < 50;
    }
    if (forwardHit || reverseHit) hitTargets.push(t);
  };

  // Goon dodge: non-staggered, non-winding-up goons have 10% chance to sidestep melee attacks
  goons.forEach(g => {
    if (!g.dead) {
      if (!g.isBoss && g.staggerTimer <= 0 && g.windupTimer <= 0 && g.launched <= 0 && Math.random() < 0.10) {
        // Dodge! Sidestep away from player
        g.x += Math.sign(g.x - player.x) * 35;
        g.x = Math.max(30, Math.min(W - 30, g.x));
        spawnParticles(g.x, g.y - 20, '#aaa', 3, 2);
        spawnDamageNumber(g.x, g.y - (g.h || 50), 'SCHIVATA!', '#aaa');
      } else {
        checkTarget(g);
      }
    }
  });
  if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) checkTarget(boss, boss.w / 2);
  if (reginaActive && regina && !regina.dead) checkTarget(regina);
  if (mariusoActive && mariuso && !mariuso.dead) checkTarget(mariuso);

  hitTargets.forEach(t => {
    // === SUPER ARMOR CHECK: boss charging with armor deflects hits ===
    if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
      // Boss absorbs hit: reduced damage, no poise damage, reflects pain back
      const reflectDmg = Math.floor(dmg * 0.25);
      t.hp -= dmg * 0.3; // boss takes only 30% damage
      t.hitFlash = 5;
      // Player gets hurt by reflect
      hurtPlayer(reflectDmg);
      // Visuals: armor sparks + bounce-back
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 8, 4);
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'SUPER ARMOR!', '#ff6f00');
      spawnDamageNumber(player.x, player.y - player.h, '-' + reflectDmg, '#f44336');
      screenShake = 6;
      playSFX('stomp');
      player.vx = -player.facing * 5; // knockback the player
      return; // skip normal hit processing for this target
    }

    // Same-target damage penalty: -20% per consecutive hit, floor 30%
    if (t === player.lastHitTarget) {
      player.sameTargetHits++;
      player.sameTargetTimer = 0;
    } else {
      player.sameTargetHits = 1;
      player.lastHitTarget = t;
      player.sameTargetTimer = 0;
    }
    const sameTargetMult = Math.max(0.3, 1 - (player.sameTargetHits - 1) * 0.2);
    let finalDmg = dmg * sameTargetMult;
    // Boss weapon matchup multiplier
    let matchupMult = 1;
    if (t.isBoss) {
      matchupMult = getBossMatchupMult();
      finalDmg *= matchupMult;
    }
    // Ciccio tank mode: 50% damage reduction in phase 3
    if (t.isBoss && t.ciccioTank) {
      finalDmg *= 0.5;
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 2, 1);
    }
    // Executioner: 2.0x on enemies below 25% HP
    if (isExecutioner && t.hp < (t.maxHp || 100) * 0.25) {
      finalDmg *= 2.0;
    }

    let didStagger = false;
    let didKnockdown = false;

    // Poise system: reduce poise instead of applying knockback/recovery
    if (t.poise !== undefined) {
      t.lastHitTimer = 0; // reset poise recovery timer
      // Track consecutive hits for auto-knockdown
      if (t.consecutiveHitCount !== undefined) {
        t.consecutiveHitCount++;
        t.lastHitByPlayerTimer = 0;
      }

      // Auto-knockdown: 12 consecutive hits forces hard knockdown
      if (t.consecutiveHitCount >= 12) {
        t.staggerTimer = 30;
        t.poise = t.maxPoise; // full poise reset
        t.consecutiveHitCount = 0;
        t.poiseBreakCooldown = 0;
        t.knockbackVx = (t.knockbackVx || 0) + player.facing * 8;
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 12, 6);
        spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'KNOCKDOWN!', '#ffeb3b');
        screenShake = 10;
        playSFX('stomp');
        didKnockdown = true;
      } else if (t.poiseBreakCooldown > 0) {
        // During poise break cooldown: hits deal damage but can't reduce poise below 1
        t.poise = Math.max(1, t.poise - effectivePoise);
        spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
      } else {
        t.poise -= effectivePoise;
        if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
          // POISE BREAK → stagger
          t.staggerTimer = 28;
          t.poise = 0;
          t.poiseBreakCooldown = 70; // 90 frame cooldown before next poise break
          t.consecutiveHitCount = 0;
          finalDmg *= 1.3; // stagger bonus damage
          t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
          spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff9800', 10, 5);
          spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
          screenShake = 8;
          playSFX('stomp');
          // Style bonus coins for stagger break
          spawnCoinPickup(t.x, t.y - 20, 3);
          didStagger = true;
        } else if (t.poise > 0) {
          // Poise held — armor spark, no hitFlash
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        }
      }

      // Warning flash at consecutive hit 5-6 (approaching knockdown)
      if (t.consecutiveHitCount >= 5 && t.consecutiveHitCount < 7 && !didKnockdown) {
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 4, 3);
      }
    } else {
      // Fallback for entities without poise (e.g. old bosses)
      if (!t.isBoss) {
        t.knockbackVx = (t.knockbackVx || 0) + player.facing * (isCrit ? 8 : 5);
      }
    }

    t.hp -= finalDmg;
    // Only set hitFlash on stagger/knockdown, not on armored hits
    if (didStagger || didKnockdown || t.poise === undefined || t.staggerTimer > 0) {
      t.hitFlash = 10;
    }

    // Hitstop
    hitstopFrames = isCrit ? 5 : 3;

    if (isCrit) {
      const label = (dodgeCounter > 0 ? 'COUNTER! ' : 'CRIT! ') + Math.floor(finalDmg);
      spawnDamageNumber(t.x, t.y - (t.h || 50), label, '#ff5722');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff5722', 12, 5);
      screenShake = 8;
      screenFlash = 4;
      flashColor = '#ff5722';
    } else if (dodgeCounter > 0) {
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'COUNTER ' + Math.floor(finalDmg), '#64b5f6');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#64b5f6', 8, 4);
      screenShake = 5;
    } else {
      spawnDamageNumber(t.x, t.y - (t.h || 50), Math.floor(finalDmg), '#ffeb3b');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ffeb3b', 6);
      screenShake = Math.max(screenShake, 3);
    }
    playSFX('hit');

    // Weapon matchup visual feedback on boss
    if (t.isBoss && matchupMult >= 1.2) {
      spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'EFFICACE!', '#4caf50');
    } else if (t.isBoss && matchupMult <= 0.75) {
      spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'RESISTE...', '#888');
    }

    // Combo counter
    player.comboHitCount++;
    player.comboHitTimer = 0;
    levelScore += Math.floor(finalDmg * player.scoreMultiplier);
    if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
    else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
    else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
    else player.scoreMultiplier = 1;

    // Ultra charge accumulation
    if (!player.ultraActive) {
      let chargeGain = 5; // base per hit
      if (isCrit) chargeGain = 8;
      if (didStagger) chargeGain = 15;
      if (player.upgrades.some(u => u.effect === 'ultraVampire')) chargeGain *= 0.9;
      player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + chargeGain);
      if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
    }

    // Bleed DoT: Cacciavite always bleeds (light); Ultra boosts it; Bottiglia ultra-only
    if (weap.special === 'bleed') {
      if (player.ultraActive) {
        t.bleedTimer = 180;
        t.bleedDmg = 2;
      } else if (weap.name === 'Cacciavite') {
        t.bleedTimer = Math.max(t.bleedTimer || 0, 120);
        t.bleedDmg = Math.max(t.bleedDmg || 0, 1);
      }
    }

    // Ultra upgrade mods — trigger during Ultra mode
    if (player.ultraActive) {
      if (player.upgrades.some(u => u.effect === 'ultraFire')) {
        t.bleedTimer = Math.max(t.bleedTimer || 0, 180);
        t.bleedDmg = Math.max(t.bleedDmg || 0, 3);
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 6, 3);
      }
      if (player.upgrades.some(u => u.effect === 'ultraIce')) {
        t.slowTimer = 180; // 3 seconds of 30% slow
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#80d8ff', 6, 3);
      }
      if (player.upgrades.some(u => u.effect === 'ultraShock')) {
        // Chain lightning to nearest other enemy
        const others = goons.filter(g => !g.dead && g !== t && Math.abs(g.x - t.x) < 120);
        if (others.length > 0) {
          const chainTarget = others[0];
          chainTarget.hp -= dmg * 0.4;
          chainTarget.hitFlash = 10;
          spawnParticles(chainTarget.x, chainTarget.y - 25, '#ffeb3b', 8, 4);
          spawnDamageNumber(chainTarget.x, chainTarget.y - (chainTarget.h || 50), 'SHOCK ' + Math.floor(dmg * 0.4), '#ffeb3b');
          if (chainTarget.hp <= 0) { chainTarget.dead = true; totalKills++; spawnCoinPickup(chainTarget.x, chainTarget.y - 20, 8); }
        }
      }
      if (player.upgrades.some(u => u.effect === 'ultraVampire')) {
        const heal = Math.floor(finalDmg * 0.08);
        player.hp = Math.min(player.maxHp, player.hp + heal);
        spawnDamageNumber(player.x, player.y - player.h, '+' + heal, '#4caf50');
      }
    }

    // Crowd pull: last hit/Ultra pulls enemies toward player
    if (isCrowdPull) {
      t.knockbackVx = (t.knockbackVx || 0) + Math.sign(player.x - t.x) * 5;
    }

    if (t.hp <= 0 && !t.isBoss) {
      t.dead = true;
      totalKills++;
      spawnParticles(t.x, t.y - 25, '#ffd700', 12);
      // Coin drops (physical pickups)
      const baseDrop = (t.type === 'tank') ? 14 + Math.floor(Math.random() * 6) : 8 + Math.floor(Math.random() * 4);
      spawnCoinPickup(t.x, t.y - 20, baseDrop);
      playSFX('coin');
    }
  });

  // Sbombo Sword: shockwave + heal + particles on every hit
  if (weap.special === 'sbombo') {
    projectiles.push({
      x: player.x + player.facing * 30,
      y: player.y - 28,
      vx: player.facing * 7,
      vy: 0,
      life: 40,
      damage: dmg * 0.6,
      hostile: false,
      type: 'sbombo_wave',
      poiseDmg: 15,
      piercing: true
    });
    player.hp = Math.min(player.maxHp, player.hp + 5);
    screenShake = 4;
    spawnParticles(player.x + player.facing * 40, player.y - 30, '#ff69b4', 8, 5);
    // Ultra: massive AoE every 3rd hit
    if (player.ultraActive && stepIndex % 3 === 2) {
      projectiles.push({ x: player.x, y: player.y - 28, vx: -10, vy: 0, life: 50, damage: dmg, hostile: false, type: 'sbombo_wave', poiseDmg: 25, piercing: true });
      projectiles.push({ x: player.x, y: player.y - 28, vx: 10, vy: 0, life: 50, damage: dmg, hostile: false, type: 'sbombo_wave', poiseDmg: 25, piercing: true });
      screenShake = 12;
      spawnParticles(player.x, player.y - 30, '#ffd700', 20, 8);
    }
  }

  // La Lupa legendaryShockwave: shockwave during Ultra
  if (weap.special === 'legendaryShockwave' && player.ultraActive) {
    projectiles.push({
      x: player.x + player.facing * 30,
      y: player.y - 28,
      vx: player.facing * 8,
      vy: 0,
      life: 45,
      damage: weap.damage * 1.5,
      hostile: false,
      type: 'shockwave',
      poiseDmg: weap.poise * 2,
      piercing: true
    });
    screenShake = 10;
    spawnParticles(player.x, player.y - 30, '#ffd700', 15, 6);
  }
}

// Overhead: Up + Attack — slow overhead slam, 2x poise damage
function playerOverhead() {
  if (player.dead || player.stunTimer > 0 || player.endLagTimer > 0 || player.exhaustedTimer > 0) return;
  player.stamina = Math.max(0, player.stamina - 28);
  player.staminaRegenDelay = 30;
  player.attacking = true;
  player.attackActiveTimer = 12;
  player.attackTimer = 12;
  player.endLagTimer = 18;

  const weap = weapons[player.weapon];
  const dmg = weap.damage * 1.4;
  const range = weap.range * 0.9;
  const attackX = player.x + player.facing * range * 0.5;
  const poiseMult = player.upgrades.some(u => u.effect === 'poise25') ? 1.25 : 1;
  const effectivePoise = Math.round(weap.poise * poiseMult);

  const targets = [...goons.filter(g => !g.dead)];
  if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) targets.push(boss);

  targets.forEach(t => {
    if (Math.abs(attackX - t.x) < range * 0.7 + (t.w || 30) / 2 && Math.abs(player.y - t.y) < 50) {
      t.hp -= dmg;
      // 2x poise damage
      if (t.poise !== undefined) {
        t.lastHitTimer = 0;
        if (t.consecutiveHitCount !== undefined) {
          t.consecutiveHitCount++;
          t.lastHitByPlayerTimer = 0;
        }
        const poiseDmg = effectivePoise * 2;
        if (t.poiseBreakCooldown > 0) {
          t.poise = Math.max(1, t.poise - poiseDmg);
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        } else {
          t.poise -= poiseDmg;
          if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
            t.staggerTimer = 28;
            t.poise = 0;
            t.poiseBreakCooldown = 70;
            t.consecutiveHitCount = 0;
            t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
            spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
            spawnCoinPickup(t.x, t.y - 20, 3);
            t.hitFlash = 10;
          } else {
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          }
        }
      }
      t.hitFlash = 10;
      t.knockbackVx = (t.knockbackVx || 0) + player.facing * 3;
      spawnDamageNumber(t.x, t.y - (t.h || 50), 'OVERHEAD! ' + Math.floor(dmg), '#ff9800');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff9800', 12, 5);
      screenShake = 10;
      playSFX('stomp');
      player.comboHitCount++;
      player.comboHitTimer = 0;
      levelScore += Math.floor(dmg * player.scoreMultiplier);
      if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
      else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
      else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
      else player.scoreMultiplier = 1;
      // Ultra charge from overhead
      if (!player.ultraActive) {
        player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 4);
        if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
      }
      if (t.hp <= 0 && !t.isBoss) {
        t.dead = true;
        totalKills++;
        spawnParticles(t.x, t.y - 25, '#ffd700', 12);
        spawnCoinPickup(t.x, t.y - 20, 20);
        playSFX('coin');
      }
    }
  });
  spawnParticles(player.x + player.facing * 20, player.y - 20, '#ff9800', 10, 4);
}

// Jump attack: standalone aerial attack (not part of combo chain)
function playerJumpAttack() {
  if (player.dead || player.grounded || player.jumpAttacking) return;
  player.jumpAttacking = true;
  player.attacking = true;
  player.attackTimer = 8;
  player.attackActiveTimer = 8;

  const weap = weapons[player.weapon];
  const dmg = weap.damage * 1.2;
  const range = weap.range;
  const attackX = player.x + player.facing * range * 0.5;
  const poiseMult = player.upgrades.some(u => u.effect === 'poise25') ? 1.25 : 1;
  const effectivePoise = Math.round(weap.poise * poiseMult);

  // Ranged weapon shoots downward-angled bullet
  if (weap.ranged) {
    projectiles.push({
      x: player.x + player.facing * 20, y: player.y - 20,
      vx: player.facing * 10, vy: 3,
      life: 40, damage: dmg, hostile: false, type: 'bullet', poiseDmg: effectivePoise
    });
    return;
  }

  const targets = [...goons.filter(g => !g.dead)];
  if (boss && !boss.dead) targets.push(boss);
  if (reginaActive && regina && !regina.dead) targets.push(regina);
  if (mariusoActive && mariuso && !mariuso.dead) targets.push(mariuso);

  targets.forEach(t => {
    if (Math.abs(attackX - t.x) < range * 0.7 + (t.w || 30) / 2 && Math.abs(player.y - t.y) < 60) {
      // Super armor: overhead bounces off charging boss
      if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
        t.hp -= dmg * 0.3;
        t.hitFlash = 5;
        hurtPlayer(Math.floor(dmg * 0.2));
        spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 8, 4);
        spawnDamageNumber(t.x, t.y - (t.h || 50), 'SUPER ARMOR!', '#ff6f00');
        player.vx = -player.facing * 5;
        screenShake = 6;
        playSFX('stomp');
        return;
      }
      const launchBonus = (t.launched && t.launched > 0) ? 1.5 : 1;
      t.hp -= dmg * launchBonus;
      let didStagger = false;
      if (t.poise !== undefined) {
        t.lastHitTimer = 0;
        if (t.consecutiveHitCount !== undefined) {
          t.consecutiveHitCount++;
          t.lastHitByPlayerTimer = 0;
        }
        if (t.poiseBreakCooldown > 0) {
          t.poise = Math.max(1, t.poise - effectivePoise);
          spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
        } else {
          t.poise -= effectivePoise;
          if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
            t.staggerTimer = 28;
            t.poise = 0;
            t.poiseBreakCooldown = 70;
            t.consecutiveHitCount = 0;
            t.knockbackVx = (t.knockbackVx || 0) + player.facing * 6;
            spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
            spawnCoinPickup(t.x, t.y - 20, 3);
            didStagger = true;
          } else if (t.poise > 0) {
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          }
        }
      }
      if (didStagger || t.poise === undefined || t.staggerTimer > 0) t.hitFlash = 10;
      const airLabel = launchBonus > 1 ? 'AIR JUGGLE! ' + Math.floor(dmg * launchBonus) : 'AIR ' + Math.floor(dmg);
      spawnDamageNumber(t.x, t.y - (t.h || 50), airLabel, launchBonus > 1 ? '#ffeb3b' : '#80d8ff');
      spawnParticles(t.x, t.y - (t.h || 50) / 2, '#80d8ff', 8, 4);
      hitstopFrames = 4;
      screenShake = 5;
      playSFX('hit');
      player.comboHitCount++;
      player.comboHitTimer = 0;
      levelScore += Math.floor(dmg * launchBonus * player.scoreMultiplier);
      if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
      else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
      else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
      else player.scoreMultiplier = 1;
      if (t.hp <= 0 && !t.isBoss) {
        t.dead = true;
        totalKills++;
        spawnParticles(t.x, t.y - 25, '#ffd700', 12);
        spawnCoinPickup(t.x, t.y - 20, 6 + Math.floor(Math.random() * 3));
        spawnCoinPickup(t.x, t.y - 30, 4);
        playSFX('coin');
      }
    }
  });
}

// Check bullet/shockwave projectiles against enemies
function checkBulletHits() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    if (p.hostile || (p.type !== 'bullet' && p.type !== 'shockwave' && p.type !== 'sbombo_wave')) continue;

    const targets = [...goons.filter(g => !g.dead)];
    // Only target boss after intro (don't hit offscreen boss during waves)
    if (boss && !boss.dead && bossIntro && bossIntroTimer <= 0) targets.push(boss);
    if (reginaActive && regina && !regina.dead) targets.push(regina);
    if (mariusoActive && mariuso && !mariuso.dead) targets.push(mariuso);

    let hitSomething = false;
    for (const t of targets) {
      if (Math.abs(p.x - t.x) < 20 && Math.abs(p.y - (t.y - (t.h||50)/2)) < 30) {
        // Super armor: projectiles deflect off charging boss
        if (t === boss && t.isBoss && boss.bossState === 'attack' && boss.currentMove && boss.currentMove.superArmor) {
          t.hp -= (p.damage || weapons[0].damage) * 0.3;
          t.hitFlash = 3;
          spawnParticles(t.x, t.y - (t.h || 50) / 2, '#ff6f00', 4, 2);
          spawnDamageNumber(t.x, t.y - (t.h || 50), 'DEFLECT!', '#ff6f00');
          if (!p.piercing) { hitSomething = true; }
          continue;
        }
        let dmg = p.damage || weapons[0].damage;
        // Apply boss weapon matchup to projectiles
        let projMatchup = 1;
        if (t.isBoss) {
          projMatchup = getBossMatchupMult();
          dmg *= projMatchup;
        }
        // Ciccio tank mode: 50% bullet damage reduction
        if (t.isBoss && t.ciccioTank) dmg *= 0.5;
        t.hp -= dmg;
        let didStagger = false;
        // Apply poise damage
        if (t.poise !== undefined && p.poiseDmg) {
          t.lastHitTimer = 0;
          if (t.consecutiveHitCount !== undefined) {
            t.consecutiveHitCount++;
            t.lastHitByPlayerTimer = 0;
          }
          if (t.poiseBreakCooldown > 0) {
            t.poise = Math.max(1, t.poise - p.poiseDmg);
            spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
          } else {
            t.poise -= p.poiseDmg;
            if (t.poise <= 0 && (!t.staggerTimer || t.staggerTimer <= 0)) {
              t.staggerTimer = 28;
              t.poise = 0;
              t.poiseBreakCooldown = 70;
              t.consecutiveHitCount = 0;
              t.knockbackVx = (t.knockbackVx || 0) + Math.sign(p.vx) * 6;
              spawnDamageNumber(t.x, t.y - (t.h || 50) - 10, 'STAGGER!', '#ff9800');
              spawnCoinPickup(t.x, t.y - 20, 3);
              didStagger = true;
            } else if (t.poise > 0) {
              spawnArmorSpark(t.x, t.y - (t.h || 50) / 2);
            }
          }
        }
        if (didStagger || t.poise === undefined || t.staggerTimer > 0) t.hitFlash = 10;
        spawnDamageNumber(t.x, t.y - (t.h||50), Math.floor(dmg), '#ffeb3b');
        spawnParticles(t.x, t.y - (t.h||50)/2, '#ffeb3b', 6);
        if (t.hp <= 0 && !t.isBoss) {
          t.dead = true;
          totalKills++;
          spawnParticles(t.x, t.y - 25, '#ffd700', 12);
          spawnCoinPickup(t.x, t.y - 20, 6 + Math.floor(Math.random() * 3));
          playSFX('coin');
        }
        playSFX('hit');
        // Projectile matchup feedback on boss
        if (t.isBoss && projMatchup >= 1.2) {
          spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'EFFICACE!', '#4caf50');
        } else if (t.isBoss && projMatchup <= 0.75) {
          spawnDamageNumber(t.x + 20, t.y - (t.h || 50) - 15, 'RESISTE...', '#888');
        }
        player.comboHitCount++;
        player.comboHitTimer = 0;
        levelScore += Math.floor(dmg * player.scoreMultiplier);
        if (player.comboHitCount >= 30) player.scoreMultiplier = 3;
        else if (player.comboHitCount >= 15) player.scoreMultiplier = 2;
        else if (player.comboHitCount >= 5) player.scoreMultiplier = 1.5;
        else player.scoreMultiplier = 1;
        hitSomething = true;
        if (!p.piercing) break;
      }
    }
    if (hitSomething && !p.piercing) {
      projectiles.splice(i, 1);
    }
  }
}

// ==========================================
// BOSS AI
// ==========================================
function createBoss(levelIdx) {
  const lvl = levels[levelIdx];
  const b = {
    x: 700, y: 430, w: 44, h: 60,
    vx: 0, vy: 0,
    hp: lvl.bossHp * DIFF_HP[difficulty], maxHp: lvl.bossHp * DIFF_HP[difficulty],
    speed: 2.2 + levelIdx * 0.3,
    facing: -1,
    attackTimer: 0,
    attackCooldown: 60,
    hitFlash: 0,
    stunTimer: 0,
    dead: false,
    isBoss: true,
    phase: 0,
    onMoped: false,
    specialTimer: 0,
    chargeTimer: 0,
    windingUp: false,
    windupTimer: 0,
    recoveryTimer: 0,
    // State machine
    bossPhase: 1,
    bossState: 'idle',
    stateTimer: 0,
    currentMove: null,
    moveData: {},
    // Poise
    poise: [52, 60, 85, 60, 52][levelIdx],
    maxPoise: [52, 60, 85, 60, 52][levelIdx],
    poiseRecovery: 0.45,
    staggerTimer: 0,
    lastHitTimer: 999,
    poiseBreakCooldown: 0,
    consecutiveHitCount: 0,
    lastHitByPlayerTimer: 999,
    bleedTimer: 0,
    bleedDmg: 0
  };

  if (levelIdx === 2) { b.h = 80; b.w = 48; } // Dale is tall
  if (levelIdx === 3) { b.w = 52; } // Ciccio is wider
  if (levelIdx === 4) { b.h = 108; b.w = 57; b.drawScale = 1.5; } // Pisellino 50% bigger

  return b;
}

function triggerPhaseTransition(text, color) {
  phaseTransitionTimer = 90;
  phaseTransitionText = text;
  phaseTransitionColor = color || '#e94560';
  screenShake = 15;
  screenFlash = 10;
  flashColor = color || '#e94560';
  if (boss) boss.stunTimer = 60;
}

function updateBossAI() {
  if (!boss || boss.dead || boss.stunTimer > 0) {
    if (boss && boss.stunTimer > 0) boss.stunTimer--;
    return;
  }

  // Interrogation special: Ultra slows boss
  const savedBossSpeed = boss.speed;
  if (player.ultraActive && weapons[0].special === 'interrogation') boss.speed *= 0.6;

  boss.hitFlash = Math.max(0, boss.hitFlash - 1);
  boss.attackTimer = Math.max(0, boss.attackTimer - 1);
  boss.specialTimer++;

  // Boss poise break cooldown
  if (boss.poiseBreakCooldown > 0) boss.poiseBreakCooldown--;
  // Boss consecutive hit tracking
  boss.lastHitByPlayerTimer++;
  if (boss.lastHitByPlayerTimer > 45) boss.consecutiveHitCount = 0;

  // Boss poise recovery
  if (boss.lastHitTimer !== undefined) {
    boss.lastHitTimer++;
    if (boss.lastHitTimer > 40 && boss.poise < boss.maxPoise && boss.poiseBreakCooldown <= 0) {
      boss.poise = Math.min(boss.maxPoise, boss.poise + (boss.poiseRecovery || 0.3));
    }
    // Boss stagger — interrupts telegraph
    if (boss.staggerTimer > 0) {
      boss.staggerTimer--;
      if (boss.staggerTimer <= 0) boss.poise = boss.maxPoise;
      if (boss.bossState === 'telegraph') {
        boss.bossState = 'recovery';
        boss.stateTimer = 20;
      }
      return;
    }
    // Boss bleed
    if (boss.bleedTimer > 0) {
      boss.bleedTimer--;
      if (boss.bleedTimer % 60 === 0) {
        boss.hp -= boss.bleedDmg;
        spawnParticles(boss.x, boss.y - 30, '#b71c1c', 3, 2);
        spawnDamageNumber(boss.x, boss.y - boss.h, boss.bleedDmg, '#b71c1c');
      }
    }
  }

  const dx = player.x - boss.x;
  const dist = Math.abs(dx);
  boss.facing = dx > 0 ? 1 : -1;

  // Phase transitions based on HP
  if (boss.bossPhase === 1 && boss.hp < boss.maxHp * 0.6) {
    boss.bossPhase = 2;
    boss.bossState = 'idle';
    boss.stateTimer = 0;
    const phaseTexts = [
      '"Sono pazzo... SONO PAZZO DI TE!"',
      '"In gabbia m\'hanno insegnato! REGINAAAA!"',
      '"DALEEEEE! BASTA! SO\' INCAZZATO!"',
      '"ER FORNO E\' APERTO! PIZZA INFERNALE!"',
      '"Time to ride bro! Er motorino della morte!"'
    ];
    triggerPhaseTransition(phaseTexts[currentLevel], levels[currentLevel].bossColor);
    // Level 1: summon Regina in phase 2
    if (currentLevel === 1 && !reginaActive) {
      reginaActive = true;
      regina = {
        x: W + 50, y: 430, w: 32, h: 50,
        hp: 120 * DIFF_HP[difficulty], maxHp: 120 * DIFF_HP[difficulty],
        hitFlash: 0, stunTimer: 0, dead: false,
        throwTimer: 0, entering: true,
        poise: 30, maxPoise: 30, poiseRecovery: 0.45, staggerTimer: 0, lastHitTimer: 999,
        poiseBreakCooldown: 0, consecutiveHitCount: 0, lastHitByPlayerTimer: 999,
        bleedTimer: 0, bleedDmg: 0
      };
    }
  }
  if (boss.bossPhase === 2 && boss.hp < boss.maxHp * 0.3) {
    boss.bossPhase = 3;
    boss.bossState = 'idle';
    boss.stateTimer = 0;
    const phase3Texts = [
      '"Preparate Conte... PREPARATE!"',
      '"In gabbia sognavo sto momento! MO\' PAGHI!"',
      '"DALE DALE DALEEEE! BASTA!"',
      '"HAI VISTO ER MOHAWK?! CE STA IL FUOCO!"',
      '"STO PER CONTO MIO NOW bro! This is MINE!"'
    ];
    triggerPhaseTransition(phase3Texts[currentLevel], '#f44336');
    // Ciccio phase 3: massive size + tank mode + fire aura
    if (currentLevel === 3) {
      boss.w = 72;
      boss.h = 78;
      boss.maxPoise = 120; // massive poise — very hard to stagger
      boss.poise = 120;
      boss.poiseRecovery = 0.8; // fast poise regen
      boss.ciccioTank = true; // flag for 50% damage reduction
      spawnParticles(boss.x, boss.y - 40, '#ff6f00', 25, 8);
      spawnParticles(boss.x, boss.y - 30, '#f44336', 15, 6);
      screenFlash = 8;
      flashColor = '#ff6f00';
      screenShake = 16;
      showQuickText('"SONO DIVENTATO ENORME! ER FORNO BRUCIA!"', '#ff3d00');
    }
    // Level 4: summon Mariuso in phase 3
    if (currentLevel === 4 && !mariusoActive) {
      mariusoActive = true;
      mariuso = {
        x: W + 60, y: 430, w: 50, h: 60,
        hp: 200 * DIFF_HP[difficulty], maxHp: 200 * DIFF_HP[difficulty],
        hitFlash: 0, stunTimer: 0, dead: false,
        attackTimer: 0, isBoss: false, entering: true,
        poise: 50, maxPoise: 50, poiseRecovery: 0.45, staggerTimer: 0, lastHitTimer: 999,
        poiseBreakCooldown: 0, consecutiveHitCount: 0, lastHitByPlayerTimer: 999,
        bleedTimer: 0, bleedDmg: 0
      };
    }
    boss.speed *= 1.2;
  }

  // State machine
  boss.stateTimer--;

  switch(boss.bossState) {
    case 'idle':
      // SYNERGY: Pisellino hangs back when Mariuso is active (let uncle do melee)
      if (currentLevel === 4 && mariusoActive && mariuso && !mariuso.dead) {
        if (dist < 150) boss.x -= Math.sign(dx) * boss.speed * 0.6; // retreat
        else if (dist > 250) boss.x += Math.sign(dx) * boss.speed * 0.3; // keep in range for shots
      } else {
        // Normal approach — later bosses are more aggressive
        const approachMult = 0.8 + currentLevel * 0.1;
        if (dist > 80) boss.x += Math.sign(dx) * boss.speed * approachMult;
        else if (dist < 50) boss.x -= Math.sign(dx) * boss.speed * 0.5;
      }
      // Slight weave — more agitated in later levels
      boss.x += Math.sin(boss.specialTimer * 0.03) * (0.5 + currentLevel * 0.2);

      // Counter-attack system: if player is attacking within range, chance to counter
      // Later levels have higher counter chance
      if (player.attackActiveTimer > 0 && dist < 80 && boss.staggerTimer <= 0) {
        const levelBonus = currentLevel * 0.008;
        const counterChance = (boss.bossPhase === 3 ? 0.03 : boss.bossPhase === 2 ? 0.02 : 0.01) + levelBonus;
        if (Math.random() < counterChance) {
          // Immediate counter with halved telegraph time
          boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, dist);
          boss.bossState = 'telegraph';
          boss.stateTimer = Math.floor((boss.currentMove.telegraphFrames || 15) * 0.5);
          boss.moveData = {};
          spawnDamageNumber(boss.x, boss.y - boss.h - 10, '!', '#f44336');
          break;
        }
      }

      if (boss.stateTimer <= 0) {
        // Pick a move
        boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, dist);
        boss.bossState = 'telegraph';
        boss.stateTimer = boss.currentMove.telegraphFrames || 15;
        boss.moveData = {};
      }
      break;

    case 'telegraph':
      // Boss flashes warning, can be interrupted by stagger
      if (boss.stateTimer <= 0) {
        boss.bossState = 'attack';
        boss.stateTimer = boss.currentMove.attackFrames || 20;
        boss.moveData.started = true;
      }
      break;

    case 'attack':
      // Execute the current move
      executeBossMove(boss.currentMove, dx, dist);
      if (boss.stateTimer <= 0) {
        boss.bossState = 'recovery';
        boss.stateTimer = boss.currentMove.recoveryFrames || 30;
      }
      break;

    case 'recovery':
      // Vulnerability window — boss moves slowly
      if (dist > 100) boss.x += Math.sign(dx) * boss.speed * 0.3;
      if (boss.stateTimer <= 0) {
        boss.bossState = 'idle';
        // Later levels = shorter idle = more aggressive
        const idleBase = Math.max(10, 30 - currentLevel * 5);
        const idleRand = Math.max(10, 30 - currentLevel * 4);
        boss.stateTimer = idleBase + Math.floor(Math.random() * idleRand);
      }
      break;
  }

  // Keep boss in bounds
  boss.x = Math.max(50, Math.min(W - 50, boss.x));

  // Update Regina (L1 helper)
  if (reginaActive && regina && !regina.dead) updateReginaAI();
  // Update Mariuso (L4 helper)
  if (mariusoActive && mariuso && !mariuso.dead) updateMariusoAI();

  // Restore boss speed after interrogation slow
  boss.speed = savedBossSpeed;
}

// Boss move selection per level and phase
function pickBossMove(level, phase, dist) {
  const moves = BOSS_MOVES[level] || BOSS_MOVES[0];
  const available = moves.filter(m => m.phase <= phase && (m.minDist === undefined || dist >= m.minDist) && (m.maxDist === undefined || dist <= m.maxDist));
  // Weighted random selection
  const totalW = available.reduce((s, m) => s + (m.weight || 1), 0);
  let r = Math.random() * totalW;
  for (const m of available) {
    r -= (m.weight || 1);
    if (r <= 0) return m;
  }
  return available[available.length - 1] || moves[0];
}

// Execute a boss move during attack state
function executeBossMove(move, dx, dist) {
  if (!move || !move.execute) return;
  move.execute(dx, dist, boss.stateTimer, boss.moveData);
}

// Boss move definitions per level
const BOSS_MOVES = {
  // LaFedeltà — rugby rapper narcisista
  0: [
    { name: 'rugby_tackle', phase: 1, telegraphFrames: 20, attackFrames: 30, recoveryFrames: 35, weight: 4, minDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        // Wind up low, then charge across screen
        if (timer > 25) {
          // Crouch telegraph — boss dips down
          if (!data.yelled) { data.yelled = true; showQuickText('"PLACCAGGIO!"', '#ffd54f'); }
        } else if (timer > 5) {
          // Full sprint charge
          const spd = boss.bossPhase >= 3 ? 11 : 9;
          boss.x += boss.facing * spd;
          // Dust trail
          if (timer % 3 === 0) spawnParticles(boss.x - boss.facing * 20, boss.y, '#8d6e63', 2, 2);
          // Hit detection throughout charge
          if (Math.abs(boss.x - player.x) < 45 && Math.abs(boss.y - player.y) < 40 && !data.hit) {
            data.hit = true;
            const dmg = boss.bossPhase >= 2 ? 30 : 24;
            hurtPlayer(dmg);
            player.vx = boss.facing * 8; // knockback
            screenShake = 12;
            spawnParticles(player.x, player.y - 20, '#ffd54f', 10, 4);
            showQuickText('"META!"', '#ffd54f');
          }
        } else {
          // Brake - skid to stop
          if (timer === 5) spawnParticles(boss.x, boss.y, '#8d6e63', 6, 3);
        }
        // Clamp to screen
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'shoulder_charge', phase: 1, telegraphFrames: 14, attackFrames: 18, recoveryFrames: 28, weight: 3, minDist: 40, superArmor: true,
      execute(dx, dist, timer, data) {
        // Short burst forward with shoulder
        boss.x += boss.facing * 6;
        if (timer === 12 && dist < 65) {
          hurtPlayer(20);
          player.vx = boss.facing * 5;
          screenShake = 6;
          spawnParticles(player.x, player.y - 20, '#ffd54f', 5);
        }
      }},
    { name: 'knife_combo', phase: 1, telegraphFrames: 12, attackFrames: 20, recoveryFrames: 25, weight: 2, maxDist: 70,
      execute(dx, dist, timer, data) {
        if (timer === 16 && dist < 60) { hurtPlayer(18); screenShake = 4; }
        if (timer === 8 && dist < 60) { hurtPlayer(20); screenShake = 5; }
      }},
    { name: 'smoke_bomb', phase: 2, telegraphFrames: 14, attackFrames: 25, recoveryFrames: 20, weight: 2,
      execute(dx, dist, timer, data) {
        if (timer === 22 && !data.smoked) {
          data.smoked = true;
          spawnParticles(boss.x, boss.y - 20, '#888', 20, 6);
          screenShake = 4;
        }
        if (timer === 10) {
          boss.x = player.x - boss.facing * 80;
          spawnParticles(boss.x, boss.y - 20, '#888', 10, 3);
          if (dist < 70) { hurtPlayer(22); }
        }
      }},
    { name: 'rugby_blitz', phase: 2, telegraphFrames: 22, attackFrames: 40, recoveryFrames: 40, weight: 3, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        // Phase 2+: charges back and forth twice
        if (!data.charges) data.charges = 0;
        if (timer > 5) {
          const spd = boss.bossPhase >= 3 ? 12 : 10;
          if (data.charges === 0) {
            boss.x += boss.facing * spd;
          } else {
            boss.x -= boss.facing * spd;
          }
          if (timer % 3 === 0) spawnParticles(boss.x - boss.facing * 15, boss.y, '#8d6e63', 2, 2);
          // Switch direction at halfway
          if (timer === 20 && data.charges === 0) {
            data.charges = 1;
            spawnParticles(boss.x, boss.y, '#ffd54f', 8, 3);
            screenShake = 6;
          }
          // Hit detection
          if (Math.abs(boss.x - player.x) < 45 && Math.abs(boss.y - player.y) < 40) {
            if (!data.hit1 && data.charges === 0) {
              data.hit1 = true;
              hurtPlayer(boss.bossPhase >= 3 ? 25 : 20);
              player.vx = boss.facing * 6;
              screenShake = 8;
            }
            if (!data.hit2 && data.charges === 1) {
              data.hit2 = true;
              hurtPlayer(boss.bossPhase >= 3 ? 28 : 23);
              player.vx = -boss.facing * 6;
              screenShake = 10;
              showQuickText('"ANDATA E RITORNO!"', '#ffd54f');
            }
          }
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'desperation_flurry', phase: 3, telegraphFrames: 15, attackFrames: 30, recoveryFrames: 40, weight: 3, maxDist: 80,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 3;
        if (timer % 7 === 0 && dist < 65) {
          hurtPlayer(15 + Math.floor(Math.random() * 5));
          screenShake = 4;
          spawnParticles(player.x, player.y - 20, '#ffd54f', 4);
        }
      }},
    { name: 'taunt_heal', phase: 2, telegraphFrames: 10, attackFrames: 50, recoveryFrames: 20, weight: 2,
      execute(dx, dist, timer, data) {
        // Taunts for 50 frames, heals 3% HP if not interrupted by stagger
        if (timer === 45 && !data.taunted) { data.taunted = true; showQuickText('"TROPPO BELLO PER TE!"', '#ffd54f'); }
        if (timer === 1 && boss.staggerTimer <= 0) {
          const heal = Math.floor(boss.maxHp * 0.03);
          boss.hp = Math.min(boss.maxHp, boss.hp + heal);
          spawnDamageNumber(boss.x, boss.y - boss.h, '+' + heal, '#4caf50');
          spawnParticles(boss.x, boss.y - 30, '#4caf50', 8, 3);
        }
      }},
    { name: 'scarf_throw', phase: 1, telegraphFrames: 10, attackFrames: 10, recoveryFrames: 25, weight: 1, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 8 && !data.thrown) {
          data.thrown = true;
          const count = boss.bossPhase >= 2 ? 2 : 1;
          for (let i = 0; i < count; i++) {
            projectiles.push({ x: boss.x, y: boss.y - 30, vx: boss.facing * 5 + (i === 1 ? boss.facing * 1.5 : 0), vy: -2, life: 80, damage: boss.bossPhase >= 3 ? 16 : 12, hostile: true, type: 'scarf', gravity: true });
          }
        }
      }},
  ],
  // Gioacchino — heavy enforcer
  1: [
    { name: 'ground_pound', phase: 1, telegraphFrames: 18, attackFrames: 50, recoveryFrames: 40, weight: 2, minDist: 40, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 45) boss.y -= 70;
        if (timer === 20) {
          boss.y = 430;
          screenShake = 18;
          if (Math.abs(boss.x - player.x) < 110) hurtPlayer(boss.bossPhase >= 3 ? 40 : 32);
          spawnParticles(boss.x, boss.y, '#795548', 20, 6);
        }
      }},
    { name: 'charge_tackle', phase: 1, telegraphFrames: 18, attackFrames: 25, recoveryFrames: 35, weight: 2, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 8;
        if (Math.abs(boss.x - player.x) < 40 && Math.abs(boss.y - player.y) < 40) {
          if (!data.hit) { hurtPlayer(boss.bossPhase >= 2 ? 30 : 25); data.hit = true; screenShake = 8; }
        }
      }},
    { name: 'baton_combo', phase: 1, telegraphFrames: 18, attackFrames: 25, recoveryFrames: 25, weight: 3, maxDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 20 && dist < 80) { hurtPlayer(25); screenShake = 5; spawnParticles(player.x, player.y - 20, '#795548', 5); }
        if (timer === 10 && dist < 80 && boss.bossPhase >= 2) { hurtPlayer(18); screenShake = 4; showQuickText('"DOPPIO BASTONE!"', '#6d4c41'); }
      }},
    { name: 'grab_slam', phase: 2, telegraphFrames: 20, attackFrames: 30, recoveryFrames: 35, weight: 2, maxDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 25 && dist < 55 && !data.grabbed) {
          data.grabbed = true;
          player.stunTimer = 25;
          showQuickText('"TE TENGO!"', '#6d4c41');
        }
        if (timer === 5 && data.grabbed) {
          hurtPlayer(38);
          screenShake = 12;
          spawnParticles(player.x, player.y, '#795548', 15, 5);
          showQuickText('"SBAM!"', '#6d4c41');
        }
      }},
    { name: 'guard_counter', phase: 2, telegraphFrames: 12, attackFrames: 40, recoveryFrames: 25, weight: 2, maxDist: 100,
      execute(dx, dist, timer, data) {
        // Guards for 40 frames; if hit during guard → counter-attacks for 30 dmg
        if (timer === 38 && !data.announced) { data.announced = true; showQuickText('"In gabbia ho imparato a para\'! PROVACE!"', '#6d4c41'); }
        // Check if boss got hit during guard
        if (!data.countered && boss.staggerTimer <= 0 && boss.lastHitTimer < 3 && timer > 5) {
          data.countered = true;
          // Refund damage: heal what was just taken
          boss.hp = Math.min(boss.maxHp, boss.hp + 20);
          hurtPlayer(30);
          screenShake = 10;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 10, 4);
          showQuickText('"CONTRATTACCO!"', '#ff6f00');
          spawnDamageNumber(boss.x, boss.y - boss.h, 'GUARD!', '#ff6f00');
        }
        // Visual: boss braces/shimmers
        if (timer % 4 === 0 && !data.countered) spawnParticles(boss.x, boss.y - 30, '#795548', 1, 1);
      }},
    { name: 'rage_flurry', phase: 3, telegraphFrames: 20, attackFrames: 45, recoveryFrames: 45, weight: 3, maxDist: 90,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 4;
        if (timer % 8 === 0 && dist < 80) {
          hurtPlayer(18);
          screenShake = 5;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 4);
        }
      }},
  ],
  // Dale — agile capoeira fighter, acrobatic and unpredictable
  2: [
    { name: 'flying_kick', phase: 1, telegraphFrames: 8, attackFrames: 20, recoveryFrames: 30, weight: 3, minDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 12;
        if (timer > 14) boss.y -= 3; // rises
        else if (timer > 8) boss.y += 3; // descends
        if (timer === 10 && Math.abs(boss.x - player.x) < 65) {
          hurtPlayer(boss.bossPhase >= 3 ? 34 : 28);
          screenShake = 10;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 10, 5);
          showQuickText('"DALE KICK!"', '#90a4ae');
        }
        if (timer === 1) boss.y = 430; // ensure grounded
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'capoeira_spin', phase: 1, telegraphFrames: 10, attackFrames: 25, recoveryFrames: 25, weight: 3, maxDist: 120,
      execute(dx, dist, timer, data) {
        // Spinning kick — hits twice, moves toward player
        boss.x += boss.facing * 4;
        if (timer % 3 === 0) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 2, 3);
        if (timer === 18 && dist < 80) {
          hurtPlayer(boss.bossPhase >= 2 ? 22 : 18);
          screenShake = 6;
          showQuickText('"GIRA DALE!"', '#90a4ae');
        }
        if (timer === 8 && dist < 80) {
          hurtPlayer(boss.bossPhase >= 3 ? 26 : 20);
          player.vx = boss.facing * 5;
          screenShake = 8;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 8, 4);
        }
      }},
    { name: 'sweep_kick', phase: 1, telegraphFrames: 8, attackFrames: 12, recoveryFrames: 28, weight: 2, maxDist: 100,
      execute(dx, dist, timer, data) {
        if (timer === 6 && dist < 90 && player.grounded) {
          hurtPlayer(24);
          player.stunTimer = 20;
          screenShake = 6;
          showQuickText('"SWEEP!"', '#90a4ae');
          spawnParticles(boss.x + boss.facing * 40, boss.y, '#90a4ae', 6, 3);
        }
      }},
    { name: 'wall_bounce', phase: 2, telegraphFrames: 10, attackFrames: 30, recoveryFrames: 30, weight: 3, minDist: 60, superArmor: true,
      execute(dx, dist, timer, data) {
        // Charges to wall, bounces off, attacks from other side
        if (!data.phase) data.phase = 0;
        if (data.phase === 0) {
          boss.x += boss.facing * 14;
          if (boss.x <= 40 || boss.x >= W - 40) {
            data.phase = 1;
            boss.facing *= -1;
            spawnParticles(boss.x, boss.y - 30, '#ffeb3b', 10, 4);
            screenShake = 6;
            showQuickText('"RIMBALZO!"', '#90a4ae');
          }
        } else {
          boss.x += boss.facing * 16;
          if (Math.abs(boss.x - player.x) < 55 && Math.abs(boss.y - player.y) < 45 && !data.hit) {
            data.hit = true;
            hurtPlayer(boss.bossPhase >= 3 ? 36 : 30);
            player.vx = boss.facing * 7;
            screenShake = 12;
            spawnParticles(player.x, player.y - 20, '#ff6f00', 12, 5);
          }
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'counter_stance', phase: 2, telegraphFrames: 6, attackFrames: 25, recoveryFrames: 18, weight: 2,
      execute(dx, dist, timer, data) {
        // If hit during this window, teleport behind and strike
        if (!data.countered && boss.staggerTimer <= 0 && timer > 5) {
          if (boss.lastHitTimer < 3) {
            data.countered = true;
            boss.x = player.x - boss.facing * 60;
            boss.facing *= -1;
            spawnParticles(boss.x, boss.y - 30, '#90a4ae', 10, 4);
            hurtPlayer(32);
            screenShake = 8;
            showQuickText('"COUNTER!"', '#ff6f00');
          }
        }
        if (timer % 4 === 0 && !data.countered) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 1, 1);
      }},
    { name: 'dale_ground_pound', phase: 2, telegraphFrames: 12, attackFrames: 30, recoveryFrames: 30, weight: 2,
      execute(dx, dist, timer, data) {
        // Jump up, slam down with shockwaves
        if (timer === 26) { boss.y -= 90; spawnParticles(boss.x, boss.y + 40, '#90a4ae', 8, 4); showQuickText('"DALE SLAM!"', '#90a4ae'); }
        if (timer === 12 && !data.slammed) {
          data.slammed = true;
          boss.y = 430;
          screenShake = 16;
          if (dist < 80 && player.grounded) { hurtPlayer(30); spawnParticles(player.x, player.y - 20, '#90a4ae', 10); }
          projectiles.push({ x: boss.x, y: boss.y - 10, vx: -5, vy: 0, life: 45, damage: 16, hostile: true, type: 'shockwave', poiseDmg: 10, piercing: true });
          projectiles.push({ x: boss.x, y: boss.y - 10, vx: 5, vy: 0, life: 45, damage: 16, hostile: true, type: 'shockwave', poiseDmg: 10, piercing: true });
          spawnParticles(boss.x, boss.y, '#90a4ae', 18, 7);
        }
        if (timer === 1) boss.y = 430;
      }},
    { name: 'feint_backflip', phase: 1, telegraphFrames: 6, attackFrames: 20, recoveryFrames: 22, weight: 2, maxDist: 120,
      execute(dx, dist, timer, data) {
        // Fakes an approach then backflips away and throws a kick
        if (timer > 14) {
          boss.x += boss.facing * 5; // approach
        } else if (timer > 8) {
          boss.x -= boss.facing * 8; // backflip away
          if (timer === 10) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 6, 3);
        } else if (timer === 5 && dist < 100) {
          // Long range kick on return
          hurtPlayer(boss.bossPhase >= 2 ? 26 : 22);
          screenShake = 6;
          spawnParticles(player.x, player.y - 20, '#90a4ae', 6);
          showQuickText('"FINTA!"', '#90a4ae');
        }
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
    { name: 'berserker_rush', phase: 3, telegraphFrames: 10, attackFrames: 40, recoveryFrames: 35, weight: 4, maxDist: 150, superArmor: true,
      execute(dx, dist, timer, data) {
        // Phase 3: wild zigzag rush with multiple hits
        if (!data.zigDir) data.zigDir = 1;
        boss.x += boss.facing * 8;
        boss.x += data.zigDir * 3;
        if (timer % 8 === 0) { data.zigDir *= -1; spawnParticles(boss.x, boss.y, '#ff6f00', 3, 2); }
        if (timer % 6 === 0 && dist < 70) {
          hurtPlayer(18);
          screenShake = 5;
          spawnParticles(player.x, player.y - 20, '#ff6f00', 5);
        }
        if (timer === 20) showQuickText('"DALE DALE DALEEEE!"', '#ff6f00');
        boss.x = Math.max(30, Math.min(W - 30, boss.x));
      }},
  ],
  // Ciccio — tank with chains
  3: [
    { name: 'chain_whip', phase: 1, telegraphFrames: 15, attackFrames: 15, recoveryFrames: 30, weight: 3, minDist: 60,
      execute(dx, dist, timer, data) {
        if (timer === 8 && dist < 150) {
          hurtPlayer(boss.bossPhase >= 2 ? 24 : 18);
          // Pull player toward boss
          if (dist > 60) player.x += Math.sign(boss.x - player.x) * 40;
          screenShake = 6;
          showQuickText('"VIENI QUA!"', '#f44336');
        }
      }},
    { name: 'body_slam', phase: 1, telegraphFrames: 15, attackFrames: 20, recoveryFrames: 35, weight: 2, maxDist: 70, superArmor: true,
      execute(dx, dist, timer, data) {
        if (timer === 10 && dist < 70) { hurtPlayer(boss.bossPhase >= 3 ? 32 : 26); screenShake = 12; spawnParticles(boss.x, boss.y, '#f44336', 12, 5); }
      }},
    { name: 'chain_spin', phase: 2, telegraphFrames: 18, attackFrames: 30, recoveryFrames: 35, weight: 2, superArmor: true,
      execute(dx, dist, timer, data) {
        // 360 AoE, must dodge through or stay far
        if (timer % 10 === 0 && dist < 120) { hurtPlayer(20); screenShake = 5; }
        spawnParticles(boss.x + Math.cos(timer * 0.5) * 60, boss.y - 20 + Math.sin(timer * 0.5) * 30, '#f44336', 2, 2);
      }},
    { name: 'earthquake', phase: 3, telegraphFrames: 18, attackFrames: 40, recoveryFrames: 40, weight: 3, superArmor: true,
      execute(dx, dist, timer, data) {
        // 3 successive shockwaves
        if ((timer === 35 || timer === 25 || timer === 15) && player.grounded) {
          if (dist < 200) { hurtPlayer(24); screenShake = 10; }
          spawnParticles(boss.x, boss.y, '#ff6f00', 15, 6);
          showQuickText('"TERREMOTO!"', '#ff3d00');
        }
      }},
    { name: 'pizza_throw', phase: 1, telegraphFrames: 12, attackFrames: 10, recoveryFrames: 25, weight: 2, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 8 && !data.thrown) {
          data.thrown = true;
          const spread = boss.bossPhase >= 2 ? 2 : 1;
          for (let i = -spread; i <= spread; i++) {
            projectiles.push({ x: boss.x, y: boss.y - 30, vx: boss.facing * 4 + i * 1.5, vy: -2 + Math.abs(i), life: 100, damage: boss.bossPhase >= 3 ? 24 : 18, hostile: true, type: 'pizza', gravity: true });
          }
        }
      }},
    { name: 'pizza_rain', phase: 3, telegraphFrames: 18, attackFrames: 30, recoveryFrames: 35, weight: 3,
      execute(dx, dist, timer, data) {
        // Throws 5 pizza projectiles in arcs for area denial
        if (timer === 25 && !data.rained) {
          data.rained = true;
          showQuickText('"PIOGGIA DI PIZZA!"', '#ff3d00');
          for (let i = 0; i < 5; i++) {
            const angle = -0.4 + i * 0.2;
            projectiles.push({
              x: boss.x, y: boss.y - 40,
              vx: Math.cos(angle) * 3 * boss.facing + (Math.random() - 0.5) * 2,
              vy: -5 - Math.random() * 3,
              life: 120, damage: 20, hostile: true, type: 'pizza', gravity: true
            });
          }
          spawnParticles(boss.x, boss.y - 40, '#ff6f00', 10, 4);
          screenShake = 6;
        }
      }},
  ],
  // Pisellino — gang leader, all-rounder
  4: [
    { name: 'pistol_burst', phase: 1, telegraphFrames: 14, attackFrames: 20, recoveryFrames: 25, weight: 3, minDist: 80,
      execute(dx, dist, timer, data) {
        if (timer === 16 || timer === 12 || timer === 8) {
          projectiles.push({ x: boss.x, y: boss.y - 35, vx: boss.facing * 8, vy: (Math.random() - 0.5) * 2, life: 60, damage: boss.bossPhase >= 3 ? 22 : 16, hostile: true, type: 'bullet', color: '#b0bec5' });
          playSFX('hit');
        }
      }},
    { name: 'summon_goons', phase: 1, telegraphFrames: 14, attackFrames: 10, recoveryFrames: 40, weight: 1,
      execute(dx, dist, timer, data) {
        if (timer === 5 && !data.summoned) {
          data.summoned = true;
          const count = boss.bossPhase >= 2 ? 2 : 1;
          const types = ENEMY_TYPES[4] || ENEMY_TYPES[0];
          for (let i = 0; i < count; i++) {
            const t = types[Math.floor(Math.random() * types.length)];
            goons.push({
              x: boss.x + (i === 0 ? -80 : 80), y: GROUND_Y, w: t.w, h: t.h,
              hp: t.hp * 0.6 * DIFF_HP[difficulty], maxHp: t.hp * 0.6 * DIFF_HP[difficulty], speed: t.speed, damage: t.dmg,
              attackTimer: 60 + Math.random() * 60, hitFlash: 0, stunTimer: 0, dead: false,
              color: t.color, hat: t.hat, name: t.name, type: t.type, shootTimer: 0,
              flankDir: Math.random() > 0.5 ? 1 : -1, knockbackVx: 0, windupTimer: 0,
              poise: t.poise || 15, maxPoise: t.poise || 15, poiseRecovery: t.poiseRecovery || 0.25,
              staggerTimer: 0, lastHitTimer: 999, poiseBreakCooldown: 0,
              consecutiveHitCount: 0, lastHitByPlayerTimer: 999, bleedTimer: 0, bleedDmg: 0
            });
          }
          showQuickText('"GET HIM BOYS!"', '#b0bec5');
        }
      }},
    { name: 'molotov', phase: 2, telegraphFrames: 16, attackFrames: 15, recoveryFrames: 30, weight: 2, minDist: 60,
      execute(dx, dist, timer, data) {
        if (timer === 10 && !data.thrown) {
          data.thrown = true;
          projectiles.push({ x: boss.x, y: boss.y - 35, vx: (player.x - boss.x) * 0.04, vy: -4, life: 50, damage: 22, hostile: true, type: 'molotov', gravity: true });
          showQuickText('"BRUCIA! BURN BRO!"', '#ff6f00');
        }
      }},
    { name: 'teleport_strike', phase: 1, telegraphFrames: 10, attackFrames: 12, recoveryFrames: 25, weight: 2, maxDist: 200,
      execute(dx, dist, timer, data) {
        if (timer === 10 && !data.teleported) {
          data.teleported = true;
          boss.x += (Math.random() > 0.5 ? 1 : -1) * 130;
          boss.x = Math.max(50, Math.min(W - 50, boss.x));
          spawnParticles(boss.x, boss.y - 30, '#b0bec5', 8);
        }
        if (timer === 4 && Math.abs(boss.x - player.x) < 60) { hurtPlayer(28); screenShake = 5; }
      }},
    { name: 'desperate_dual', phase: 3, telegraphFrames: 12, attackFrames: 30, recoveryFrames: 25, weight: 4, maxDist: 80, superArmor: true,
      execute(dx, dist, timer, data) {
        boss.x += boss.facing * 4;
        if (timer % 5 === 0 && dist < 65) {
          hurtPlayer(16);
          screenShake = 4;
          spawnParticles(player.x, player.y - 20, '#b0bec5', 4);
        }
      }},
    { name: 'melee', phase: 1, telegraphFrames: 12, attackFrames: 10, recoveryFrames: 20, weight: 2, maxDist: 65,
      execute(dx, dist, timer, data) {
        if (timer === 5 && dist < 65) { hurtPlayer(boss.bossPhase >= 3 ? 26 : 20); screenShake = 4; }
      }},
    { name: 'shadow_decoy', phase: 3, telegraphFrames: 10, attackFrames: 50, recoveryFrames: 20, weight: 3,
      execute(dx, dist, timer, data) {
        // Teleports away, leaves decoy that explodes after delay
        if (timer === 45 && !data.teleported) {
          data.teleported = true;
          data.decoyX = boss.x;
          data.decoyY = boss.y;
          // Teleport boss to opposite side
          boss.x = boss.x > W/2 ? 100 + Math.random() * 150 : W - 100 - Math.random() * 150;
          boss.x = Math.max(50, Math.min(W - 50, boss.x));
          spawnParticles(data.decoyX, data.decoyY - 30, '#b0bec5', 10, 3);
          spawnParticles(boss.x, boss.y - 30, '#b0bec5', 6, 3);
          showQuickText('"NOW YOU SEE ME..."', '#b0bec5');
        }
        // Draw decoy shimmer
        if (data.decoyX && timer > 10 && timer < 45) {
          const shimmer = Math.sin(gameTime * 0.3) * 0.3 + 0.5;
          spawnParticles(data.decoyX + (Math.random() - 0.5) * 20, data.decoyY - 30, '#b0bec5', 1, 1);
        }
        // Decoy explodes
        if (timer === 10 && data.decoyX) {
          const decoyDist = Math.abs(player.x - data.decoyX);
          if (decoyDist < 90 && Math.abs(player.y - data.decoyY) < 50) {
            hurtPlayer(28);
            screenShake = 10;
          }
          spawnParticles(data.decoyX, data.decoyY - 20, '#f44336', 15, 6);
          showQuickText('"BOOM BRO!"', '#f44336');
          screenShake = 8;
        }
      }},
  ]
};

// Old individual boss AI functions removed — replaced by state machine above

// Regina AI helper (L1 boss phase 2+) — SYNERGY: hides behind Gioacchino, fires from cover
function updateReginaAI() {
  regina.hitFlash = Math.max(0, regina.hitFlash - 1);
  if (regina.stunTimer > 0) { regina.stunTimer--; return; }
  if (regina.entering) {
    regina.x += (650 - regina.x) * 0.05;
    if (Math.abs(regina.x - 650) < 5) regina.entering = false;
    return;
  }
  // Poise break cooldown
  if (regina.poiseBreakCooldown > 0) regina.poiseBreakCooldown--;
  regina.lastHitByPlayerTimer++;
  if (regina.lastHitByPlayerTimer > 45) regina.consecutiveHitCount = 0;
  if (regina.staggerTimer > 0) { regina.staggerTimer--; if (regina.staggerTimer <= 0) regina.poise = regina.maxPoise; return; }
  regina.lastHitTimer++;
  if (regina.lastHitTimer > 60 && regina.poise < regina.maxPoise && regina.poiseBreakCooldown <= 0) {
    regina.poise = Math.min(regina.maxPoise, regina.poise + regina.poiseRecovery);
  }

  // === SYNERGY: Regina positions BEHIND Gioacchino (opposite side from player) ===
  if (boss && !boss.dead) {
    const behindX = boss.x - Math.sign(player.x - boss.x) * 60; // behind boss relative to player
    const targetX = Math.max(40, Math.min(W - 40, behindX));
    regina.x += (targetX - regina.x) * 0.06; // smooth follow
  } else {
    // Boss dead: Regina panics, backs away
    if (Math.abs(player.x - regina.x) < 150) regina.x -= Math.sign(player.x - regina.x) * 1.5;
  }

  regina.throwTimer++;
  // Throw rate: faster when Gioacchino is attacking (covering fire)
  const bossAttacking = boss && !boss.dead && boss.bossState === 'attack';
  const throwInterval = bossAttacking ? 50 : 80; // much faster during boss attacks
  if (regina.throwTimer % throwInterval === 0) {
    const targetY = player.y - player.h / 2;
    const originY = regina.y - 25;
    const angle = Math.atan2(targetY - originY, player.x - regina.x);
    projectiles.push({ x: regina.x, y: originY, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, life: 120, damage: 14, hostile: true, type: 'meat' });
    spawnParticles(regina.x, originY, '#d32f2f', 3, 2);
    // During boss attack: also fire a second angled shot
    if (bossAttacking) {
      projectiles.push({ x: regina.x, y: originY, vx: Math.cos(angle + 0.3) * 3.5, vy: Math.sin(angle + 0.3) * 3.5, life: 100, damage: 10, hostile: true, type: 'meat' });
    }
  }

  // === SYNERGY: Retaliation shot when player hits Gioacchino ===
  if (boss && !boss.dead && boss.lastHitTimer < 2 && regina.throwTimer > 10) {
    const retAngle = Math.atan2((player.y - 20) - regina.y, player.x - regina.x);
    projectiles.push({ x: regina.x, y: regina.y - 25, vx: Math.cos(retAngle) * 5, vy: Math.sin(retAngle) * 5, life: 80, damage: 16, hostile: true, type: 'meat' });
    spawnParticles(regina.x, regina.y - 25, '#e91e63', 4, 2);
    regina.throwTimer = 0; // reset throw cooldown
  }

  if (regina.hp <= 0) {
    regina.dead = true;
    spawnParticles(regina.x, regina.y - 25, '#e91e63', 15);
    showQuickText('"REGINA NOOOO!"', '#e91e63');
    boss.stunTimer = 60;
    boss.speed += 1.0;
  }
}

// Mariuso AI helper (L4 boss phase 3) — SYNERGY: pincer attacks with Pisellino
function updateMariusoAI() {
  mariuso.hitFlash = Math.max(0, mariuso.hitFlash - 1);
  if (mariuso.stunTimer > 0) { mariuso.stunTimer--; return; }
  if (mariuso.entering) {
    mariuso.x += (200 - mariuso.x) * 0.04;
    if (Math.abs(mariuso.x - 200) < 10) mariuso.entering = false;
    return;
  }
  // Poise management
  if (mariuso.poiseBreakCooldown > 0) mariuso.poiseBreakCooldown--;
  mariuso.lastHitByPlayerTimer++;
  if (mariuso.lastHitByPlayerTimer > 45) mariuso.consecutiveHitCount = 0;
  if (mariuso.staggerTimer > 0) { mariuso.staggerTimer--; if (mariuso.staggerTimer <= 0) mariuso.poise = mariuso.maxPoise; return; }
  mariuso.lastHitTimer++;
  if (mariuso.lastHitTimer > 60 && mariuso.poise < mariuso.maxPoise && mariuso.poiseBreakCooldown <= 0) {
    mariuso.poise = Math.min(mariuso.maxPoise, mariuso.poise + mariuso.poiseRecovery);
  }

  // === SYNERGY: Mariuso rushes in while Pisellino keeps distance (pincer) ===
  if (!mariuso.pincerTimer) mariuso.pincerTimer = 0;
  mariuso.pincerTimer++;

  const mdx = player.x - mariuso.x;
  const mdist = Math.abs(mdx);

  // Mariuso aggressively chases player
  mariuso.x += Math.sign(mdx) * 3.2;

  mariuso.attackTimer = Math.max(0, mariuso.attackTimer - 1);
  if (mdist < 55 && mariuso.attackTimer === 0) {
    hurtPlayer(28);
    mariuso.attackTimer = 30;
    screenShake = 8;
    spawnParticles(player.x, player.y - 20, '#7b1fa2', 8);
    showQuickText('"MARIUSO COLPISCE!"', '#ce93d8');
  }

  // === SYNERGY: Pisellino teleports behind player for pincer every 200 frames ===
  if (mariuso.pincerTimer % 200 === 0 && boss && !boss.dead && boss.bossState === 'idle' && mdist < 80) {
    // Pisellino teleports behind the player while Mariuso attacks from front
    const behindPlayer = player.x - Math.sign(mdx) * 100;
    boss.x = Math.max(50, Math.min(W - 50, behindPlayer));
    boss.facing = Math.sign(player.x - boss.x);
    spawnParticles(boss.x, boss.y - 30, '#b0bec5', 10, 4);
    screenShake = 5;
    showQuickText('"PINZA BRO! PINZA!"', '#b0bec5');
    // Pisellino immediately attacks
    boss.currentMove = pickBossMove(currentLevel, boss.bossPhase, Math.abs(player.x - boss.x));
    boss.bossState = 'telegraph';
    boss.stateTimer = Math.floor((boss.currentMove.telegraphFrames || 15) * 0.4); // very fast telegraph
    boss.moveData = {};
  }

  // === SYNERGY: When Mariuso gets staggered, Pisellino teleports to cover him ===
  if (mariuso.staggerTimer === 27 && boss && !boss.dead) { // just started stagger
    boss.x = mariuso.x + Math.sign(mariuso.x - player.x) * 50;
    boss.x = Math.max(50, Math.min(W - 50, boss.x));
    boss.facing = Math.sign(player.x - boss.x);
    spawnParticles(boss.x, boss.y - 30, '#b0bec5', 8, 3);
    showQuickText('"STAY AWAY FROM MY UNCLE!"', '#b0bec5');
    // Fire covering shots
    for (let i = 0; i < 3; i++) {
      projectiles.push({ x: boss.x, y: boss.y - 35, vx: boss.facing * 7 + (i - 1) * 2, vy: (Math.random() - 0.5) * 3, life: 60, damage: 14, hostile: true, type: 'bullet', color: '#b0bec5' });
    }
  }

  if (mariuso.hp <= 0) {
    mariuso.dead = true;
    spawnParticles(mariuso.x, mariuso.y - 30, '#7b1fa2', 20);
    showQuickText('"NO BRO... UNCLE... That\'s it. BASTA."', '#76ff03');
    boss.speed += 1.0;
    spawnCoinPickup(mariuso.x, mariuso.y - 30, 30);
  }
}

// Legacy stubs (old boss AIs removed — state machine handles everything)
function aiGioacchino() {}

// ==========================================
// GOON AI
// ==========================================
// Enemy types per level
// Goon nickname pools per type — randomly assigned on spawn for personality
const GOON_NICKNAMES = {
  0: { // Via Plava: Lazio ultras
    rusher: ['Zorzetto', 'Bianchino', 'Er Laziale', 'Aquilotto', 'Polverino'],
    tank: ['Bulldozer', 'Er Muro', 'Bestione', 'Zampone', 'Testacalda'],
  },
  1: { // Down Under Pub
    drunk: ['Vino Rosso', 'Sbronzetto', 'Er Barcollone', 'Gino Pinta', 'Ciuccio'],
    tank: ['Buttafuori', 'Nerone', 'Portone', 'Er Gorilla', 'Black'],
    thrower: ['Shaker', 'Er Cocktail', 'Barman', 'Colpo Secco', 'Oliva'],
  },
  2: { // Piazza Bainsizza: street
    rusher: ['Coltellaccio', 'Stradaiolo', 'Fumetto', 'Selciato', 'Rattazzo'],
    flanker: ['Ombra', 'Sveltino', 'Er Fantasma', 'Furetto', 'Sguscio'],
    tank: ['Macigno', 'Er Grosso', 'Bidone', 'Masso', 'Colosseo'],
  },
  3: { // Pizzarium: pizza fighters
    thrower: ['Mozzarella', 'Pomodorino', 'Farina', 'Lievitino', 'Condimento'],
    rusher: ['Motorino', 'Express', 'Scooterino', 'Freccia', 'Consegna'],
    tank: ['Forno', 'Impasto', 'Sfornata', 'Pala', 'Lievito Madre'],
  },
  4: { // Piazza Mazzini: elite
    rusher: ['Soldatino', 'Recluta', 'Caporale', 'Fucile', 'Er Marziale'],
    ranged: ['Mirino', 'Sniper', 'Occhio', 'Grilletto', 'Silenzio'],
    tank: ['Corazza', 'Bunker', 'Er Blindato', 'Fortezza', 'Trincea'],
    flanker: ['Pestifero', 'Monello', 'Lametta', 'Scattino', 'Trottolino'],
  }
};

const ENEMY_TYPES = {
  // Level 0 - Via Plava: rugby hooligans + Lazio tifosi
  0: [
    { name: 'Tifoso', color: '#1565c0', hp: 110, speed: 1.5, dmg: 9, w: 32, h: 50, type: 'rusher', hat: '#64b5f6', poise: 25, poiseRecovery: 0.4 },
    { name: 'Hooligan', color: '#455a64', hp: 220, speed: 0.9, dmg: 14, w: 36, h: 52, type: 'tank', hat: '#90a4ae', poise: 65, poiseRecovery: 0.55 },
  ],
  // Level 1 - Down Under Pub: drunk pub guys + bouncers
  1: [
    { name: 'Ubriaco', color: '#5d4037', hp: 90, speed: 1.7, dmg: 8, w: 30, h: 48, type: 'drunk', hat: '#8d6e63', poise: 20, poiseRecovery: 0.3 },
    { name: 'Bouncer', color: '#212121', hp: 250, speed: 0.7, dmg: 16, w: 40, h: 56, type: 'tank', hat: '#424242', poise: 72, poiseRecovery: 0.55 },
    { name: 'Barista', color: '#4e342e', hp: 105, speed: 1.1, dmg: 12, w: 30, h: 48, type: 'thrower', hat: '#6d4c41', poise: 25, poiseRecovery: 0.4 },
  ],
  // Level 2 - Piazza Bainsizza: street toughs
  2: [
    { name: 'Teppista', color: '#37474f', hp: 155, speed: 1.4, dmg: 12, w: 32, h: 50, type: 'rusher', hat: '#546e7a', poise: 30, poiseRecovery: 0.4 },
    { name: 'Spacciatore', color: '#1b5e20', hp: 105, speed: 2.0, dmg: 9, w: 28, h: 46, type: 'flanker', hat: '#2e7d32', poise: 24, poiseRecovery: 0.4 },
    { name: 'Grosso', color: '#424242', hp: 335, speed: 0.6, dmg: 20, w: 44, h: 58, type: 'tank', hat: '#616161', poise: 80, poiseRecovery: 0.6 },
  ],
  // Level 3 - Pizzarium: pizza workers + delivery guys
  3: [
    { name: 'Garzone', color: '#fff', hp: 100, speed: 1.6, dmg: 10, w: 30, h: 48, type: 'thrower', hat: '#f44336', poise: 24, poiseRecovery: 0.4 },
    { name: 'Fattorino', color: '#ff8f00', hp: 140, speed: 2.2, dmg: 12, w: 30, h: 48, type: 'rusher', hat: '#ffc107', poise: 28, poiseRecovery: 0.4 },
    { name: 'Impastatore', color: '#fff', hp: 310, speed: 0.8, dmg: 19, w: 42, h: 54, type: 'tank', hat: '#d32f2f', poise: 78, poiseRecovery: 0.55 },
  ],
  // Level 4 - Piazza Mazzini: Valle Aurelia gang elite
  4: [
    { name: 'Soldato', color: '#263238', hp: 170, speed: 1.7, dmg: 14, w: 32, h: 52, type: 'rusher', hat: '#37474f', poise: 34, poiseRecovery: 0.5 },
    { name: 'Cecchino', color: '#1a1a2e', hp: 100, speed: 0.9, dmg: 19, w: 28, h: 48, type: 'ranged', hat: '#311b92', poise: 20, poiseRecovery: 0.4 },
    { name: 'Guardaspalle', color: '#1a1a1a', hp: 380, speed: 0.7, dmg: 22, w: 46, h: 60, type: 'tank', hat: '#333', poise: 88, poiseRecovery: 0.6 },
    { name: 'Scugnizzo', color: '#4a148c', hp: 90, speed: 2.8, dmg: 9, w: 26, h: 44, type: 'flanker', hat: '#7b1fa2', poise: 24, poiseRecovery: 0.4 },
  ]
};

function spawnGoons(count) {
  // Dead goons already pruned in updateGoons
  const types = ENEMY_TYPES[currentLevel] || ENEMY_TYPES[0];
  for (let i = 0; i < count; i++) {
    const t = types[i % types.length];
    // Spawn offscreen and walk in (alternating sides)
    const spawnSide = (i % 2 === 0) ? W + 40 + i * 30 : -40 - i * 30;
    // Assign a random nickname from the level's pool
    const nickPool = GOON_NICKNAMES[currentLevel] && GOON_NICKNAMES[currentLevel][t.type];
    const nickname = nickPool ? nickPool[Math.floor(Math.random() * nickPool.length)] : t.name;
    goons.push({
      x: spawnSide,
      y: GROUND_Y,
      entering: true, // walk-in flag
      w: t.w, h: t.h,
      hp: t.hp * DIFF_HP[difficulty], maxHp: t.hp * DIFF_HP[difficulty],
      speed: t.speed,
      damage: t.dmg,
      attackTimer: 60 + Math.random() * 60,
      hitFlash: 0,
      stunTimer: 0,
      dead: false,
      color: t.color,
      hat: t.hat,
      name: nickname,
      typeName: t.name,
      type: t.type,
      shootTimer: 0,
      flankDir: Math.random() > 0.5 ? 1 : -1,
      knockbackVx: 0,
      windupTimer: 0,
      phaseOffset: Math.random() * Math.PI * 2, // unique movement phase
      // Poise system
      poise: t.poise || 15,
      maxPoise: t.poise || 15,
      poiseRecovery: t.poiseRecovery || 0.25,
      staggerTimer: 0,
      lastHitTimer: 999, // frames since last hit (starts high so poise recovery works)
      poiseBreakCooldown: 0, // frames after poise break where poise can't be broken again
      consecutiveHitCount: 0, // for auto-knockdown system
      lastHitByPlayerTimer: 999, // frames since last player hit (for consecutive hit reset)
      bleedTimer: 0,
      bleedDmg: 0
    });
  }
}

function updateGoons() {
  // Prune dead goons every frame to keep array lean
  goons = goons.filter(g => !g.dead);
  const aliveCount = goons.length;

  // Aggression slots: max 5 enemies attack simultaneously, others circle at medium range
  const MAX_ATTACKERS = 5;
  let attackingCount = 0;
  for (let i = 0; i < goons.length; i++) {
    const g = goons[i];
    if (g.windupTimer > 0 || (g.attackTimer > 0 && g.attackTimer < 20)) attackingCount++;
  }
  const attackSlotsAvailable = MAX_ATTACKERS - attackingCount;

  goons.forEach(g => {
    // Walk-in animation: move toward play area from offscreen
    if (g.entering) {
      if (!g.enterTarget) g.enterTarget = 200 + Math.random() * 400;
      const dir = g.x < g.enterTarget ? 1 : -1;
      g.x += dir * g.speed * 2.5;
      if (Math.abs(g.x - g.enterTarget) < 10) { g.entering = false; g.enterTarget = null; }
      return;
    }
    g.hitFlash = Math.max(0, g.hitFlash - 1);
    // Apply hazard slow
    const origSpeed = g.speed;
    if (g.hazardSlow) g.speed *= 0.7;
    if (g.slowTimer > 0) { g.slowTimer--; g.speed *= 0.7; }
    if (player.ultraActive && weapons[0].special === 'interrogation') g.speed *= 0.6;
    if (g.stunTimer > 0) { g.stunTimer--; g.speed = origSpeed; return; }

    // Poise break cooldown timer
    if (g.poiseBreakCooldown > 0) g.poiseBreakCooldown--;

    // Consecutive hit reset: if not hit for 45 frames, reset counter
    g.lastHitByPlayerTimer++;
    if (g.lastHitByPlayerTimer > 45) g.consecutiveHitCount = 0;

    // Launched state: enemy floating above ground, takes 1.5x from jump attacks
    if (g.launched > 0) {
      g.launched--;
      const launchProgress = g.launched / 40;
      g.y = (g.launchY || GROUND_Y) - Math.sin(launchProgress * Math.PI) * 80;
      if (g.launched <= 0) {
        g.y = GROUND_Y;
        g.stunTimer = Math.max(g.stunTimer, 15);
      }
      // Apply knockback while launched
      if (Math.abs(g.knockbackVx) > 0.2) {
        g.x += g.knockbackVx;
        g.knockbackVx *= 0.9;
      }
      return;
    }

    // Stagger: enemy can't act, flashes, takes bonus damage
    if (g.staggerTimer > 0) {
      g.staggerTimer--;
      if (g.staggerTimer <= 0) {
        // Poise resets to full after stagger ends
        g.poise = g.maxPoise;
      }
      // Still apply knockback during stagger
      if (Math.abs(g.knockbackVx) > 0.2) {
        g.x += g.knockbackVx;
        g.knockbackVx *= 0.82;
      } else {
        g.knockbackVx = 0;
      }
      return; // Can't act during stagger
    }

    // Knockback physics
    if (Math.abs(g.knockbackVx) > 0.2) {
      g.x += g.knockbackVx;
      g.knockbackVx *= 0.82;
    } else {
      g.knockbackVx = 0;
    }

    // Poise recovery: if not hit for 40 frames and not in poise break cooldown, regenerate poise
    g.lastHitTimer++;
    if (g.lastHitTimer > 40 && g.poise < g.maxPoise && g.poiseBreakCooldown <= 0) {
      g.poise = Math.min(g.maxPoise, g.poise + g.poiseRecovery);
    }

    // Bleed DoT
    if (g.bleedTimer > 0) {
      g.bleedTimer--;
      if (g.bleedTimer % 60 === 0) {
        g.hp -= g.bleedDmg;
        spawnParticles(g.x, g.y - 20, '#b71c1c', 3, 2);
        spawnDamageNumber(g.x, g.y - (g.h || 50), g.bleedDmg, '#b71c1c');
        if (g.hp <= 0 && !g.dead) {
          g.dead = true;
          totalKills++;
          spawnParticles(g.x, g.y - 25, '#ffd700', 12);
          spawnCoinPickup(g.x, g.y - 20, 6 + Math.floor(Math.random() * 3));
          playSFX('coin');
        }
      }
    }

    // Windup - telegraphed attack about to fire
    if (g.windupTimer > 0) {
      // Dust on first frame
      if (!g.windupStarted) { g.windupStarted = true; g.windupMax = g.windupTimer; spawnParticles(g.x, g.y, '#9e8e7e', 3, 2); }
      g.windupTimer--;
      if (g.windupTimer === 0 && !player.dead) {
        const dx = player.x - g.x;
        const dist = Math.abs(dx);
        if (g.type === 'thrower') {
          const pType = currentLevel === 3 ? 'pizza' : 'meat';
          projectiles.push({
            x: g.x, y: g.y - 25,
            vx: Math.sign(dx) * 4.5, vy: -2.5,
            life: 80, damage: g.damage, hostile: true,
            type: pType, gravity: true
          });
        } else if (g.type === 'ranged') {
          projectiles.push({
            x: g.x, y: g.y - 25,
            vx: Math.sign(dx) * 6.5, vy: 0,
            life: 90, damage: g.damage, hostile: true,
            type: 'bullet', color: '#7b1fa2'
          });
        } else {
          // Melee - visible swing + range check (jumping avoids melee attacks)
          const atkDir = Math.sign(player.x - g.x) || 1;
          spawnParticles(g.x + atkDir * 25, g.y - 25, '#ff8a65', 4, 3);
          const playerAirborne = player.y < GROUND_Y - 30;
          if (dist < 65 && !playerAirborne) {
            hurtPlayer(g.damage);
            screenShake = g.type === 'tank' ? 5 : 3;
            if (g.type === 'tank') spawnParticles(player.x, player.y - 20, '#f44336', 4);
          }
        }
      }
      g.windupStarted = false;
      return; // Freeze during windup (committed to attack)
    }

    g.attackTimer = Math.max(0, g.attackTimer - 1);

    const dx = player.x - g.x;
    const dist = Math.abs(dx);

    // Aggression boost when fewer allies remain
    const aggroMult = aliveCount <= 1 ? 1.5 : aliveCount <= 2 ? 1.2 : 1.0;

    // If no attack slot available and this goon isn't already attacking, circle at medium range
    const canAttack = attackSlotsAvailable > 0 || g.windupTimer > 0;
    const circleRange = 100 + Math.sin(gameTime * 0.02 + g.x) * 30; // medium range orbit

    switch(g.type) {
      case 'rusher':
        if (!canAttack && dist < circleRange) {
          // Pace at medium range with unique rhythm
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 1.0;
          if (dist < 60) g.x += Math.sign(g.x - player.x) * g.speed * 0.6;
        } else if (dist > 45) {
          g.x += Math.sign(dx) * g.speed * 1.5 * aggroMult;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 16;
          g.attackTimer = Math.floor(24 / aggroMult);
        }
        break;

      case 'tank':
        if (!canAttack && dist < circleRange) {
          g.x += Math.sin(gameTime * 0.03 + g.phaseOffset) * g.speed * 0.7;
          if (dist < 70) g.x += Math.sign(g.x - player.x) * g.speed * 0.5;
        } else if (dist > 55) {
          g.x += Math.sign(dx) * g.speed * 1.1 * aggroMult;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 24;
          g.attackTimer = Math.floor(36 / aggroMult);
        }
        break;

      case 'drunk':
        // Always moving erratically — unique wobble per goon
        g.x += Math.sign(dx) * g.speed * 0.8 * aggroMult + Math.sin(gameTime * 0.1 + g.phaseOffset) * 1.8;
        if (dist > 200) g.x += Math.sign(dx) * g.speed * 0.5;
        if (dist < 50 && g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 12;
          g.attackTimer = Math.floor(22 / aggroMult);
        }
        break;

      case 'thrower': {
        // Maintain ideal range 140-220, always moving
        if (dist < 120) g.x -= Math.sign(dx) * g.speed * 0.6;
        else if (dist > 250) g.x += Math.sign(dx) * g.speed * 1.1;
        else {
          // Strafe at ideal range with unique phase
          g.x += Math.sin(gameTime * 0.05 + g.phaseOffset) * g.speed * 1.0;
          if (dist < 140) g.x -= Math.sign(dx) * g.speed * 0.3;
          else if (dist > 220) g.x += Math.sign(dx) * g.speed * 0.3;
        }
        g.shootTimer++;
        if (g.shootTimer > Math.floor(48 / aggroMult) && g.attackTimer === 0 && !player.dead && canAttack) {
          g.shootTimer = 0;
          g.windupTimer = 18;
          g.attackTimer = 20;
        }
        break;
      }

      case 'flanker': {
        const behindX = player.x + g.flankDir * 80;
        if (!canAttack && dist < circleRange) {
          // Pace around the player's flank with unique rhythm
          g.x += Math.sin(gameTime * 0.06 + g.phaseOffset) * g.speed * 1.1;
          if (dist < 50) g.x += Math.sign(g.x - player.x) * g.speed * 0.6;
        } else if (Math.abs(g.x - behindX) > 30) {
          g.x += Math.sign(behindX - g.x) * g.speed * 1.15 * aggroMult;
        } else if (g.attackTimer === 0 && dist < 60 && !player.dead && canAttack) {
          g.windupTimer = 14;
          g.attackTimer = Math.floor(20 / aggroMult);
          g.flankDir *= -1;
        }
        break;
      }

      case 'ranged':
        // Maintain range 200-350
        if (dist < 180) g.x -= Math.sign(dx) * g.speed * 1.1;
        else if (dist > 350) g.x += Math.sign(dx) * g.speed * 0.8;
        else {
          // Strafe with unique phase
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 0.8;
        }
        g.shootTimer++;
        if (g.shootTimer > Math.floor(40 / aggroMult) && g.attackTimer === 0 && !player.dead && canAttack) {
          g.shootTimer = 0;
          g.windupTimer = 18;
          g.attackTimer = 20;
        }
        break;

      default:
        if (!canAttack && dist < circleRange) {
          g.x += Math.sin(gameTime * 0.04 + g.phaseOffset) * g.speed * 0.8;
          if (dist < 60) g.x += Math.sign(g.x - player.x) * g.speed * 0.4;
        } else if (dist > 50) {
          g.x += Math.sign(dx) * g.speed;
        } else if (g.attackTimer === 0 && !player.dead && canAttack) {
          g.windupTimer = 16;
          g.attackTimer = 28;
        }
    }

    // Separation: don't stack on top of other goons (strong force)
    for (let oi = 0; oi < goons.length; oi++) {
      const other = goons[oi];
      if (other === g) continue;
      const gap = g.x - other.x;
      if (Math.abs(gap) < 40) {
        g.x += Math.sign(gap || 1) * ((40 - Math.abs(gap)) / 40 * 2.0);
      }
    }

    g.x = Math.max(30, Math.min(W - 30, g.x));
    g.speed = origSpeed; // restore after hazard slow
  });
}

// Upgraded goon drawing with distinct looks per type
function drawGoon(g) {
  if (g.dead) return;
  // Lean-back during windup (telegraph body language)
  let leanX = 0;
  if (g.windupTimer > 0) {
    const leanDir = Math.sign(g.x - player.x) || 1;
    leanX = leanDir * 4;
  }
  const x = g.x - g.w/2 + leanX, y = g.y - g.h;

  // Stagger flash
  if (g.staggerTimer > 0) {
    ctx.globalAlpha = Math.floor(gameTime / 2) % 2 === 0 ? 0.3 : 0.8;
  } else if (g.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0) {
    ctx.globalAlpha = 0.5;
  }

  drawPixelChar(x, y, g.w, g.h, g.color, '#deb887', (px, py, w, h) => {
    // Hat/hair varies by type
    drawRect(px + 2, py - 3, w - 4, 6, g.hat || '#333');
    // Tank gets a scarf
    if (g.type === 'tank') {
      drawRect(px + 4, py + 18, w - 8, 5, '#c62828');
    }
    // Thrower has an apron
    if (g.type === 'thrower') {
      drawRect(px + 4, py + 22, w - 8, 15, '#fff');
    }
    // Flanker has a hoodie
    if (g.type === 'flanker') {
      drawRect(px, py - 2, 6, 12, g.hat);
      drawRect(px + w - 6, py - 2, 6, 12, g.hat);
    }
    // Drunk blush
    if (g.type === 'drunk') {
      drawRect(px + 4, py + 12, 5, 3, '#e57373');
      drawRect(px + w - 9, py + 12, 5, 3, '#e57373');
    }
    // Ranged has scope/visor
    if (g.type === 'ranged') {
      drawRect(px + 6, py + 8, w - 12, 3, '#b71c1c');
    }
    // Level-specific accessories
    if (currentLevel === 0) {
      // Lazio scarf on rushers
      if (g.type === 'rusher') drawRect(px + 2, py + 19, w - 4, 3, '#87ceeb');
    } else if (currentLevel === 1) {
      // Pub apron string on drunks
      if (g.type === 'drunk') drawRect(px + w/2 - 1, py + 20, 2, h - 24, '#8d6e63');
    } else if (currentLevel === 3) {
      // Flour stains on pizza workers
      if (g.type === 'thrower' || g.type === 'tank') {
        drawRect(px + 8, py + 25, 4, 3, 'rgba(255,255,255,0.5)');
        drawRect(px + w - 14, py + 30, 5, 3, 'rgba(255,255,255,0.5)');
      }
    } else if (currentLevel === 4) {
      // Armband on elite soldiers
      if (g.type === 'rusher') drawRect(px, py + 16, 4, 6, '#e94560');
    }
  });
  ctx.globalAlpha = 1;

  // Windup visual — body tint + red circle "!" + ground line + flash
  if (g.windupTimer > 0) {
    const wp = g.windupMax ? 1 - (g.windupTimer / g.windupMax) : 0.5;
    const shake = (wp > 0.5 ? 1 : 0) * (Math.floor(gameTime) % 2 === 0 ? 1 : -1);
    const windupFrame = g.windupMax ? (g.windupMax - g.windupTimer) : 0;

    // Bright red flash for first 6 frames of windup
    if (windupFrame < 6) {
      ctx.globalAlpha = 0.5 * (1 - windupFrame / 6);
      drawRect(x - 4, y - 4, g.w + 8, g.h + 8, '#ff1744');
      ctx.globalAlpha = 1;
    }

    // Body red tint (stronger)
    ctx.globalAlpha = 0.30 + wp * 0.35;
    drawRect(x + shake, y, g.w, g.h, '#ff1744');
    ctx.globalAlpha = 1;

    // Ground attack line (melee only) — thicker with glow
    if (g.type !== 'thrower' && g.type !== 'ranged') {
      const atkDir = Math.sign(player.x - g.x) || 1;
      const lineW = 50 + wp * 35;
      const lineX = atkDir > 0 ? g.x : g.x - lineW;
      // Glow layer
      ctx.globalAlpha = (0.5 + wp * 0.4) * 0.4;
      drawRect(lineX, GROUND_Y - 5, lineW, 8, '#ff5252');
      ctx.globalAlpha = 0.5 + wp * 0.4;
      drawRect(lineX, GROUND_Y - 2, lineW, 4, '#ff5252');
      ctx.globalAlpha = 1;
    }

    // Red circle with "!" above head
    const exPulse = Math.sin(gameTime * 0.3) > 0;
    const exX = x + g.w/2 + shake;
    const exY = y - 20;
    ctx.globalAlpha = exPulse ? 1 : 0.7;
    ctx.fillStyle = '#d32f2f';
    ctx.beginPath();
    ctx.arc(exX, exY, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    drawText('!', exX, exY + 6, '#fff', 20, 'center');
  }

  // Thrower/ranged: arm raise + dotted aim line during windup
  if (g.windupTimer > 0 && (g.type === 'thrower' || g.type === 'ranged')) {
    const armDir = Math.sign(player.x - g.x) || 1;
    const armX = x + g.w/2 + armDir * 10;
    drawRect(armX - 4, y - 14, 8, 16, g.color || '#888');
    drawRect(armX - 3, y - 14, 6, 5, '#deb887');
    // Dotted aim line (larger dots, higher alpha)
    const wp = g.windupMax ? 1 - (g.windupTimer / g.windupMax) : 0.5;
    ctx.globalAlpha = 0.4 + wp * 0.4;
    const lineLen = Math.min(Math.abs(player.x - g.x), 100);
    for (let d = 0; d < lineLen; d += 8) {
      drawRect(g.x + armDir * d, g.y - 28, 6, 4, '#ff5252');
    }
    ctx.globalAlpha = 1;
  }

  const hpR = g.hp / g.maxHp;
  drawRect(x, y - 10, g.w, 4, '#333');
  drawRect(x, y - 10, g.w * hpR, 4, '#ff5722');
  // Poise bar (only visible when poise < max)
  if (g.poise !== undefined && g.poise < g.maxPoise) {
    const poiseR = Math.max(0, g.poise / g.maxPoise);
    drawRect(x, y - 6, g.w, 2, '#555');
    drawRect(x, y - 6, g.w * poiseR, 2, g.staggerTimer > 0 ? '#ff9800' : '#ffeb3b');
  }
  // Stagger indicator
  if (g.staggerTimer > 0) {
    const pulse = Math.sin(gameTime * 0.3) * 0.3 + 0.7;
    ctx.globalAlpha = pulse;
    drawText('STAGGER', x + g.w/2, y - 18, '#ff9800', 8, 'center');
    ctx.globalAlpha = 1;
  }
  // Name tag — styled with type color background
  if (g.name && g.staggerTimer <= 0) {
    const nameW = g.name.length * 5 + 8;
    const nameX = x + g.w/2 - nameW/2;
    const nameColor = g.type === 'tank' ? '#c62828' : g.type === 'flanker' ? '#7b1fa2' :
      g.type === 'thrower' ? '#e65100' : g.type === 'ranged' ? '#311b92' :
      g.type === 'drunk' ? '#795548' : '#37474f';
    ctx.globalAlpha = 0.85;
    drawRect(nameX, y - 24, nameW, 12, nameColor);
    ctx.globalAlpha = 1;
    drawText(g.name, x + g.w/2, y - 14, '#fff', 8, 'center');
  }
}

// ==========================================
// GAME SCREENS
// ==========================================

function drawMenu() {
  // Dark background with gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 50; i++) {
    const sx = (i * 73 + gameTime * 0.2) % W;
    const sy = (i * 47) % (H * 0.6);
    const bright = 0.3 + Math.sin(gameTime * 0.02 + i) * 0.3;
    ctx.globalAlpha = bright;
    drawRect(sx, sy, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Title
  const bounce = Math.sin(gameTime * 0.03) * 5;
  drawText('LA GUERRA DI', W/2, 130 + bounce, '#e94560', 32, 'center');
  drawText('VALLE AURELIA', W/2, 175 + bounce, '#e94560', 40, 'center');

  // Subtitle
  drawText('La storia del Conte contro la gang', W/2, 220, '#aaa', 14, 'center');

  // Animated silhouette of Rome
  drawRect(100, 380, 80, 60, '#2d2d44');
  drawRect(110, 360, 20, 20, '#2d2d44');
  drawRect(250, 370, 100, 70, '#2d2d44');
  drawRect(270, 340, 15, 30, '#2d2d44');
  drawRect(295, 345, 15, 25, '#2d2d44');
  drawRect(450, 375, 120, 65, '#2d2d44');
  drawRect(600, 360, 90, 80, '#2d2d44');
  drawRect(620, 330, 10, 30, '#2d2d44');
  drawRect(700, 385, 100, 55, '#2d2d44');

  // Ground
  drawRect(0, 440, W, 110, '#16213e');

  // Start button (tappable on mobile)
  const startBtnW = 280, startBtnH = 40;
  const startBtnX = W/2 - startBtnW/2, startBtnY = 295;
  const startHover = mouseX >= startBtnX && mouseX <= startBtnX + startBtnW && mouseY >= startBtnY && mouseY <= startBtnY + startBtnH;
  const startPulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = startHover ? 1 : startPulse;
  drawRect(startBtnX, startBtnY, startBtnW, startBtnH, startHover ? '#e94560' : 'rgba(233,69,96,0.2)');
  drawRect(startBtnX, startBtnY, startBtnW, 2, '#e94560');
  drawText('INIZIA', W/2, startBtnY + 28, '#fff', 20, 'center');
  ctx.globalAlpha = 1;

  // Controls
  drawText('WASD/Frecce = Muovi | Z/Spazio = Attacca | X = Schiva | 1-4 = Helper', W/2, 500, '#666', 11, 'center');
  drawText('M = Mute/Unmute musica', W/2, 520, '#555', 10, 'center');

  // Small "Crediti" button bottom-right
  const credBtnX = W - 80, credBtnY = H - 28, credBtnW = 70, credBtnH = 20;
  const hoverCred = mouseX >= credBtnX && mouseX <= credBtnX + credBtnW && mouseY >= credBtnY && mouseY <= credBtnY + credBtnH;
  drawRect(credBtnX, credBtnY, credBtnW, credBtnH, hoverCred ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.06)');
  drawText('Crediti', credBtnX + 35, credBtnY + 15, hoverCred ? '#aaa' : '#555', 10, 'center');
  if (mouseClick && hoverCred) {
    showCredits = true;
    codeInput = '';
  }

  // Show cheat active indicator
  if (player.maxHp >= 999) {
    drawText('CONTE MODE', W/2, 280, '#ffd700', 14, 'center');
  }

  // === Credits overlay with code entry ===
  if (showCredits) {
    // Darken background
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.8)');

    // Credits panel — 15% larger, taller on touch to fit on-screen keyboard
    const panelX = W/2 - 230, panelY = isTouchDevice ? 20 : 75, panelW = 460, panelH = isTouchDevice ? 520 : 400;
    drawRect(panelX, panelY, panelW, panelH, 'rgba(20,20,40,0.95)');
    drawRect(panelX, panelY, panelW, 2, '#e94560');
    drawRect(panelX, panelY + panelH - 2, panelW, 2, '#e94560');

    const tOff = isTouchDevice ? -50 : 0; // text offset for touch layout
    drawText('- CREDITI -', W/2, 110 + tOff, '#e94560', 25, 'center');
    drawText('LA GUERRA DI VALLE AURELIA', W/2, 140 + tOff, '#ffd700', 16, 'center');
    drawText('Un gioco da conti...anzi, del Conte!', W/2, 163 + tOff, '#ccc', 13, 'center');
    drawText('Ambientato a Prati, Roma', W/2, 184 + tOff, '#aaa', 13, 'center');
    drawText('Sviluppatore: Cicca', W/2, 210 + tOff, '#aaa', 13, 'center');
    drawText('Programmazione: Cicca + Claude', W/2, 232 + tOff, '#aaa', 13, 'center');
    drawText('Idea & Design: Cicca', W/2, 254 + tOff, '#aaa', 13, 'center');
    drawText('Grazie per aver giocato!', W/2, 280 + tOff, '#ffcc80', 14, 'center');

    // Code entry box
    const codeY = isTouchDevice ? 290 : 340;
    drawRect(W/2 - 105, codeY, 210, 32, 'rgba(255,255,255,0.08)');
    drawRect(W/2 - 105, codeY, 210, 1, '#555');
    drawRect(W/2 - 105, codeY + 31, 210, 1, '#555');
    const cursor = Math.floor(gameTime / 30) % 2 === 0 ? '_' : '';
    const displayCode = codeInput + cursor;
    drawText(displayCode || 'Inserisci codice...', W/2, codeY + 22, codeInput ? '#fff' : '#555', 14, 'center');

    // On-screen keyboard for mobile
    drawCreditsKeyboard(codeY + 40);

    // Close button
    const closeBtnY2 = isTouchDevice ? codeY + 165 : 400;
    const closeBtnX = W/2 - 46, closeBtnW = 92, closeBtnH = 28;
    const hoverClose = mouseX >= closeBtnX && mouseX <= closeBtnX + closeBtnW && mouseY >= closeBtnY2 && mouseY <= closeBtnY2 + closeBtnH;
    drawRect(closeBtnX, closeBtnY2, closeBtnW, closeBtnH, hoverClose ? '#e94560' : 'rgba(233,69,96,0.4)');
    drawText('Chiudi', W/2, closeBtnY2 + 19, '#fff', 13, 'center');
    if (mouseClick && hoverClose) {
      showCredits = false;
      codeInput = '';
    }
    if (keysJustPressed['Escape']) {
      showCredits = false;
      codeInput = '';
    }

    // Handle keyboard input for code entry
    const letterKeys = ['KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG','KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT','KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ'];
    letterKeys.forEach(k => {
      if (keysJustPressed[k]) {
        if (codeInput.length < 12) codeInput += k.charAt(3);
      }
    });
    if (keysJustPressed['Backspace']) codeInput = codeInput.slice(0, -1);

    // Check for CONTE code
    if (codeInput === 'CONTE') {
      showCredits = false;
      codeInput = '';
      // UNLOCK EVERYTHING
      coins = 9999;
      bossDefeated = [true, true, true, true, true];
      player.maxHp = 999;
      player.hp = 999;
      player.maxStamina = 999;
      player.stamina = 999;
      player.invincible = 999999;
      player.speed = 6;
      UPGRADE_POOL.forEach(u => { if (!player.upgrades.some(e => e.effect === u.effect)) player.upgrades.push(u); });
      helpers.forEach(h => { h.tier = 3; h.unlocked = true; });
      firstTime = false;
      screenFlash = 20;
      flashColor = '#ffd700';
      showQuickText('CONTE MODE ACTIVATED! SEI INVINCIBILE!', '#ffd700');
      playSFX('victory_jingle');
      spawnParticles(W/2, H/2, '#ffd700', 40, 10);
    }

    // Check for SABI code
    if (codeInput === 'SABI') {
      showCredits = false;
      codeInput = '';
      sabiTimer = 0;
      sabiCicca = { x: 200, y: GROUND_Y, vx: 0, facing: 1, animTimer: 0 };
      sabiSabi = { x: 450, y: GROUND_Y, animTimer: 0, petting: false };
      sabiTotti = { x: 650, y: GROUND_Y, animTimer: 0, wagging: true, fetching: false };
      sabiMessages = [];
      sabiPreviousState = state;
      state = 'sabi';
      screenFlash = 15;
      flashColor = '#ff69b4';
      playSFX('coin');
    }

    // Check for LUDO code
    if (codeInput === 'LUDO') {
      showCredits = false;
      codeInput = '';
      coins += 100;
      screenFlash = 15;
      flashColor = '#ffd700';
      showQuickText('+100 COINS! Grazie Ludo!', '#ffd700');
      playSFX('coin');
      spawnParticles(W/2, H/2, '#ffd700', 20, 5);
    }

    // Check for FREESTYLE code
    if (codeInput === 'FREE') {
      showCredits = false;
      codeInput = '';
      startFreestyleVideo();
    }

    // Check for YO code (sunglasses toggle)
    if (codeInput === 'YO') {
      hasSunglasses = !hasSunglasses;
      codeInput = '';
      screenFlash = 10; flashColor = '#333';
      showQuickText(hasSunglasses ? 'STYLE ON!' : 'Occhiali rimossi.', '#333');
      playSFX('perfect_dodge');
    }

    // Block menu interaction while credits open
    return;
  }

  const startTap = startHover && mouseClick;
  if (keys['Enter'] || keys['Space'] || startTap) {
    if (firstTime) {
      state = 'difficultySelect';
      firstTime = false;
      resetPlayer();
    } else {
      state = 'hub';
      resetPlayer();
    }
  }
  mouseClick = false;
}

// ==========================================
// DIFFICULTY SELECT
// ==========================================
let diffSelectIndex = 1; // default to medium
let diffSelectReady = false;
let diffSelectTimer = 0;

function drawDifficultySelect() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawText('SCEGLI LA DIFFICOLTA\'', W/2, 45, '#e94560', 24, 'center');
  drawText('Puoi sempre cambiare dopo', W/2, 68, '#666', 10, 'center');

  diffSelectTimer++;
  if (diffSelectTimer > 15) diffSelectReady = true;

  const diffs = [
    { name: 'FACILE', color: '#4caf50', desc: 'Modalità Parioli',
      detail: 'Per goderti la storia del Conte senza troppo stress.', icon: '\u263A' },
    { name: 'MEDIO', color: '#ff9800', desc: 'Modalità Prati',
      detail: 'L\'esperienza standard. Nemici meno duri, danno ridotto.', icon: '\u2694' },
    { name: 'DIFFICILE', color: '#f44336', desc: 'Modalità Tor Bella',
      detail: 'Nemici piu\' forti e aggressivi. Nessuna pieta\'.', icon: '\u2620' }
  ];

  // Navigation
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) { diffSelectIndex = Math.max(0, diffSelectIndex - 1); playSFX('hit'); }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) { diffSelectIndex = Math.min(2, diffSelectIndex + 1); playSFX('hit'); }
  if (keysJustPressed['Digit1']) { diffSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { diffSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { diffSelectIndex = 2; playSFX('hit'); }

  const cardW = 230, cardH = 340, gap = 25;
  const totalW = 3 * cardW + 2 * gap;
  const startX = (W - totalW) / 2;
  const startY = 85;

  diffs.forEach((d, i) => {
    const cx = startX + i * (cardW + gap);
    const selected = (i === diffSelectIndex);

    // Click detection
    if (mouseX >= cx && mouseX <= cx + cardW && mouseY >= startY && mouseY <= startY + cardH && mouseClick) {
      diffSelectIndex = i;
      playSFX('hit');
    }

    // Card
    const cardAlpha = selected ? 1 : 0.5;
    ctx.globalAlpha = cardAlpha;
    drawRect(cx, startY, cardW, cardH, selected ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.4)');
    drawRect(cx, startY, cardW, 3, d.color);
    if (selected) {
      drawRect(cx, startY + cardH - 3, cardW, 3, d.color);
      drawRect(cx, startY, 3, cardH, d.color);
      drawRect(cx + cardW - 3, startY, 3, cardH, d.color);
    }

    // Icon
    drawText(d.icon, cx + cardW/2, startY + 60, d.color, 32, 'center');

    // Name
    drawText(d.name, cx + cardW/2, startY + 100, d.color, 18, 'center');

    // Description
    drawText(d.desc, cx + cardW/2, startY + 130, '#ccc', 10, 'center');

    // Detail lines (word wrap manually)
    const words = d.detail.split(' ');
    let line1 = '', line2 = '';
    words.forEach(w => {
      if ((line1 + w).length < 30) line1 += (line1 ? ' ' : '') + w;
      else line2 += (line2 ? ' ' : '') + w;
    });
    drawText(line1, cx + cardW/2, startY + 160, '#888', 9, 'center');
    if (line2) drawText(line2, cx + cardW/2, startY + 174, '#888', 9, 'center');

    // Difficulty-specific info
    if (i === 0) {
      drawText('Vite: \u221E', cx + cardW/2, startY + 210, '#4caf50', 11, 'center');
      drawText('Nemici: -20% HP', cx + cardW/2, startY + 228, '#4caf50', 10, 'center');
      drawText('Danni subiti: -30%', cx + cardW/2, startY + 246, '#4caf50', 10, 'center');
    } else if (i === 1) {
      drawText('Vite: 3 per boss', cx + cardW/2, startY + 210, '#ff9800', 11, 'center');
      drawText('Nemici: normali', cx + cardW/2, startY + 228, '#ff9800', 10, 'center');
      drawText('Danni subiti: normali', cx + cardW/2, startY + 246, '#ff9800', 10, 'center');
    } else {
      drawText('Vite: 3 in TOTALE', cx + cardW/2, startY + 210, '#f44336', 11, 'center');
      drawText('Nemici: +10% HP', cx + cardW/2, startY + 228, '#f44336', 10, 'center');
      drawText('Danni subiti: +10%', cx + cardW/2, startY + 246, '#f44336', 10, 'center');
    }

    ctx.globalAlpha = 1;
  });

  // Key hint
  drawText('Frecce/1-2-3 per scegliere', W/2, startY + cardH + 18, '#555', 10, 'center');

  // Confirm button
  const confirmW = 220, confirmH = 40;
  const confirmX = W/2 - confirmW/2, confirmY = startY + cardH + 30;
  const confirmHover = mouseX >= confirmX && mouseX <= confirmX + confirmW && mouseY >= confirmY && mouseY <= confirmY + confirmH;
  const selColor = diffs[diffSelectIndex].color;
  const pulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  drawRect(confirmX, confirmY, confirmW, confirmH, confirmHover ? selColor : 'rgba(255,255,255,0.1)');
  drawRect(confirmX, confirmY, confirmW, 3, selColor);
  drawText('CONFERMA: ' + diffs[diffSelectIndex].name, W/2, confirmY + 27, '#fff', 14, 'center');
  ctx.globalAlpha = 1;

  const confirmTap = diffSelectReady && confirmHover && mouseClick;
  if (diffSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    difficulty = ['easy', 'medium', 'hard'][diffSelectIndex];
    if (difficulty === 'hard') lives = 3;
    state = 'weaponSelect';
    weaponSelectIndex = 0;
    weaponSelectReady = false;
    weaponSelectTimer = 0;
    spawnParticles(W/2, H/2, selColor, 20, 5);
    playSFX('coin');
  }

  drawTouchButtons();
  mouseClick = false;
}

// ==========================================
// TUTORIAL
// ==========================================
const tutorialSteps = [
  { text: 'Benvenuto, Conte! Questo e\' il tuo addestramento.', hint: '[ENTER] per continuare' },
  { text: 'Usa A/D o FRECCE per muoverti.', hint: 'Muoviti a sinistra e destra!', check: 'move' },
  { text: 'Premi W o FRECCIA SU per saltare!', hint: 'Salta!', check: 'jump' },
  { text: 'Premi Z o SPAZIO per attaccare! Colpisci il manichino!', hint: 'Attacca il manichino!', check: 'attack' },
  { text: 'Ora fai un COMBO completo! Premi Z piu\' volte di fila veloce!', hint: 'Completa tutto il combo (3 colpi) sul manichino!', check: 'combo' },
  { text: 'Premi X per schivare! Breve invincibilita\'.', hint: 'Schiva!', check: 'dodge' },
  { text: 'Colpire carica la barra ULTRA! Continua a colpire fino a riempirla!', hint: 'Riempi la barra dorata colpendo il manichino!', check: 'ultra' },
  { text: 'TAB = schermata aiuto completa. Helper: tasti 1-4.', hint: 'Premi TAB per aprire l\'aiuto!' },
  { text: 'Sei pronto, Conte. La gang di Valle Aurelia ti aspetta!', hint: '[ENTER] per iniziare!' }
];
let tutorialChecks = { move: false, jump: false, attack: false, combo: false, dodge: false, ultra: false };

function updateTutorial() {
  tutorialTimer++;

  // Check conditions
  if (tutorialSteps[tutorialStep] && tutorialSteps[tutorialStep].check) {
    const check = tutorialSteps[tutorialStep].check;
    if (check === 'move' && (keys['ArrowLeft'] || keys['ArrowRight'] || keys['KeyA'] || keys['KeyD'])) {
      tutorialChecks.move = true;
    }
    if (check === 'jump' && !player.grounded) {
      tutorialChecks.jump = true;
    }
    if (check === 'attack' && player.attacking) {
      tutorialChecks.attack = true;
    }
    if (check === 'combo' && player.comboChainCount >= 1) {
      // Full combo chain completed (all hits of weapon combo)
      tutorialChecks.combo = true;
    }
    if (check === 'dodge' && player.dodging) {
      tutorialChecks.dodge = true;
    }
    if (check === 'ultra' && player.ultraAvailable) {
      // Ultra bar is full
      tutorialChecks.ultra = true;
    }
  }

  updatePlayerInput();

  // Tick stamina/exhaustion/reload timers (normally in updateLevel)
  if (player.exhaustedTimer > 0) player.exhaustedTimer--;
  if (player.reloadTimer > 0) {
    player.reloadTimer--;
    if (player.reloadTimer <= 0) {
      const weap = weapons[player.weapon];
      if (weap.maxAmmo) { weap.currentAmmo = weap.maxAmmo; }
    }
  }
  if (player.staminaRegenDelay > 0) {
    player.staminaRegenDelay--;
  } else if (player.stamina < player.maxStamina) {
    player.stamina = Math.min(player.maxStamina, player.stamina + 0.8);
  }

  // Reset dummy if killed
  if (tutorialDummy && tutorialDummy.dead) {
    tutorialDummy = { x: 550, y: GROUND_Y, w: 34, h: 52, hp: 50, maxHp: 50, hitFlash: 0, stunTimer: 0, dead: false, color: '#777' };
  }
  if (tutorialDummy) tutorialDummy.hitFlash = Math.max(0, tutorialDummy.hitFlash - 1);

  // Hit detection on dummy (only on first active frame of each combo hit)
  if (player.attacking && player.attackActiveTimer === weapons[player.weapon].activeFrames - 1 && tutorialDummy && !tutorialDummy.dead) {
    const weap = weapons[player.weapon];
    const attackX = player.x + player.facing * weap.range * 0.5;
    if (Math.abs(attackX - tutorialDummy.x) < weap.range * 0.7 + tutorialDummy.w/2 && Math.abs(player.y - tutorialDummy.y) < 55) {
      const dmg = weap.damage * COMBO_DMG_MULT[Math.min(player.comboStep - 1, 3)];
      tutorialDummy.hp -= dmg;
      tutorialDummy.hitFlash = 10;
      spawnParticles(tutorialDummy.x, tutorialDummy.y - 25, '#ffeb3b', 6);
      spawnDamageNumber(tutorialDummy.x, tutorialDummy.y - 52, Math.floor(dmg), '#ffeb3b');
      playSFX('hit');
      // Ultra charge in tutorial
      if (!player.ultraActive) {
        player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 6);
        if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
      }
      if (tutorialDummy.hp <= 0) {
        tutorialDummy.dead = true;
        spawnParticles(tutorialDummy.x, tutorialDummy.y - 25, '#ffd700', 15);
      }
    }
  }

  // Ultra timer countdown in tutorial
  if (player.ultraActive) {
    player.ultraTimer--;
    if (player.ultraTimer <= 0) {
      player.ultraActive = false;
      player.ultraTimer = 0;
    }
  }

  updateParticles();
  player.x = Math.max(25, Math.min(W - 25, player.x));
}

function drawTutorial() {
  // Camera zoom
  const tutZoom = isTouchDevice ? 1.35 : 1.25;
  ctx.save();
  const tutCamX = Math.max(W / (2 * tutZoom), Math.min(W - W / (2 * tutZoom), player.x));
  const tutCamY = Math.max(H / (2 * tutZoom), Math.min(H - H / (2 * tutZoom), player.y - 40));
  ctx.translate(W / 2, H / 2);
  ctx.scale(tutZoom, tutZoom);
  ctx.translate(-tutCamX, -tutCamY);

  // Background - training area at Vanni bar
  const trainSky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  trainSky.addColorStop(0, '#0d1b2a');
  trainSky.addColorStop(1, '#1b2838');
  ctx.fillStyle = trainSky;
  ctx.fillRect(0, 0, W, GROUND_Y);
  drawRect(0, GROUND_Y, W, H - GROUND_Y, '#3e2723');
  drawRect(0, GROUND_Y, W, 3, '#5d4037');

  // Back wall - bar interior feel
  drawRect(0, 95, W, GROUND_Y - 95, '#2d2233');
  // Brick texture (reduced)
  ctx.globalAlpha = 0.08;
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 10; col++) {
      const offset = row % 2 === 0 ? 0 : 50;
      drawRect(col * 100 + offset, 100 + row * 76, 92, 68, '#5d4037');
    }
  }
  ctx.globalAlpha = 1;

  // Vanni bar counter at back
  drawRect(0, GROUND_Y - 45, W, 8, '#5d4037');
  drawRect(0, GROUND_Y - 37, W, 37, '#3e2723');
  // Bottles on shelf
  const bColors = ['#4caf50','#f44336','#2196f3','#ff9800','#9c27b0','#ffeb3b','#4caf50','#f44336'];
  bColors.forEach((c, i) => {
    drawRect(60 + i * 100, GROUND_Y - 72, 8, 28, c);
    drawRect(58 + i * 100, GROUND_Y - 74, 12, 4, c);
  });

  // Training targets on wall (punching bag outlines)
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = '#f44336';
  ctx.beginPath(); ctx.arc(180, GROUND_Y - 130, 25, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(720, GROUND_Y - 130, 25, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;
  // Target rings
  [180, 720].forEach(tx => {
    ctx.strokeStyle = '#f44336'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.arc(tx, GROUND_Y - 130, 15, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, GROUND_Y - 130, 8, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = 1;
  });

  // Warm hanging lights
  [200, 450, 700].forEach(lx => {
    drawRect(lx, 95, 2, 20, '#444');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx) * 0.1;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx + 1, 118, 14, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    drawRect(lx - 5, 114, 12, 6, '#ffd54f');
  });

  // Floor mat (training area)
  ctx.globalAlpha = 0.15;
  drawRect(300, GROUND_Y + 3, 300, H - GROUND_Y - 3, '#1565c0');
  ctx.globalAlpha = 1;

  // Vanni sign (below tutorial panel)
  drawRect(350, 92, 200, 28, '#b71c1c');
  drawRect(350, 92, 200, 2, '#e53935');
  drawText('VANNI - ADDESTRAMENTO', W/2, 112, '#fff', 13, 'center');

  // Draw dummy
  if (tutorialDummy && !tutorialDummy.dead) {
    const dx = tutorialDummy.x - tutorialDummy.w/2, dy = tutorialDummy.y - tutorialDummy.h;
    if (tutorialDummy.hitFlash > 0 && Math.floor(gameTime / 3) % 2 === 0) ctx.globalAlpha = 0.5;
    drawPixelChar(dx, dy, tutorialDummy.w, tutorialDummy.h, '#777', '#aaa', (px, py, w, h) => {
      drawText('DUMMY', px - 2, py - 8, '#999', 9);
      // X eyes
      drawRect(px + 10, py + 10, 2, 2, '#f00');
      drawRect(px + w - 12, py + 10, 2, 2, '#f00');
    });
    ctx.globalAlpha = 1;
    const hpR = tutorialDummy.hp / tutorialDummy.maxHp;
    drawRect(dx, dy - 6, 30, 4, '#333');
    drawRect(dx, dy - 6, 30 * hpR, 4, '#ff5722');
  }

  // Draw player
  drawConte(player);
  drawParticles();

  ctx.restore();

  // === Tutorial mini-HUD (ultra bar) ===
  const tutStep = tutorialSteps[tutorialStep];
  const isUltraStep = tutStep && tutStep.check === 'ultra';
  const showTutHud = tutorialStep >= 3; // show from attack step onward

  if (showTutHud) {
    // Ultra bar — same position and style as level HUD
    const ubX = 8, ubY = 84, ubW = 195, ubH = 14;
    drawRect(ubX, ubY, ubW, ubH, 'rgba(0,0,0,0.7)');
    const ultraR = player.ultraCharge / player.ultraMaxCharge;
    if (player.ultraAvailable) {
      const pulse = Math.sin(gameTime * 0.15) * 0.3 + 0.7;
      ctx.globalAlpha = pulse;
      drawRect(ubX + 1, ubY + 1, ubW - 2, ubH - 2, '#ffd700');
      drawText('Q  PRONTO!', ubX + ubW / 2, ubY + 11, '#1a1a2e', 10, 'center');
      ctx.globalAlpha = 1;
    } else {
      drawRect(ubX + 1, ubY + 1, (ubW - 2) * ultraR, ubH - 2, '#ff8f00');
      drawText('Q', ubX + 6, ubY + 11, '#ff8f00', 9);
    }

    // Pulsing highlight arrow during ultra step
    if (isUltraStep && !tutorialChecks.ultra) {
      const arrowPulse = Math.sin(gameTime * 0.1) * 8;
      const aX = ubX + ubW / 2, aY = ubY + ubH + 8 + arrowPulse;
      ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(aX - 8, aY + 10);
      ctx.lineTo(aX + 8, aY + 10);
      ctx.lineTo(aX, aY);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      drawText('COLPISCI PER CARICARE!', aX, aY + 18, '#ffd700', 10, 'center');
    }
  }

  // === Tutorial UI - at the TOP ===
  const step = tutorialSteps[tutorialStep];
  if (step) {
    drawRect(0, 0, W, 80, 'rgba(10,10,30,0.92)');
    drawRect(0, 78, W, 2, '#4caf50');

    // Step progress dots
    for (let i = 0; i < tutorialSteps.length; i++) {
      const dotX = W/2 - (tutorialSteps.length * 8) + i * 16;
      drawRect(dotX, 6, 8, 4, i < tutorialStep ? '#4caf50' : i === tutorialStep ? '#fff' : '#333');
    }

    // Step indicator
    drawText('TUTORIAL ' + (tutorialStep + 1) + '/' + tutorialSteps.length, W/2, 22, '#4caf50', 11, 'center');
    drawText(step.text, W/2, 42, '#fff', 14, 'center');
    drawText(step.hint, W/2, 62, '#aaa', 11, 'center');

    // Auto-advance or manual advance
    const hasCheck = step.check;
    const confirmPressed = keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'];
    if (hasCheck) {
      if (tutorialChecks[step.check]) {
        const bravoPulse = Math.sin(gameTime * 0.12) * 0.3 + 0.7;
        ctx.globalAlpha = bravoPulse;
        drawText('Bravo! [Z/ENTER]', W/2, 76, '#4caf50', 10, 'center');
        ctx.globalAlpha = 1;
        if (confirmPressed) { tutorialStep++; }
      }
    } else {
      if (Math.floor(gameTime / 30) % 2 === 0) {
        drawText('[Z/ENTER]', W/2, 76, '#888', 10, 'center');
      }
      if (confirmPressed) { tutorialStep++; }
    }
  }

  // Tutorial complete
  if (tutorialStep >= tutorialSteps.length) {
    state = 'hub';
    resetPlayer();
  }

  // Moves screen (TAB/P) — handled in draw phase to avoid double-toggle
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP']) {
    toggleMovesScreen();
  }

  // Mobile touch buttons
  drawTouchButtons();

  // Skip option — top right, big enough to tap on mobile
  const skipBtnW = 140, skipBtnH = 36;
  const skipBtnX = W - skipBtnW - 10, skipBtnY = 86;
  const skipHover = mouseX >= skipBtnX && mouseX <= skipBtnX + skipBtnW && mouseY >= skipBtnY && mouseY <= skipBtnY + skipBtnH;
  drawRect(skipBtnX, skipBtnY, skipBtnW, skipBtnH, skipHover ? 'rgba(255,255,255,0.25)' : 'rgba(255,255,255,0.1)');
  drawRect(skipBtnX, skipBtnY, skipBtnW, 2, '#888');
  drawText('SALTA TUTORIAL >', skipBtnX + skipBtnW / 2, skipBtnY + 23, skipHover ? '#fff' : '#aaa', 12, 'center');
  if ((mouseClick && skipHover) || keys['Escape']) {
    state = 'hub';
    resetPlayer();
    mouseClick = false;
  }
}

function resetPlayer() {
  player.x = 200;
  player.y = 430;
  player.hp = player.maxHp;
  player.stamina = player.maxStamina;
  player.dead = false;
  player.invincible = player.maxHp >= 999 ? 999999 : 0; // preserve cheat invincibility
  player.attacking = false;
  player.attackTimer = 0;
  player.attackCooldown = 0;
  player.dodging = false;
  player.dodgeTimer = 0;
  player.dodgeCooldown = 0;
  player.vx = 0;
  player.vy = 0;
  player.stunTimer = 0;
  player.speedBoost = 0;
  player.comboStep = 0;
  player.comboWindowTimer = 0;
  player.endLagTimer = 0;
  player.attackBuffered = false;
  player.attackActiveTimer = 0;
  player.comboChainCount = 0;
  player.jumpAttacking = false;
  player.stamina = player.maxStamina;
  player.staminaRegenDelay = 0;
  player.reloadTimer = 0;
  // Reset ammo on level start
  const w0 = weapons[player.weapon];
  if (w0 && w0.maxAmmo) w0.currentAmmo = w0.maxAmmo;
  player.comboHitCount = 0;
  player.comboHitTimer = 0;
  player.scoreMultiplier = 1;
  player.hazardSlow = false;
  player.exhaustedTimer = 0;
  player.sameTargetHits = 0;
  player.sameTargetTimer = 0;
  player.lastHitTarget = null;
  // Ultra system reset
  player.ultraCharge = 0;
  player.ultraActive = false;
  player.ultraTimer = 0;
  player.ultraAvailable = false;
}

// ==========================================
// WEAPON SELECT
// ==========================================
function drawWeaponSelect() {
  // Input guard — ignore keys for first 20 frames so menu Enter doesn't carry over
  weaponSelectTimer++;
  if (weaponSelectTimer > 20) weaponSelectReady = true;

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawText('SCEGLI LA TUA ARMA', W/2, 45, '#ffd700', 24, 'center');
  drawText('"Conte, da Vanni c\'e\' rimasto \'sto ben di Dio..."', W/2, 68, '#aaa', 11, 'center');

  // Navigate with arrows/WASD or 1-4
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) {
    weaponSelectIndex = Math.max(0, weaponSelectIndex - 1);
    playSFX('hit');
  }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) {
    weaponSelectIndex = Math.min(3, weaponSelectIndex + 1);
    playSFX('hit');
  }
  if (keysJustPressed['Digit1']) { weaponSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { weaponSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { weaponSelectIndex = 2; playSFX('hit'); }
  if (keysJustPressed['Digit4']) { weaponSelectIndex = 3; playSFX('hit'); }

  const cardW = 190, cardH = 340, gap = 15;
  const totalW = 4 * cardW + 3 * gap;
  const startX = (W - totalW) / 2;
  const startY = 85;

  for (let i = 0; i < 4; i++) {
    const sw = starterWeapons[i];
    const cx = startX + i * (cardW + gap);
    const cy = startY;
    const selected = (i === weaponSelectIndex);
    const isHover = mouseX > cx && mouseX < cx + cardW && mouseY > cy && mouseY < cy + cardH;

    if (isHover && mouseClick) {
      weaponSelectIndex = i;
    }

    // Card background
    ctx.globalAlpha = selected ? 1 : 0.5;
    drawRect(cx, cy, cardW, cardH, selected ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.4)');
    drawRect(cx, cy, cardW, 3, sw.color);
    if (selected) {
      drawRect(cx, cy + cardH - 3, cardW, 3, sw.color);
      drawRect(cx, cy, 3, cardH, sw.color);
      drawRect(cx + cardW - 3, cy, 3, cardH, sw.color);
    }

    // Number key hint
    drawText((i+1) + '', cx + 12, cy + 22, selected ? sw.color : '#555', 14);

    // Weapon name
    drawText(sw.name, cx + cardW/2, cy + 38, selected ? '#fff' : '#888', 14, 'center');

    // Weapon icon/visual
    const iconY = cy + 85;
    drawWeaponIcon(cx + cardW/2, iconY, sw, selected);

    // Type label
    const types = ['VELOCE', 'BILANCIATO', 'PESANTE', 'RANGED'];
    const typeColors = ['#4caf50', '#2196f3', '#ff9800', '#9c27b0'];
    drawText(types[i], cx + cardW/2, cy + 135, typeColors[i], 10, 'center');

    // Stats
    const statY = cy + 160;
    const statX = cx + 15;
    const barMaxW = cardW - 30;

    drawStatBar(statX, statY, 'DANNO', sw.damage, 40, barMaxW, '#f44336');
    drawStatBar(statX, statY + 28, 'RAGGIO', Math.min(sw.range, 100), 100, barMaxW, '#2196f3');
    drawStatBar(statX, statY + 56, 'VELOCITA\'', 20 - sw.speed, 20, barMaxW, '#4caf50');
    drawStatBar(statX, statY + 84, 'CRITICO', sw.crit, 30, barMaxW, '#ffeb3b');
    drawStatBar(statX, statY + 112, 'COMBO', sw.comboHits, 5, barMaxW, '#e040fb');

    // Description
    drawText(sw.desc, cx + cardW/2, cy + cardH - 20, selected ? '#ccc' : '#555', 8, 'center');
    ctx.globalAlpha = 1;
  }

  // Key hint
  drawText('Frecce/1-4 per scegliere', W/2, startY + cardH + 18, '#555', 10, 'center');

  // Confirm button
  const confirmW = 220, confirmH = 40;
  const confirmX = W/2 - confirmW/2, confirmY = startY + cardH + 30;
  const confirmHover = mouseX >= confirmX && mouseX <= confirmX + confirmW && mouseY >= confirmY && mouseY <= confirmY + confirmH;
  const selColor = starterWeapons[weaponSelectIndex].color;
  const pulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  drawRect(confirmX, confirmY, confirmW, confirmH, confirmHover ? selColor : 'rgba(255,255,255,0.1)');
  drawRect(confirmX, confirmY, confirmW, 3, selColor);
  drawText('CONFERMA', W/2, confirmY + 27, '#fff', 14, 'center');
  ctx.globalAlpha = 1;

  // Confirm selection (keyboard, or tap confirm button)
  const confirmTap = weaponSelectReady && confirmHover && mouseClick;
  if (weaponSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    const chosen = JSON.parse(JSON.stringify(starterWeapons[weaponSelectIndex]));
    if (chosen.maxAmmo) chosen.currentAmmo = chosen.maxAmmo;
    weapons = [chosen];
    player.weapon = 0;
    weaponTier = 0;
    // Go to helper select
    state = 'helperSelect';
    helperSelectIndex = 0;
    helperSelectReady = false;
    helperSelectTimer = 0;
    spawnParticles(W/2, H/2, selColor, 25, 6);
    playSFX('coin');
  }

  mouseClick = false;
}

function drawHelperSelect() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0d1a');
  grad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  helperSelectTimer++;
  if (helperSelectTimer > 15) helperSelectReady = true;

  drawText('SCEGLI IL TUO ALLEATO', W/2, 45, '#e040fb', 24, 'center');
  drawText('Gli altri si sbloccano dall\'armeria di Vanni', W/2, 68, '#888', 10, 'center');

  // Navigate
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) {
    helperSelectIndex = Math.max(0, helperSelectIndex - 1); playSFX('hit');
  }
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) {
    helperSelectIndex = Math.min(3, helperSelectIndex + 1); playSFX('hit');
  }
  if (keysJustPressed['Digit1']) { helperSelectIndex = 0; playSFX('hit'); }
  if (keysJustPressed['Digit2']) { helperSelectIndex = 1; playSFX('hit'); }
  if (keysJustPressed['Digit3']) { helperSelectIndex = 2; playSFX('hit'); }
  if (keysJustPressed['Digit4']) { helperSelectIndex = 3; playSFX('hit'); }

  const cardW = 190, cardH = 340, gap = 15;
  const totalW = 4 * cardW + 3 * gap;
  const startX = (W - totalW) / 2;
  const startY = 85;

  for (let i = 0; i < 4; i++) {
    const h = helpers[i];
    const cx = startX + i * (cardW + gap);
    const cy = startY;
    const isHover = mouseX > cx && mouseX < cx + cardW && mouseY > cy && mouseY < cy + cardH;
    const selected = (i === helperSelectIndex);

    if (isHover && mouseClick && helperSelectReady) {
      helperSelectIndex = i;
    }

    ctx.globalAlpha = selected ? 1 : 0.5;
    drawRect(cx, cy, cardW, cardH, selected ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.4)');
    drawRect(cx, cy, cardW, 3, h.color);
    if (selected) {
      drawRect(cx, cy + cardH - 3, cardW, 3, h.color);
      drawRect(cx, cy, 3, cardH, h.color);
      drawRect(cx + cardW - 3, cy, 3, cardH, h.color);
    }

    // Number key hint
    drawText((i+1) + '', cx + 12, cy + 22, selected ? h.color : '#555', 14);

    // Icon
    drawRect(cx + cardW/2 - 25, cy + 35, 50, 50, 'rgba(0,0,0,0.5)');
    drawText(h.icon, cx + cardW/2, cy + 70, h.color, 32, 'center');

    // Name
    drawText(h.name, cx + cardW/2, cy + 110, '#fff', 16, 'center');

    // Main effect description
    const helperDescs = [
      ['Stordisce i nemici vicini', 'Utile per uscire da situazioni difficili'],
      ['Coltellata diretta al boss', 'Danno pesante, colpisce il boss'],
      ['Cura +35 HP', 'Fonte di cura in battaglia'],
      ['Velocita\' x2 per 8 secondi', 'Muoviti e colpisci piu\' veloce']
    ];
    drawText(helperDescs[i][0], cx + cardW/2, cy + 138, '#fff', 11, 'center');
    drawText(helperDescs[i][1], cx + cardW/2, cy + 156, '#999', 9, 'center');
    drawText('Cooldown: ' + Math.floor(h.cooldown / 60) + 's', cx + cardW/2, cy + 178, h.color, 9, 'center');

    ctx.globalAlpha = 1;
  }

  // Key hint
  drawText('Frecce/1-4 per scegliere', W/2, startY + cardH + 18, '#555', 10, 'center');

  // Confirm button
  const confirmW = 220, confirmH = 40;
  const confirmBtnX = W/2 - confirmW/2, confirmBtnY = startY + cardH + 30;
  const confirmHover = mouseX > confirmBtnX && mouseX < confirmBtnX + confirmW && mouseY > confirmBtnY && mouseY < confirmBtnY + confirmH;
  const selColor = helpers[helperSelectIndex].color;
  const pulse = Math.sin(gameTime * 0.08) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  drawRect(confirmBtnX, confirmBtnY, confirmW, confirmH, confirmHover ? selColor : 'rgba(255,255,255,0.1)');
  drawRect(confirmBtnX, confirmBtnY, confirmW, 3, selColor);
  drawText('CONFERMA', W/2, confirmBtnY + 27, '#fff', 14, 'center');
  ctx.globalAlpha = 1;

  const confirmTap = helperSelectReady && confirmHover && mouseClick;
  if (helperSelectReady && (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap)) {
    // Unlock the chosen helper for free
    helpers.forEach((hlp, idx) => { hlp.unlocked = (idx === helperSelectIndex); });
    // Go to tutorial
    state = 'tutorial';
    resetPlayer();
    player.x = 200;
    tutorialStep = 0;
    tutorialTimer = 0;
    tutorialDummy = { x: 550, y: GROUND_Y, w: 34, h: 52, hp: 50, maxHp: 50, hitFlash: 0, stunTimer: 0, dead: false, color: '#777' };
    spawnParticles(W/2, H/2, helpers[helperSelectIndex].color, 25, 6);
    playSFX('coin');
  }
  mouseClick = false;
}

function drawWeaponIcon(cx, cy, w, selected) {
  const col = w.color;
  if (w.name === 'Sanpietrino') {
    // Cobblestone
    drawRect(cx - 12, cy - 10, 24, 20, '#9e9e9e');
    drawRect(cx - 10, cy - 8, 20, 16, '#bdbdbd');
    drawRect(cx - 6, cy - 4, 4, 4, '#757575');
    drawRect(cx + 2, cy, 4, 4, '#757575');
  } else if (w.name === 'Cacciavite') {
    // Screwdriver
    drawRect(cx - 2, cy - 18, 4, 24, '#ff8a65');
    drawRect(cx - 4, cy + 6, 8, 10, '#795548');
    drawRect(cx - 1, cy - 20, 2, 4, '#bbb');
  } else if (w.name === 'Spranga') {
    // Metal pipe
    drawRect(cx - 3, cy - 22, 6, 44, '#795548');
    drawRect(cx - 4, cy - 22, 8, 6, '#5d4037');
    drawRect(cx - 2, cy + 16, 4, 6, '#4e342e');
  } else if (w.name === 'Fionda') {
    // Slingshot
    drawRect(cx - 8, cy - 12, 3, 24, '#8d6e63');
    drawRect(cx + 5, cy - 12, 3, 24, '#8d6e63');
    drawRect(cx - 8, cy - 12, 16, 3, '#8d6e63');
    drawRect(cx - 1, cy + 8, 2, 8, '#795548');
    // Rubber band
    ctx.strokeStyle = '#ffcc80';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - 7, cy - 10);
    ctx.lineTo(cx, cy);
    ctx.lineTo(cx + 7, cy - 10);
    ctx.stroke();
  }
}

function drawStatBar(x, y, label, value, maxVal, barW, color) {
  drawText(label, x, y + 8, '#888', 7);
  const bx = x, by = y + 12, bw = barW, bh = 6;
  drawRect(bx, by, bw, bh, '#222');
  drawRect(bx, by, bw * Math.min(value / maxVal, 1), bh, color);
}

// ==========================================
// MOVES/SKILLS REFERENCE SCREEN
// ==========================================
let movesScreenOpen = false;
let movesScreenPrev = ''; // state to return to

function toggleMovesScreen() {
  if (movesScreenOpen) {
    state = movesScreenPrev;
    movesScreenOpen = false;
  } else {
    movesScreenPrev = state;
    state = 'moves';
    movesScreenOpen = true;
  }
}

function drawMovesScreen() {
  ctx.fillStyle = '#0a0a19';
  ctx.fillRect(0, 0, W, H);

  drawText('AIUTO', W/2, 28, '#ffd700', 22, 'center');
  drawText('TAB / ESC = chiudi', W/2, 46, '#555', 9, 'center');

  // Helper to draw a section box
  const drawSection = (x, y, w, h, title, titleCol, rows, keyCol) => {
    drawRect(x, y, w, h, '#111');
    drawRect(x, y, w, 2, titleCol);
    drawText(title, x + 8, y + 15, titleCol, 11);
    let ry = y + 28;
    rows.forEach(([key, desc]) => {
      drawText(key, x + 10, ry, keyCol, 9);
      drawText(desc, x + 80, ry, '#bbb', 8);
      ry += 16;
    });
  };

  // Col 1 — left side
  // ATTACCO
  drawSection(20, 60, 430, 112, 'ATTACCO', '#e94560', [
    ['Z / Spazio', 'Colpisci. Premi piu\' volte = combo chain'],
    ['Q', 'ULTRA — barra piena → attiva (1.5x danno, velocita\', 5 sec)'],
    ['W+Z', 'Overhead — colpo dall\'alto, 2x danno postura'],
    ['Z in aria', 'Attacco aereo'],
    ['X', 'Schivata (durante windup nemico = COUNTER)'],
  ], '#ff8a65');

  // MOVIMENTO
  drawSection(20, 182, 430, 58, 'MOVIMENTO', '#2196f3', [
    ['A/D', 'Muovi    |    W = Salta    |    X = Schiva'],
  ], '#64b5f6');

  // STAMINA
  drawSection(20, 250, 430, 68, 'STAMINA', '#fdd835', [
    ['Costo', 'Colpo = 12 | Ultra = 7 per colpo'],
    ['Esaurito', 'Stamina a 0 → bloccato brevemente'],
  ], '#fff59d');

  // Col 2 — right side
  // SPECIALI ARMA
  drawSection(460, 60, 420, 128, 'SPECIALI ARMA (attivi durante Ultra)', '#ff8a65', [
    ['Sanpietrino', 'Crit cresce ad ogni colpo del combo'],
    ['Cacciavite', 'Sanguinamento su ogni colpo'],
    ['Spranga', 'Colpo 1 lungo, Colpo 2 entrambi i lati'],
    ['Fionda', 'Ultra: il 3o colpo perfora i nemici'],
    ['Machete', '2x danno su nemici sotto 25% HP'],
    ['Catena', 'Attira nemici vicini'],
  ], '#ffcc80');

  // HELPER
  drawSection(460, 198, 420, 78, 'HELPER', '#e040fb', [
    ['1', 'Pirox — Stun'],
    ['2', 'Tommy — Coltellata'],
    ['3', 'Cicca — Cura'],
    ['4', 'Il Mostro — Speed'],
  ], '#ce93d8');

  // TASTI
  drawSection(460, 306, 420, 58, 'ALTRI TASTI', '#78909c', [
    ['S', 'Armeria (nel hub)    |    M = Musica on/off'],
    ['TAB/P', 'Mosse (questa schermata)'],
  ], '#b0bec5');

  // Current weapon info at bottom
  const w = weapons[player.weapon] || weapons[0];
  // Determine rarity
  let rarityLetter = 'C', rarityColor = '#9e9e9e', rarityName = 'Comune';
  if (rareWeapons.some(rw => rw.name === w.name)) { rarityLetter = 'R'; rarityColor = '#2196f3'; rarityName = 'Raro'; }
  else if (legendaryWeapons.some(lw => lw.name === w.name) || w.special === 'sbombo') { rarityLetter = 'L'; rarityColor = '#ffd700'; rarityName = 'Leggendario'; }

  drawRect(20, 424, W - 40, 50, '#1a1a2e');
  drawRect(20, 424, W - 40, 2, w.color || '#888');
  // Rarity badge
  drawRect(22, 428, 22, 22, rarityColor);
  drawText(rarityLetter, 33, 444, '#000', 14, 'center');
  drawText('ARMA ATTUALE: ' + w.name, 52, 444, '#fff', 12);
  drawText(rarityName, 52, 462, rarityColor, 9);
  drawText('DMG ' + w.damage + '  |  RNG ' + w.range + '  |  CRIT ' + w.crit + '%  |  COMBO ' + w.comboHits + ' colpi', 400, 444, '#ffcc80', 9);
  drawText('Speciale: ' + (w.special || 'nessuno'), 400, 462, '#ff8a65', 9);

  // Separator line at very bottom
  drawRect(20, 480, W - 40, 1, '#333');
  drawText('"Nun te scorda\' come se combatte, Conte!"', W/2, 498, '#444', 9, 'center');

  // Close button (tappable)
  const closeMBtnW = 100, closeMBtnH = 30;
  const closeMBtnX = W/2 - closeMBtnW/2, closeMBtnY = H - 45;
  const closeMHover = mouseX >= closeMBtnX && mouseX <= closeMBtnX + closeMBtnW && mouseY >= closeMBtnY && mouseY <= closeMBtnY + closeMBtnH;
  drawRect(closeMBtnX, closeMBtnY, closeMBtnW, closeMBtnH, closeMHover ? '#e94560' : 'rgba(233,69,96,0.4)');
  drawText('CHIUDI', W/2, closeMBtnY + 21, '#fff', 13, 'center');

  // Level options: restart or return to hub (only when opened from level/tutorial)
  if (movesScreenPrev === 'level' || movesScreenPrev === 'tutorial') {
    const optY = H - 45;
    // Restart level
    const restartW = 150, restartH = 28;
    const restartX = 20, restartY = optY;
    const restartHover = mouseX >= restartX && mouseX <= restartX + restartW && mouseY >= restartY && mouseY <= restartY + restartH;
    drawRect(restartX, restartY, restartW, restartH, restartHover ? '#ff9800' : 'rgba(255,152,0,0.3)');
    drawText('RICOMINCIA', restartX + restartW/2, restartY + 20, restartHover ? '#fff' : '#ff9800', 11, 'center');
    if (restartHover && mouseClick) {
      movesScreenOpen = false;
      startLevel(currentLevel);
      mouseClick = false;
      return;
    }
    // Back to hub
    const hubW = 150, hubH = 28;
    const hubX = W - hubW - 20, hubY = optY;
    const hubHover = mouseX >= hubX && mouseX <= hubX + hubW && mouseY >= hubY && mouseY <= hubY + hubH;
    drawRect(hubX, hubY, hubW, hubH, hubHover ? '#4caf50' : 'rgba(76,175,80,0.3)');
    drawText('TORNA A VANNI', hubX + hubW/2, hubY + 20, hubHover ? '#fff' : '#4caf50', 11, 'center');
    if (hubHover && mouseClick) {
      movesScreenOpen = false;
      state = 'hub';
      resetPlayer();
      mouseClick = false;
      return;
    }
  }

  // Restart game button (always visible)
  const rgW = 180, rgH = 28;
  const rgX = W - rgW - 20, rgY = 8;
  const rgHover = mouseX >= rgX && mouseX <= rgX + rgW && mouseY >= rgY && mouseY <= rgY + rgH;
  drawRect(rgX, rgY, rgW, rgH, rgHover ? '#b71c1c' : 'rgba(183,28,28,0.3)');
  drawText('RICOMINCIA DA CAPO', rgX + rgW/2, rgY + 20, rgHover ? '#fff' : '#ef5350', 11, 'center');
  if (rgHover && mouseClick) {
    movesScreenOpen = false;
    coins = 0; weapons = [starterWeapons[0]]; weaponTier = 0;
    healthTier = 0; dodgeTier = 0; speedTier = 0;
    player.maxHp = 120; player.maxStamina = 100; player.speed = 4.0;
    player.upgrades = [];
    helpers.forEach(h => { h.tier = 0; h.unlocked = false; });
    bossDefeated = [false, false, false, false, false];
    lives = 3; firstTime = true;
    state = 'menu';
    resetPlayer();
    mouseClick = false;
    return;
  }

  // Close on TAB, P, ESC, or tap
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP'] || keysJustPressed['Escape'] || (closeMHover && mouseClick)) {
    toggleMovesScreen();
  }

  mouseClick = false;
}

// ==========================================
// HUB - VANNI
// ==========================================
let hubSelection = 0;
let hubConfirm = false; // level confirmation box active
let hubInputCooldown = 0; // prevents accidental input bleed-through
let shopOpen = false;
let lampHit = false, lampFlicker = 0;
let hubCatX = 100, hubCatDir = 1, hubCatTimer = 0, hubCatPetted = false, hubCatSitting = 0;
let wallTaps = 0, graffitiRevealed = false, graffitiAlpha = 0;
let drinkTaken = false, drinkWobble = 0, drinkBuff = 0;
let hasSunglasses = false;
let micheleVisited = false;
let micheleArgueTimer = 0;
let micheleArgueLine = '';
let micheleArgueIntroDone = false;
let micheleArgueFirstSeen = false;
let backroomPhase = 0; // 0=dialogue, 1=choice, 2=response, 3=exit
let backroomLine = 0;
let backroomChoice = -1; // 0=Scarabeo, 1=TMAX
let backroomCooldown = 0; // input cooldown to prevent accidental double-tap
let hubVisitInited = false;

function drawHub() {
  // Reset per-visit secrets on hub entry
  if (!hubVisitInited) {
    hubVisitInited = true;
    hubCatSitting = 0; hubCatX = 100; hubCatDir = 1; hubCatTimer = 0;
    wallTaps = 0; graffitiRevealed = false; graffitiAlpha = 0;
    drinkWobble = 0;
    // lampHit, drinkTaken, hubCatPetted, and hasSunglasses persist across visits
  }

  // Night sky
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#070714');
  grad.addColorStop(0.4, '#0d0d24');
  grad.addColorStop(1, '#1a1a30');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.015 + i * 2) * 0.15;
    drawRect((i * 67) % W, (i * 31) % 100 + 5, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Roman palazzi in background (neighbors)
  // COLOR THEORY: split-complementary off indigo sky (#070714)
  //   Vanni = warm sienna-amber (indigo's complement) → focal glow
  //   Left  = cool slate blue (analogous to sky) → recedes into night
  //   Right = dusty rose-clay (bridges toward Bingo's purple)

  // Left palazzo — cool slate blue, in night shadow
  drawRect(-10, 140, 160, 270, '#363d4d');
  drawRect(-10, 140, 160, 3, '#4a5265');
  for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
    const nwx = 10 + c * 55, nwy = 170 + r * 60;
    drawRect(nwx, nwy, 24, 35, '#181c28');
    ctx.globalAlpha = 0.12;
    drawRect(nwx + 1, nwy + 1, 22, 33, '#c8d0e0');
    ctx.globalAlpha = 1;
    // Shutters (muted teal-green, works with blue wall)
    drawRect(nwx - 4, nwy, 4, 35, '#3d5c4a');
    drawRect(nwx + 24, nwy, 4, 35, '#3d5c4a');
    // Sill
    drawRect(nwx - 2, nwy + 35, 28, 3, '#4a5265');
  }
  // Right palazzo — dusty rose-clay, bridges to Bingo's purple
  drawRect(740, 160, 180, 250, '#4a3840');
  drawRect(740, 160, 180, 3, '#5e4850');
  for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
    const nwx = 760 + c * 55, nwy = 185 + r * 60;
    drawRect(nwx, nwy, 24, 35, '#1e1820');
    ctx.globalAlpha = 0.12;
    drawRect(nwx + 1, nwy + 1, 22, 33, '#e0d0d8');
    ctx.globalAlpha = 1;
    drawRect(nwx - 4, nwy, 4, 35, '#5a4048');
    drawRect(nwx + 24, nwy, 4, 35, '#5a4048');
    drawRect(nwx - 2, nwy + 35, 28, 3, '#5e4850');
  }

  // BAR VANNI - main building (warm sienna-amber — complement of indigo sky)
  const facadeGrad = ctx.createLinearGradient(150, 100, 150, 410);
  facadeGrad.addColorStop(0, '#6a5038');
  facadeGrad.addColorStop(0.4, '#5a4433');
  facadeGrad.addColorStop(1, '#4a3828');
  ctx.fillStyle = facadeGrad;
  ctx.fillRect(150, 100, 540, 310);
  // Subtle stucco texture
  for (let ty = 0; ty < 10; ty++) for (let tx = 0; tx < 18; tx++) {
    ctx.globalAlpha = 0.03 + ((tx * 7 + ty * 13) % 5) * 0.008;
    drawRect(152 + tx * 30, 104 + ty * 30, 28, 28, (tx + ty) % 2 === 0 ? '#7a6048' : '#4a3828');
  }
  ctx.globalAlpha = 1;
  // Roofline cornice
  drawRect(146, 96, 548, 8, '#6a5848');
  drawRect(146, 96, 548, 2, '#8a7460');
  drawRect(148, 104, 544, 2, '#3a2e22');

  // Red/maroon awning with scalloped edge and stripe detail
  const awningGrad = ctx.createLinearGradient(0, 125, 0, 158);
  awningGrad.addColorStop(0, '#9b2020');
  awningGrad.addColorStop(0.5, '#8b1a1a');
  awningGrad.addColorStop(1, '#6d1414');
  ctx.fillStyle = awningGrad;
  ctx.fillRect(140, 125, 560, 32);
  // Awning highlight stripe
  drawRect(140, 125, 560, 2, '#c62828');
  drawRect(140, 139, 560, 1, 'rgba(255,200,150,0.08)');
  // Scalloped edge
  for (let i = 0; i < 14; i++) {
    ctx.fillStyle = '#6d1414';
    ctx.beginPath();
    ctx.arc(160 + i * 40, 158, 13, 0, Math.PI);
    ctx.fill();
    // Scallop highlight
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    ctx.arc(160 + i * 40, 158, 11, Math.PI, Math.PI * 1.5);
    ctx.fill();
  }

  // BAR VANNI sign — elegant dark backing with gold lettering
  drawRect(310, 93, 220, 36, '#111');
  drawRect(310, 93, 220, 2, '#c62828');
  drawRect(310, 127, 220, 2, '#3e2723');
  // Inner border
  drawRect(314, 97, 212, 28, 'rgba(139,26,26,0.3)');
  drawText('BAR VANNI', 420, 118, '#ffd54f', 20, 'center');
  // Subtle gold glow behind text
  ctx.globalAlpha = 0.08;
  drawText('BAR VANNI', 420, 118, '#fff', 21, 'center');
  ctx.globalAlpha = 1;

  // Windows — with wooden shutters, warm interior glow, and sills
  for (let i = 0; i < 3; i++) {
    const wx = 175 + i * 175;
    // Window recess (shadow)
    drawRect(wx - 2, 168, 84, 104, '#2c2218');
    // Glass / interior
    drawRect(wx, 170, 80, 100, '#1a1a2e');
    // Warm interior glow
    const winGlow = 0.3 + Math.sin(gameTime * 0.02 + i) * 0.08;
    ctx.globalAlpha = winGlow;
    const wGrad = ctx.createRadialGradient(wx + 40, 220, 5, wx + 40, 220, 50);
    wGrad.addColorStop(0, '#ffe0b2');
    wGrad.addColorStop(0.6, '#ffcc80');
    wGrad.addColorStop(1, '#4a3520');
    ctx.fillStyle = wGrad;
    ctx.fillRect(wx + 2, 172, 76, 96);
    ctx.globalAlpha = 1;
    // Interior silhouettes (bottles on shelf)
    ctx.globalAlpha = 0.12;
    for (let b = 0; b < 4; b++) {
      drawRect(wx + 10 + b * 18, 195, 6, 14, '#1a1a1a');
      drawRect(wx + 12 + b * 18, 190, 2, 6, '#1a1a1a');
    }
    ctx.globalAlpha = 1;
    // Wooden frame (warm brown)
    drawRect(wx, 170, 80, 3, '#5d4037');
    drawRect(wx, 267, 80, 3, '#5d4037');
    drawRect(wx, 170, 3, 100, '#5d4037');
    drawRect(wx + 77, 170, 3, 100, '#5d4037');
    // Cross mullion
    drawRect(wx, 218, 80, 2, '#5d4037');
    drawRect(wx + 38, 170, 3, 100, '#5d4037');
    // Window sill
    drawRect(wx - 4, 270, 88, 5, '#8d7b6a');
    drawRect(wx - 4, 270, 88, 1, '#a09080');
    // Flower box under window
    drawRect(wx + 5, 275, 70, 8, '#5d4037');
    drawRect(wx + 5, 275, 70, 1, '#795548');
    // Little green tufts
    for (let f = 0; f < 5; f++) {
      ctx.fillStyle = ['#4caf50', '#388e3c', '#66bb6a', '#2e7d32', '#81c784'][f];
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(wx + 12 + f * 14, 274, 4 + (f % 2), Math.PI, 0);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Door — open entrance with warm inviting light
  // Door frame (thick wood)
  drawRect(382, 276, 76, 134, '#4e342e');
  drawRect(383, 277, 74, 133, '#3e2723');
  // Inner door / opening
  drawRect(386, 280, 68, 130, '#2a1f16');
  drawRect(388, 283, 64, 127, '#1e1610');
  // Warm light spilling out
  ctx.globalAlpha = 0.35;
  const doorGlow = ctx.createRadialGradient(420, 320, 10, 420, 320, 70);
  doorGlow.addColorStop(0, '#ffe0b2');
  doorGlow.addColorStop(0.5, '#ffcc80');
  doorGlow.addColorStop(1, 'rgba(255,180,100,0)');
  ctx.fillStyle = doorGlow;
  ctx.beginPath();
  ctx.arc(420, 310, 60, Math.PI, 0);
  ctx.fill();
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = '#ffcc80';
  ctx.fillRect(375, 340, 90, 70);
  ctx.globalAlpha = 1;
  // Light cast on ground from door
  ctx.globalAlpha = 0.06;
  ctx.beginPath();
  ctx.moveTo(386, 410);
  ctx.lineTo(350, 435);
  ctx.lineTo(490, 435);
  ctx.lineTo(454, 410);
  ctx.fillStyle = '#ffcc80';
  ctx.fill();
  ctx.globalAlpha = 1;
  // Espresso machine glow inside (through door)
  drawRect(400, 298, 20, 26, '#555');
  drawRect(401, 299, 18, 24, '#666');
  drawRect(404, 293, 12, 8, '#999');
  drawRect(406, 291, 8, 4, '#bbb');
  ctx.globalAlpha = 0.7;
  drawRect(406, 302, 8, 4, '#ff6f00');
  // Steam wisp from machine
  ctx.globalAlpha = 0.08 + Math.sin(gameTime * 0.05) * 0.04;
  ctx.beginPath();
  ctx.arc(410, 288 - Math.sin(gameTime * 0.03) * 3, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#ccc';
  ctx.fill();
  ctx.globalAlpha = 1;
  // Door arch (decorative top)
  ctx.strokeStyle = '#5d4037';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(420, 280, 37, Math.PI, 0);
  ctx.stroke();
  ctx.lineWidth = 1;

  // Backroom door click — Michele Lo Sbirro
  const vanniDoorHover = !hubConfirm && !(bossDefeated[0] && !micheleVisited && !micheleArgueFirstSeen) && mouseX > 385 && mouseX < 455 && mouseY > 280 && mouseY < 410;
  if (vanniDoorHover) {
    ctx.globalAlpha = 0.15;
    drawRect(385, 280, 70, 130, '#ffcc80');
    ctx.globalAlpha = 1;
  }
  if (!showCredits && !hubConfirm && vanniDoorHover && mouseClick) {
    if (micheleVisited) {
      showQuickText("Michele e' andato a jiu jitsu... o cosi dice", '#78909c');
    } else {
      state = 'backroom';
      backroomPhase = 0;
      backroomLine = 0;
      backroomChoice = -1;
      backroomCooldown = 15;
      micheleArgueTimer = 0;
      micheleArgueLine = '';
    }
    mouseClick = false;
  }

  // Michele arguing hint — after LaFed beaten, if not yet visited
  if (bossDefeated[0] && !micheleVisited) {
    if (!micheleArgueIntroDone) {
      // Intro dialogue box — player must click to dismiss
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, W, H);
      const dlgX = W/2 - 250, dlgY = H/2 - 50, dlgW = 500, dlgH = 100;
      drawRect(dlgX + 3, dlgY + 3, dlgW, dlgH, 'rgba(0,0,0,0.3)');
      drawRect(dlgX, dlgY, dlgW, dlgH, 'rgba(20,20,40,0.95)');
      drawRect(dlgX, dlgY, dlgW, 3, '#ff8a65');
      ctx.strokeStyle = '#5d4037';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(dlgX, dlgY, dlgW, dlgH);
      ctx.lineWidth = 1;
      drawText('Qualcuno urla da dentro il bar...', W/2, dlgY + 42, '#ff8a65', 16, 'center');
      const blinkAlpha = 0.5 + Math.sin(gameTime * 0.08) * 0.3;
      ctx.globalAlpha = blinkAlpha;
      drawText('[Click / Enter]', W/2, dlgY + 78, '#888', 11, 'center');
      ctx.globalAlpha = 1;
      if (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space']) {
        micheleArgueIntroDone = true;
        // Trigger first arguing bubble almost immediately
        const MICHELE_ARGUE = [
          '"Te lo giuro, e\' solo un\'amica!"',
          '"Amore, ho perso il telefono per 3 giorni, capita!"',
          '"Non e\' come sembra! Ero a jiu jitsu!"',
          '"Ma quale sparizione?! Ero a fare surf!"',
          '"Si, ok, non ho risposto... ma avevo il telefono in silenzioso!"',
          '"Non urlare che ci sentono fuori!"',
          '"Lo sai che ti amo... e anche il jiu jitsu..."',
          '"Colpa del Conte, mi ha distratto!"',
          '"Dai, ti porto in snowboard... domani... forse..."',
          '"OK OK hai ragione, come sempre, MA..."'
        ];
        micheleArgueLine = MICHELE_ARGUE[Math.floor(Math.random() * MICHELE_ARGUE.length)];
        micheleArgueTimer = 180;
        hubInputCooldown = 15;
        mouseClick = false;
      }
    } else {
      // Periodic arguing bubble from the door
      if (micheleArgueTimer <= 0 && gameTime % 180 === 0) {
        const MICHELE_ARGUE = [
          '"Te lo giuro, e\' solo un\'amica!"',
          '"Amore, ho perso il telefono per 3 giorni, capita!"',
          '"Non e\' come sembra! Ero a jiu jitsu!"',
          '"Ma quale sparizione?! Ero a fare surf!"',
          '"Si, ok, non ho risposto... ma avevo il telefono in silenzioso!"',
          '"Non urlare che ci sentono fuori!"',
          '"Lo sai che ti amo... e anche il jiu jitsu..."',
          '"Colpa del Conte, mi ha distratto!"',
          '"Dai, ti porto in snowboard... domani... forse..."',
          '"OK OK hai ragione, come sempre, MA..."'
        ];
        micheleArgueLine = MICHELE_ARGUE[Math.floor(Math.random() * MICHELE_ARGUE.length)];
        micheleArgueTimer = 150;
      }
      if (micheleArgueTimer > 0) {
        micheleArgueTimer--;
        drawCasinoBubble(420, 278, micheleArgueLine, 200, '#78909c');
      } else if (!micheleArgueFirstSeen) {
        // First bubble has fully played — unlock the door
        micheleArgueFirstSeen = true;
      }
    }
  }

  // === Secret 3: Secret Graffiti on left wall ===
  if (!showCredits && !graffitiRevealed && mouseClick && mouseX > 155 && mouseX < 200 && mouseY > 200 && mouseY < 350) {
    wallTaps++;
    if (wallTaps >= 5) {
      graffitiRevealed = true;
      playSFX('coin');
      screenFlash = 8;
      flashColor = '#ff5722';
      showQuickText("...qualcuno e' stato qui prima di te", '#ff5722');
    }
    mouseClick = false;
  }
  if (graffitiRevealed && graffitiAlpha < 0.7) {
    graffitiAlpha += 0.7 / 60; // fade in over 60 frames
    if (graffitiAlpha > 0.7) graffitiAlpha = 0.7;
  }
  if (graffitiAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = graffitiAlpha;
    ctx.translate(170, 280);
    ctx.rotate(-0.08);
    ctx.font = '14px monospace';
    ctx.fillStyle = '#ff5722';
    ctx.fillText('IL CONTE', 0, 0);
    ctx.fillText('ERA QUI', 0, 16);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Outdoor tables (round bistro style)
  // Table 1 — round top with shadow
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.ellipse(210, 380, 28, 6, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.globalAlpha = 1;
  // Table leg
  drawRect(207, 379, 6, 28, '#5d4037');
  drawRect(200, 405, 20, 3, '#4e342e');
  // Table top (round)
  ctx.beginPath();
  ctx.ellipse(210, 375, 27, 5, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#6d5040';
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(210, 374, 25, 4, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#7d6050';
  ctx.fill();
  // Chairs
  drawRect(178, 385, 6, 18, '#5d4037');
  drawRect(176, 383, 10, 3, '#5d4037');
  drawRect(176, 372, 10, 12, '#5d4037');
  drawRect(232, 385, 6, 18, '#5d4037');
  drawRect(230, 383, 10, 3, '#5d4037');
  drawRect(230, 372, 10, 12, '#5d4037');
  // Coffee cup on table (small espresso cup)
  drawRect(199, 370, 7, 5, '#f5f5f5');
  drawRect(200, 371, 5, 3, '#e0e0e0');
  drawRect(196, 372, 3, 2, '#e0e0e0'); // handle
  // Saucer
  drawRect(197, 375, 10, 1, '#e0e0e0');
  // Steam
  ctx.globalAlpha = 0.06 + Math.sin(gameTime * 0.06) * 0.03;
  ctx.beginPath();
  ctx.arc(203, 367 - Math.sin(gameTime * 0.04) * 2, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#ccc';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Table 2 — same bistro style
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.ellipse(622, 385, 28, 6, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.globalAlpha = 1;
  drawRect(619, 384, 6, 24, '#5d4037');
  drawRect(612, 406, 20, 3, '#4e342e');
  ctx.beginPath();
  ctx.ellipse(622, 380, 27, 5, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#6d5040';
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(622, 379, 25, 4, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#7d6050';
  ctx.fill();
  // Chairs
  drawRect(593, 390, 6, 16, '#5d4037');
  drawRect(591, 388, 10, 3, '#5d4037');
  drawRect(591, 377, 10, 12, '#5d4037');
  drawRect(647, 390, 6, 16, '#5d4037');
  drawRect(645, 388, 10, 3, '#5d4037');
  drawRect(645, 377, 10, 12, '#5d4037');
  // Amaro glass on table (amber colored)
  if (!drinkTaken) {
    drawRect(614, 374, 8, 7, 'rgba(255,143,0,0.5)');
    drawRect(615, 375, 6, 5, '#ff8f00');
    drawRect(614, 374, 8, 1, '#ffc107');
  }
  // Ashtray
  drawRect(630, 376, 10, 3, '#757575');
  drawRect(631, 377, 8, 1, '#9e9e9e');

  // === Secret 4: Bartender Drink ===
  if (!showCredits && !drinkTaken && mouseClick && mouseX > 560 && mouseX < 660 && mouseY > 365 && mouseY < 395) {
    drinkTaken = true;
    drinkWobble = 180;
    drinkBuff = 1;
    playSFX('coin');
    spawnParticles(622, 380, '#795548', 8, 3);
    showQuickText('*gulp* ...CHE BOTTA!! +10% DMG', '#ff8f00');
    mouseClick = false;
  }
  if (drinkWobble > 0) drinkWobble--;

  // Street lamp (near Vanni) — ornate Roman style
  // Pole
  drawRect(120, 210, 4, 200, '#4a4a4a');
  drawRect(119, 404, 6, 6, '#555'); // base
  drawRect(116, 408, 12, 3, '#4a4a4a');
  // Curved arm
  drawRect(112, 196, 20, 4, '#4a4a4a');
  // Lantern housing
  drawRect(114, 186, 16, 14, '#555');
  drawRect(116, 188, 12, 10, '#666');
  drawRect(113, 185, 18, 2, '#4a4a4a');
  drawRect(113, 200, 18, 2, '#4a4a4a');
  // Lamp flicker after being punched
  if (lampFlicker > 0) lampFlicker--;
  const lampPulse = lampFlicker > 0
    ? (0.2 + Math.random() * 0.5)
    : (0.5 + Math.sin(gameTime * 0.015) * 0.15 + Math.sin(gameTime * 0.037) * 0.08);
  // Outer soft glow
  const grad1 = ctx.createRadialGradient(122, 192, 0, 122, 192, 60);
  grad1.addColorStop(0, 'rgba(255,200,120,' + (lampPulse * 0.35).toFixed(2) + ')');
  grad1.addColorStop(0.5, 'rgba(255,180,90,' + (lampPulse * 0.12).toFixed(2) + ')');
  grad1.addColorStop(1, 'rgba(255,160,60,0)');
  ctx.fillStyle = grad1;
  ctx.beginPath();
  ctx.arc(122, 192, 60, 0, Math.PI * 2);
  ctx.fill();
  // Inner bright core
  ctx.globalAlpha = lampPulse;
  ctx.fillStyle = '#ffe0a0';
  ctx.beginPath();
  ctx.arc(122, 192, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  // Secret 1: Punch the lamp (once per run)
  if (!showCredits && !lampHit && mouseClick && mouseX > 100 && mouseX < 145 && mouseY > 180 && mouseY < 210) {
    lampHit = true;
    lampFlicker = 60;
    const lampCoins = 5 + Math.floor(Math.random() * 11);
    coins += lampCoins;
    playSFX('hit');
    screenShake = 4;
    spawnParticles(122, 192, '#ffd700', 12, 5);
    showQuickText('CLANG! +' + lampCoins + ' coins!', '#ffd700');
    mouseClick = false;
  }

  // Street lamp 2 — matching ornate style
  drawRect(720, 230, 4, 180, '#4a4a4a');
  drawRect(719, 404, 6, 6, '#555');
  drawRect(716, 408, 12, 3, '#4a4a4a');
  drawRect(712, 216, 20, 4, '#4a4a4a');
  drawRect(714, 206, 16, 14, '#555');
  drawRect(716, 208, 12, 10, '#666');
  drawRect(713, 205, 18, 2, '#4a4a4a');
  drawRect(713, 220, 18, 2, '#4a4a4a');
  const lamp2Pulse = 0.25 + Math.sin(gameTime * 0.03 + 2) * 0.1;
  const grad2 = ctx.createRadialGradient(722, 212, 0, 722, 212, 40);
  grad2.addColorStop(0, 'rgba(255,200,120,' + (lamp2Pulse * 0.35).toFixed(2) + ')');
  grad2.addColorStop(0.5, 'rgba(255,180,90,' + (lamp2Pulse * 0.1).toFixed(2) + ')');
  grad2.addColorStop(1, 'rgba(255,160,60,0)');
  ctx.fillStyle = grad2;
  ctx.beginPath();
  ctx.arc(722, 212, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = lamp2Pulse;
  ctx.fillStyle = '#ffe0a0';
  ctx.beginPath();
  ctx.arc(722, 212, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Cobblestone ground — sampietrini pattern
  const groundGrad = ctx.createLinearGradient(0, 410, 0, 550);
  groundGrad.addColorStop(0, '#342a20');
  groundGrad.addColorStop(0.3, '#2c2218');
  groundGrad.addColorStop(1, '#1e1812');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, 410, W, 140);
  // Curb edge
  drawRect(0, 410, W, 4, '#4e3d2e');
  drawRect(0, 410, W, 1, '#6d5f50');
  // Sampietrini cobblestones (3 rows, offset pattern)
  const stoneColors = ['#3d3428', '#453a2e', '#3a3024', '#4a3f32', '#352c22'];
  for (let row = 0; row < 4; row++) {
    const ry = 416 + row * 14;
    const offset = (row % 2) * 14;
    for (let i = 0; i < 35; i++) {
      const sx = i * 28 + offset;
      const ci = (i * 3 + row * 7) % 5;
      ctx.globalAlpha = 0.2;
      drawRect(sx, ry, 25, 11, stoneColors[ci]);
      // Highlight on top edge
      ctx.globalAlpha = 0.06;
      drawRect(sx + 1, ry, 23, 1, '#8d7b6a');
      ctx.globalAlpha = 1;
    }
  }

  // === Secret 2: Cicca the Cat ===
  const catY = 400;
  if (hubCatSitting > 0) {
    hubCatSitting--;
  } else if (!hubCatPetted || hubCatSitting <= 0) {
    hubCatTimer++;
    if (hubCatTimer > 120 + Math.random() * 60) {
      hubCatDir = Math.random() > 0.5 ? 1 : -1;
      hubCatTimer = 0;
    }
    hubCatX += hubCatDir * 0.4;
    if (hubCatX < 40) { hubCatX = 40; hubCatDir = 1; }
    if (hubCatX > 680) { hubCatX = 680; hubCatDir = -1; }
  }
  // Draw cat — polished pixel cat with ears, whiskers, paws, curved tail
  const tailWag = Math.sin(gameTime * 0.08) * 5;
  const cf = hubCatDir; // facing direction
  const cx = hubCatX, cy = catY;
  // Shadow
  ctx.globalAlpha = 0.2;
  ctx.beginPath();
  ctx.ellipse(cx, cy + 4, 18, 4, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.globalAlpha = 1;
  // Body (rounded)
  ctx.beginPath();
  ctx.ellipse(cx, cy - 6, 15, 8, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#ff8a65';
  ctx.fill();
  // Darker stripe on back
  ctx.beginPath();
  ctx.ellipse(cx, cy - 9, 10, 3, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#e67e5a';
  ctx.fill();
  // Head
  const hx = cx - cf * 14, hy = cy - 14;
  ctx.beginPath();
  ctx.ellipse(hx, hy, 7, 6, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#ff8a65';
  ctx.fill();
  // Ears (triangular)
  ctx.fillStyle = '#ff8a65';
  ctx.beginPath();
  ctx.moveTo(hx - 5, hy - 4); ctx.lineTo(hx - 7, hy - 11); ctx.lineTo(hx - 1, hy - 5);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(hx + 5, hy - 4); ctx.lineTo(hx + 7, hy - 11); ctx.lineTo(hx + 1, hy - 5);
  ctx.fill();
  // Inner ear (pink)
  ctx.fillStyle = '#f48fb1';
  ctx.beginPath();
  ctx.moveTo(hx - 5, hy - 5); ctx.lineTo(hx - 6, hy - 9); ctx.lineTo(hx - 2, hy - 5);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(hx + 5, hy - 5); ctx.lineTo(hx + 6, hy - 9); ctx.lineTo(hx + 2, hy - 5);
  ctx.fill();
  // Eyes
  if (hubCatSitting > 0) {
    // Happy closed eyes (curved lines)
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(hx - 3, hy - 1, 2, Math.PI, 0); ctx.stroke();
    ctx.beginPath(); ctx.arc(hx + 3, hy - 1, 2, Math.PI, 0); ctx.stroke();
    ctx.lineWidth = 1;
  } else {
    // Open eyes with pupils
    drawRect(hx - 4, hy - 2, 3, 3, '#2e7d32'); // green iris left
    drawRect(hx + 2, hy - 2, 3, 3, '#2e7d32'); // green iris right
    drawRect(hx - 3, hy - 1, 1, 2, '#111'); // pupil left (slit)
    drawRect(hx + 3, hy - 1, 1, 2, '#111'); // pupil right (slit)
    // Eye shine
    drawRect(hx - 4, hy - 2, 1, 1, 'rgba(255,255,255,0.7)');
    drawRect(hx + 2, hy - 2, 1, 1, 'rgba(255,255,255,0.7)');
  }
  // Nose (tiny pink triangle)
  ctx.fillStyle = '#f48fb1';
  ctx.beginPath();
  ctx.moveTo(hx - 1, hy + 2); ctx.lineTo(hx + 1, hy + 2); ctx.lineTo(hx, hy + 3.5);
  ctx.fill();
  // Whiskers
  ctx.strokeStyle = 'rgba(200,200,200,0.5)';
  ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(hx - 3, hy + 2); ctx.lineTo(hx - 11, hy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(hx - 3, hy + 3); ctx.lineTo(hx - 11, hy + 4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(hx + 3, hy + 2); ctx.lineTo(hx + 11, hy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(hx + 3, hy + 3); ctx.lineTo(hx + 11, hy + 4); ctx.stroke();
  ctx.lineWidth = 1;
  // Front paws
  drawRect(cx - cf * 8 - 3, cy + 1, 4, 3, '#ffab91');
  drawRect(cx - cf * 8 + 3, cy + 1, 4, 3, '#ffab91');
  // Back paws
  drawRect(cx + cf * 8 - 3, cy + 1, 4, 3, '#ffab91');
  drawRect(cx + cf * 8 + 3, cy + 1, 4, 3, '#ffab91');
  // Tail (curved using quadratic bezier)
  const tailBaseX = cx + cf * 14, tailBaseY = cy - 6;
  ctx.strokeStyle = '#e67e5a';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(tailBaseX, tailBaseY);
  ctx.quadraticCurveTo(tailBaseX + cf * 12, tailBaseY - 14 + tailWag, tailBaseX + cf * 8, tailBaseY - 20 + tailWag);
  ctx.stroke();
  ctx.lineWidth = 1;
  ctx.lineCap = 'butt';
  // Click to pet (once per visit)
  if (!showCredits && !hubCatPetted && mouseClick && mouseX > hubCatX - 20 && mouseX < hubCatX + 20 && mouseY > catY - 24 && mouseY < catY + 6) {
    hubCatPetted = true;
    hubCatSitting = 120;
    spawnParticles(hubCatX, catY - 12, '#ff69b4', 8, 3);
    coins += 5;
    playSFX('helper');
    showQuickText('Prrrr... +5 coins!', '#ff69b4');
    mouseClick = false;
  }

  // === BINGO DEGLI UBALDI building (right of Bar Vanni) ===
  const bingoX = 700, bingoY = 130, bingoW = 195, bingoH = 280;
  // Main building structure (dark purple/maroon)
  drawRect(bingoX, bingoY, bingoW, bingoH, '#2a1a3a');
  drawRect(bingoX, bingoY, bingoW, 4, '#4a2a5a');
  // Roof trim
  drawRect(bingoX - 4, bingoY - 4, bingoW + 8, 8, '#3d2050');
  drawRect(bingoX - 4, bingoY - 4, bingoW + 8, 2, '#7b1fa2');

  // Neon sign: "BINGO UBALDI" with pulsing glow
  const neonP = 0.6 + Math.sin(gameTime * 0.06) * 0.4;
  const signX = bingoX + bingoW/2, signY = bingoY + 28;
  // Sign backing
  drawRect(bingoX + 15, bingoY + 10, bingoW - 30, 32, '#111');
  drawRect(bingoX + 15, bingoY + 10, bingoW - 30, 2, '#7b1fa2');
  // Neon glow
  ctx.globalAlpha = neonP * 0.2;
  drawRect(bingoX + 10, bingoY + 6, bingoW - 20, 40, '#ce93d8');
  ctx.globalAlpha = 1;
  drawText('BINGO', signX, signY, '#e1bee7', 14, 'center');
  ctx.globalAlpha = neonP;
  drawText('UBALDI', signX, signY + 14, '#ce93d8', 11, 'center');
  ctx.globalAlpha = 1;

  // Windows (2 rows, dark interior with purple-ish glow)
  for (let r = 0; r < 2; r++) for (let c = 0; c < 2; c++) {
    const wx = bingoX + 18 + c * 95;
    const wy = bingoY + 55 + r * 70;
    drawRect(wx, wy, 55, 50, '#0d0a1a');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.025 + c + r * 2) * 0.1;
    drawRect(wx + 2, wy + 2, 51, 46, '#4a148c');
    ctx.globalAlpha = 1;
    // Window frame
    drawRect(wx, wy, 55, 2, '#3d2050');
    drawRect(wx + 26, wy, 2, 50, '#3d2050');
  }

  // Door — clickable entrance with warm purple light
  const doorX = bingoX + bingoW/2 - 30, doorY = bingoY + 200, doorW = 60, doorH = bingoH - 200;
  drawRect(doorX, doorY, doorW, doorH, '#1a0a2a');
  drawRect(doorX + 3, doorY + 3, doorW - 6, doorH - 3, '#120820');
  // Warm light from inside
  ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.04) * 0.1;
  ctx.fillStyle = '#9c27b0';
  ctx.beginPath();
  ctx.arc(doorX + doorW/2, doorY + 30, 30, Math.PI, 0);
  ctx.fill();
  ctx.globalAlpha = 0.15;
  ctx.fillRect(doorX + 5, doorY + 40, doorW - 10, doorH - 45);
  ctx.globalAlpha = 1;
  // Door frame
  drawRect(doorX, doorY, doorW, 3, '#7b1fa2');
  drawRect(doorX, doorY, 3, doorH, '#4a2a5a');
  drawRect(doorX + doorW - 3, doorY, 3, doorH, '#4a2a5a');

  // "ENTRA" sign above door
  drawRect(doorX - 5, doorY - 18, doorW + 10, 16, 'rgba(0,0,0,0.7)');
  const entraPulse = 0.7 + Math.sin(gameTime * 0.08) * 0.3;
  ctx.globalAlpha = entraPulse;
  drawText('[B] ENTRA', doorX + doorW/2, doorY - 6, '#e1bee7', 10, 'center');
  ctx.globalAlpha = 1;

  // Click on door to enter casino
  const doorHover = mouseX > doorX && mouseX < doorX + doorW && mouseY > doorY && mouseY < doorY + doorH;
  if (doorHover) {
    // Hover highlight on door
    ctx.globalAlpha = 0.15;
    drawRect(doorX, doorY, doorW, doorH, '#ce93d8');
    ctx.globalAlpha = 1;
  }

  // Small decorative neon strips on building sides
  ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.07) * 0.15;
  drawRect(bingoX, bingoY + 48, 2, bingoH - 48, '#7b1fa2');
  drawRect(bingoX + bingoW - 2, bingoY + 48, 2, bingoH - 48, '#7b1fa2');
  ctx.globalAlpha = 1;

  // === TOP BAR ===
  drawRect(0, 0, W, 50, 'rgba(0,0,0,0.75)');
  drawRect(0, 48, W, 2, '#4e342e');
  drawText('COINS: ' + coins, 25, 28, '#ffd700', 14);
  // Lives display in hub
  if (difficulty === 'easy') {
    drawText('\u221E', 38, 46, '#4caf50', 14, 'center');
  } else {
    for (let li = 0; li < 3; li++) {
      const alive = li < lives;
      drawRect(25 + li * 22, 34, 18, 14, alive ? '#e94560' : '#333');
      drawText(alive ? '\u2665' : '\u2661', 34 + li * 22, 46, alive ? '#fff' : '#555', 11, 'center');
    }
  }
  drawText('Base del Conte', 180, 32, '#a1887f', 13, 'center');
  // Shop button
  const shopBx = 720, shopBy = 10;
  const shopHover = mouseX > shopBx && mouseX < shopBx + 150 && mouseY > shopBy && mouseY < shopBy + 32;
  drawRect(shopBx, shopBy, 150, 32, shopHover ? '#d84315' : '#bf360c');
  drawRect(shopBx, shopBy, 150, 2, '#ff6e40');
  drawText('ARMERIA [S]', shopBx + 75, shopBy + 22, '#fff', 13, 'center');
  if (!showCredits && !hubConfirm && ((shopHover && mouseClick) || keys['KeyS'])) {
    state = 'shop';
    shopTab = 0;
    mouseClick = false;
  }

  // Casino button (top bar + door click)
  const casinoBx = 510, casinoBy = 10;
  const casinoHover = mouseX > casinoBx && mouseX < casinoBx + 195 && mouseY > casinoBy && mouseY < casinoBy + 32;
  drawRect(casinoBx, casinoBy, 195, 32, casinoHover ? '#7b1fa2' : '#6a1b9a');
  drawRect(casinoBx, casinoBy, 195, 2, '#ce93d8');
  drawText('BINGO UBALDI [B]', casinoBx + 98, casinoBy + 22, '#fff', 13, 'center');
  // Door hitbox (matches the bingo building door drawn earlier)
  const bingoDoorClick = mouseX > 700 + 195/2 - 30 && mouseX < 700 + 195/2 + 30 && mouseY > 330 && mouseY < 410;
  if (!showCredits && !hubConfirm && ((casinoHover && mouseClick) || (bingoDoorClick && mouseClick) || keysJustPressed['KeyB'])) {
    state = 'casino';
    casinoTab = 0;
    pokerPhase = 'idle';
    slotPhase = 'idle';
    if (casinoFirstVisit) {
      casinoFirstVisit = false;
      casinoDialogueActive = true;
      casinoDialogueLines = [
        'Benvenuto al BINGO DEGLI UBALDI!',
        'Qui se gioca, Conte... e se perde pure.',
        'Video Poker con Andreino... o le Slot col Panda.',
        'Sceji er tavolo e bona fortuna!'
      ];
      casinoDialogueIndex = 0;
      casinoDialogueCooldown = 15;
    }
    mouseClick = false;
  }

  // Help button
  const movesBx = 345, movesBy = 10;
  const movesHover = mouseX > movesBx && mouseX < movesBx + 155 && mouseY > movesBy && mouseY < movesBy + 32;
  drawRect(movesBx, movesBy, 155, 32, movesHover ? '#1565c0' : '#0d47a1');
  drawRect(movesBx, movesBy, 155, 2, '#42a5f5');
  drawText('AIUTO [TAB]', movesBx + 78, movesBy + 22, '#fff', 13, 'center');
  if (!showCredits && ((movesHover && mouseClick) || keysJustPressed['Tab'] || keysJustPressed['KeyP'])) {
    toggleMovesScreen();
    mouseClick = false;
  }

  // === LEVEL SELECT ===
  drawRect(30, 435, W - 60, 105, 'rgba(0,0,0,0.7)');
  drawRect(30, 435, W - 60, 2, '#e94560');
  drawText('SCEGLI BATTAGLIA', 60, 455, '#e94560', 13);

  // Input cooldown (prevents bleed-through from Michele dialogue etc.)
  if (hubInputCooldown > 0) hubInputCooldown--;

  // Keyboard navigation
  if (!showCredits && !hubConfirm && (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA'])) {
    hubSelection = Math.max(0, hubSelection - 1);
    playSFX('hit');
  }
  if (!showCredits && !hubConfirm && (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD'])) {
    hubSelection = Math.min(levels.length - 1, hubSelection + 1);
    playSFX('hit');
  }
  // Number keys to jump to level
  if (!showCredits && !hubConfirm) {
  for (let n = 0; n < levels.length; n++) {
    if (keysJustPressed['Digit' + (n+1)]) {
      hubSelection = n;
      playSFX('hit');
    }
  }
  }
  // Enter to open confirmation (not start level directly)
  if (!showCredits && !hubConfirm && hubInputCooldown <= 0 && (keysJustPressed['Enter'] || keysJustPressed['Space'])) {
    const selLocked = hubSelection > 0 && !bossDefeated[hubSelection - 1];
    if (!selLocked) {
      hubConfirm = true;
      hubInputCooldown = 12;
      mouseClick = false;
    } else {
      playSFX('hurt');
    }
  }

  for (let i = 0; i < levels.length; i++) {
    const bx = 50 + i * 168;
    const by = 462;
    const locked = i > 0 && !bossDefeated[i - 1];
    const beaten = bossDefeated[i];
    const isHover = mouseX > bx && mouseX < bx + 158 && mouseY > by && mouseY < by + 68;
    const isSelected = i === hubSelection;

    // Mouse hover updates selection
    if (!hubConfirm && isHover && (mouseX !== 0 || mouseY !== 0)) hubSelection = i;

    const bgColor = beaten ? '#1b5e20' : locked ? '#333' : (isSelected || isHover) ? '#b71c1c' : '#4a1a1a';
    drawRect(bx, by, 158, 68, bgColor);
    drawRect(bx, by, 158, 2, beaten ? '#4caf50' : locked ? '#555' : '#e94560');

    // Selection highlight border (animated pulse)
    if (isSelected && !locked) {
      const pulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 2 + pulse;
      ctx.strokeRect(bx - 2, by - 2, 162, 72);
      ctx.lineWidth = 1;
    }

    drawText((i+1) + '.', bx + 8, by + 20, beaten ? '#66bb6a' : locked ? '#555' : '#e94560', 11);

    if (locked) {
      drawText('???', bx + 80, by + 20, '#555', 14, 'center');
      drawText('???', bx + 80, by + 38, '#444', 9, 'center');
      ctx.globalAlpha = 0.7;
      drawRect(bx, by, 158, 68, 'rgba(0,0,0,0.5)');
      ctx.globalAlpha = 1;
      drawText('LOCKED', bx + 80, by + 55, '#777', 10, 'center');
    } else if (beaten) {
      drawText(levels[i].boss, bx + 80, by + 20, '#a5d6a7', 13, 'center');
      drawText(levels[i].name, bx + 80, by + 38, '#81c784', 9, 'center');
      drawText('SCONFITTO', bx + 80, by + 55, '#4caf50', 9, 'center');
    } else {
      drawText(levels[i].boss, bx + 80, by + 20, '#fff', 13, 'center');
      drawText(levels[i].name, bx + 80, by + 38, '#ffcdd2', 9, 'center');
      drawText(isSelected ? '[ ENTER ]' : '', bx + 80, by + 55, '#fff', 9, 'center');
    }

    // Click opens confirmation, not instant start
    if (!hubConfirm && isHover && mouseClick && !locked) {
      hubSelection = i;
      hubConfirm = true;
      hubInputCooldown = 12;
      mouseClick = false;
    }
  }

  // === Level confirmation box ===
  if (hubConfirm) {
    const lv = levels[hubSelection];
    const beaten = bossDefeated[hubSelection];
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    const cW = 440, cH = 140;
    const cx = W/2 - cW/2, cy = H/2 - cH/2 - 20;
    drawRect(cx + 3, cy + 3, cW, cH, 'rgba(0,0,0,0.3)');
    drawRect(cx, cy, cW, cH, 'rgba(20,16,12,0.97)');
    drawRect(cx, cy, cW, 3, lv.bossColor);
    ctx.strokeStyle = '#4a3828';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(cx, cy, cW, cH);
    ctx.lineWidth = 1;
    // Boss name + subtitle
    drawText(lv.boss, W/2, cy + 30, lv.bossColor, 20, 'center');
    drawText(lv.subtitle, W/2, cy + 52, '#aaa', 12, 'center');
    drawText(beaten ? 'Rivuoi la rivincita?' : 'Sei pronto a sfidare ' + lv.boss + '?', W/2, cy + 78, '#e0e0e0', 13, 'center');
    // Buttons
    const btnW = 130, btnH = 32;
    const yesX = W/2 - btnW - 15, noX = W/2 + 15, btnY = cy + 96;
    const yesHover = mouseX > yesX && mouseX < yesX + btnW && mouseY > btnY && mouseY < btnY + btnH;
    const noHover = mouseX > noX && mouseX < noX + btnW && mouseY > btnY && mouseY < btnY + btnH;
    drawRect(yesX, btnY, btnW, btnH, yesHover ? '#b71c1c' : '#4a1a1a');
    drawRect(yesX, btnY, btnW, 2, '#e94560');
    drawText('COMBATTI!', yesX + btnW/2, btnY + 22, yesHover ? '#fff' : '#e94560', 14, 'center');
    drawRect(noX, btnY, btnW, btnH, noHover ? '#3a3028' : '#2a2018');
    drawRect(noX, btnY, btnW, 2, '#5d4037');
    drawText('ANNULLA', noX + btnW/2, btnY + 22, noHover ? '#fff' : '#888', 13, 'center');
    if (hubInputCooldown <= 0) {
      if ((yesHover && mouseClick) || keysJustPressed['Enter'] || keysJustPressed['Space']) {
        currentLevel = hubSelection;
        startLevel(hubSelection);
        hubConfirm = false;
        mouseClick = false;
        return;
      }
      if ((noHover && mouseClick) || keysJustPressed['Escape']) {
        hubConfirm = false;
        mouseClick = false;
      }
    }
  }

  // Small "Crediti" button bottom-right corner
  const credBtnX = W - 75, credBtnY = H - 24, credBtnW = 65, credBtnH = 18;
  const hoverCred = mouseX >= credBtnX && mouseX <= credBtnX + credBtnW && mouseY >= credBtnY && mouseY <= credBtnY + credBtnH;
  drawRect(credBtnX, credBtnY, credBtnW, credBtnH, hoverCred ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)');
  drawText('Crediti', credBtnX + 33, credBtnY + 14, hoverCred ? '#aaa' : '#555', 10, 'center');
  if (mouseClick && hoverCred) {
    showCredits = true;
    codeInput = '';
    mouseClick = false;
  }

  // === Credits overlay with code entry ===
  if (showCredits) {
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.85)');
    const panelX = W/2 - 230, panelY = isTouchDevice ? 20 : 75, panelW = 460, panelH = isTouchDevice ? 520 : 400;
    drawRect(panelX, panelY, panelW, panelH, 'rgba(20,20,40,0.95)');
    drawRect(panelX, panelY, panelW, 2, '#e94560');
    drawRect(panelX, panelY + panelH - 2, panelW, 2, '#e94560');

    const tOff = isTouchDevice ? -50 : 0;
    drawText('- CREDITI -', W/2, 110 + tOff, '#e94560', 25, 'center');
    drawText('LA GUERRA DI VALLE AURELIA', W/2, 140 + tOff, '#ffd700', 16, 'center');
    drawText('Un gioco da conti...anzi, del Conte!', W/2, 163 + tOff, '#ccc', 13, 'center');
    drawText('Ambientato a Prati, Roma', W/2, 184 + tOff, '#aaa', 13, 'center');
    drawText('Sviluppatore: Cicca', W/2, 210 + tOff, '#aaa', 13, 'center');
    drawText('Programmazione: Cicca + Claude', W/2, 232 + tOff, '#aaa', 13, 'center');
    drawText('Idea & Design: Cicca', W/2, 254 + tOff, '#aaa', 13, 'center');
    drawText('Grazie per aver giocato!', W/2, 280 + tOff, '#ffcc80', 14, 'center');

    // Code entry box
    const codeY = isTouchDevice ? 290 : 340;
    drawRect(W/2 - 105, codeY, 210, 32, 'rgba(255,255,255,0.08)');
    drawRect(W/2 - 105, codeY, 210, 1, '#555');
    drawRect(W/2 - 105, codeY + 31, 210, 1, '#555');
    const cursor = Math.floor(gameTime / 30) % 2 === 0 ? '_' : '';
    const displayCode = codeInput + cursor;
    drawText(displayCode || 'Inserisci codice...', W/2, codeY + 22, codeInput ? '#fff' : '#555', 14, 'center');

    // On-screen keyboard for mobile
    drawCreditsKeyboard(codeY + 40);

    // Close button
    const closeBtnY2 = isTouchDevice ? codeY + 165 : 400;
    const closeBtnX = W/2 - 46, closeBtnW = 92, closeBtnH = 28;
    const hoverClose = mouseX >= closeBtnX && mouseX <= closeBtnX + closeBtnW && mouseY >= closeBtnY2 && mouseY <= closeBtnY2 + closeBtnH;
    drawRect(closeBtnX, closeBtnY2, closeBtnW, closeBtnH, hoverClose ? '#e94560' : 'rgba(233,69,96,0.4)');
    drawText('Chiudi', W/2, closeBtnY2 + 19, '#fff', 13, 'center');
    if (mouseClick && hoverClose) {
      showCredits = false;
      codeInput = '';
      mouseClick = false;
    }
    if (keysJustPressed['Escape']) {
      showCredits = false;
      codeInput = '';
    }

    // Handle keyboard input for code entry
    const letterKeys = ['KeyA','KeyB','KeyC','KeyD','KeyE','KeyF','KeyG','KeyH','KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP','KeyQ','KeyR','KeyS','KeyT','KeyU','KeyV','KeyW','KeyX','KeyY','KeyZ'];
    letterKeys.forEach(k => {
      if (keysJustPressed[k]) {
        if (codeInput.length < 12) codeInput += k.charAt(3);
      }
    });
    if (keysJustPressed['Backspace']) codeInput = codeInput.slice(0, -1);

    // Check for CONTE code
    if (codeInput === 'CONTE') {
      showCredits = false;
      codeInput = '';
      coins = 9999;
      bossDefeated = [true, true, true, true, true];
      player.maxHp = 999;
      player.hp = 999;
      player.maxStamina = 999;
      player.stamina = 999;
      player.invincible = 999999;
      player.speed = 6;
      UPGRADE_POOL.forEach(u => { if (!player.upgrades.some(e => e.effect === u.effect)) player.upgrades.push(u); });
      helpers.forEach(h => { h.tier = 3; h.unlocked = true; });
      screenFlash = 20;
      flashColor = '#ffd700';
      showQuickText('CONTE MODE ACTIVATED! SEI INVINCIBILE!', '#ffd700');
      playSFX('victory_jingle');
      spawnParticles(W/2, H/2, '#ffd700', 40, 10);
    }

    // Check for SABI code
    if (codeInput === 'SABI') {
      showCredits = false;
      codeInput = '';
      sabiTimer = 0;
      sabiCicca = { x: 200, y: GROUND_Y, vx: 0, facing: 1, animTimer: 0 };
      sabiSabi = { x: 450, y: GROUND_Y, animTimer: 0, petting: false };
      sabiTotti = { x: 650, y: GROUND_Y, animTimer: 0, wagging: true, fetching: false };
      sabiMessages = [];
      sabiPreviousState = state;
      state = 'sabi';
      screenFlash = 15;
      flashColor = '#ff69b4';
      playSFX('coin');
    }

    // Check for LUDO code
    if (codeInput === 'LUDO') {
      showCredits = false;
      codeInput = '';
      coins += 100;
      screenFlash = 15;
      flashColor = '#ffd700';
      showQuickText('+100 COINS! Grazie Ludo!', '#ffd700');
      playSFX('coin');
      spawnParticles(W/2, H/2, '#ffd700', 20, 5);
    }

    // Check for FREESTYLE code
    if (codeInput === 'FREE') {
      showCredits = false;
      codeInput = '';
      startFreestyleVideo();
    }

    // Check for YO code (sunglasses toggle)
    if (codeInput === 'YO') {
      hasSunglasses = !hasSunglasses;
      codeInput = '';
      screenFlash = 10; flashColor = '#333';
      showQuickText(hasSunglasses ? 'STYLE ON!' : 'Occhiali rimossi.', '#333');
      playSFX('perfect_dodge');
    }

    mouseClick = false;
    return; // Block hub interaction while credits open
  }

  // Show cheat active indicator
  if (player.maxHp >= 999) {
    drawText('CONTE MODE', W/2, 105, '#ffd700', 11, 'center');
  }

  // Check all beaten
  if (bossDefeated.every(b => b) && player.maxHp < 999) {
    victoryTimer = 0;
    state = 'victory';
  }

  mouseClick = false;
}

// ==========================================
// BACKROOM — Michele Lo Sbirro
// ==========================================
function drawBackroom() {
  if (backroomCooldown > 0) backroomCooldown--;

  // Dark smoky backroom background
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, '#1a1410');
  bgGrad.addColorStop(0.5, '#1c1612');
  bgGrad.addColorStop(1, '#120e0a');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  // Brick wall texture
  for (let by = 0; by < 8; by++) {
    for (let bx = 0; bx < 16; bx++) {
      ctx.globalAlpha = 0.06;
      const ox = (by % 2) * 30;
      drawRect(bx * 60 + ox, by * 35 + 20, 56, 31, '#4e3328');
      ctx.globalAlpha = 1;
    }
  }

  // Floor
  drawRect(0, 400, W, 150, '#1a1510');
  drawRect(0, 400, W, 2, '#2c2218');

  // Dim ceiling bulb
  const bulbPulse = 0.5 + Math.sin(gameTime * 0.03) * 0.08;
  drawRect(348, 20, 4, 50, '#333');
  ctx.beginPath();
  ctx.arc(350, 75, 8, 0, Math.PI * 2);
  ctx.fillStyle = '#ffcc80';
  ctx.globalAlpha = bulbPulse;
  ctx.fill();
  const bulbGlow = ctx.createRadialGradient(350, 75, 0, 350, 75, 120);
  bulbGlow.addColorStop(0, 'rgba(255,200,120,' + (bulbPulse * 0.25).toFixed(2) + ')');
  bulbGlow.addColorStop(1, 'rgba(255,180,100,0)');
  ctx.fillStyle = bulbGlow;
  ctx.beginPath();
  ctx.arc(350, 75, 120, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Table with two chairs
  drawRect(250, 340, 180, 8, '#3e2723');
  drawRect(290, 348, 8, 55, '#2c1e14');
  drawRect(390, 348, 8, 55, '#2c1e14');
  // Chair left
  drawRect(210, 330, 30, 6, '#4e342e');
  drawRect(215, 336, 6, 45, '#3e2723');
  drawRect(235, 336, 6, 45, '#3e2723');
  drawRect(210, 310, 6, 26, '#4e342e');
  // Chair right (empty, for the Conte)
  drawRect(440, 330, 30, 6, '#4e342e');
  drawRect(445, 336, 6, 45, '#3e2723');
  drawRect(465, 336, 6, 45, '#3e2723');

  // Bottles on shelf behind
  drawRect(580, 180, 140, 6, '#3e2723');
  drawRect(578, 182, 4, 30, '#2c1e14');
  drawRect(718, 182, 4, 30, '#2c1e14');
  for (let b = 0; b < 5; b++) {
    const bCol = ['#4a148c', '#1b5e20', '#b71c1c', '#e65100', '#004d40'][b];
    drawRect(590 + b * 26, 158, 10, 22, bCol);
    drawRect(593 + b * 26, 152, 4, 8, bCol);
  }

  // Smoke wisps
  for (let s = 0; s < 3; s++) {
    ctx.globalAlpha = 0.04 + Math.sin(gameTime * 0.01 + s * 2) * 0.02;
    ctx.beginPath();
    ctx.arc(200 + s * 250 + Math.sin(gameTime * 0.008 + s) * 30, 150 + s * 40, 60 + s * 20, 0, Math.PI * 2);
    ctx.fillStyle = '#9e9e9e';
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Michele Lo Sbirro (right side of room)
  const mx = 620, my = 240;
  drawPixelChar(mx, my, 40, 60, '#1a237e', '#d7ccc8', (x, y, w, h) => {
    // Police cap
    drawRect(x + 2, y - 8, w - 4, 6, '#1a237e');
    drawRect(x - 2, y - 3, w + 4, 4, '#1a237e');
    drawRect(x + w/2 - 4, y - 10, 8, 4, '#263238');
    // Cap badge
    drawRect(x + w/2 - 3, y - 9, 6, 3, '#ffd700');
    // Badge on chest
    drawRect(x + 6, y + 24, 8, 8, '#ffd700');
    drawRect(x + 8, y + 26, 4, 4, '#fff');
    // Blue uniform details
    drawRect(x + w/2 - 1, y + 20, 2, h - 36, '#0d47a1');
    // Arms in blue
    drawRect(x - 3, y + 22, 6, 18, '#1a237e');
    drawRect(x + w - 3, y + 22, 6, 18, '#1a237e');
    // Legs dark
    drawRect(x + 6, y + h - 16, 8, 16, '#0d1b3e');
    drawRect(x + w - 14, y + h - 16, 8, 16, '#0d1b3e');
    // Smirk
    drawRect(x + 10, y + 15, 8, 2, '#8d6e63');
  });

  // "MICHELE LO SBIRRO" name label
  ctx.globalAlpha = 0.7;
  drawText('MICHELE LO SBIRRO', mx + 20, my - 16, '#78909c', 10, 'center');
  ctx.globalAlpha = 1;

  // Dialogue lines
  const micheleLines = [
    "Ehi, Conte... vieni, siediti.",
    "Io sono Michele. Lo Sbirro, mi chiamano.",
    "Sai qual e' il segreto della vita?",
    "Vivere. VIVERE, Conte. Ogni giorno come fosse l'ultimo.",
    "Io per esempio... lavoro? Boh. Forse si, forse no.",
    "La ragazza? Cambio ogni settimana. La vita e' breve!",
    "Allora dimmi..."
  ];
  const tmaxLines = [
    "TMAX! Ecco uno che capisce!",
    "Tieni, questo e' per te. Il mio Manganello.",
    "Usalo bene... o male, a me non interessa.",
    "Spero che vieni con me qualche volta...",
    "Sembri uno che sa come godersi la vita!"
  ];
  const scarabeoLines = [
    "Scarabeo?! Ma che, sei serio?",
    "Vabbe'... scelta sbagliata, Conte.",
    "Ora ti saluto, devo andare a jiu jitsu...",
    "...o forse surf... o snowboard...",
    "Insomma, ho da fare cose importanti!"
  ];

  // Dialogue box
  drawRect(60, 430, W - 120, 80, 'rgba(0,0,0,0.85)');
  drawRect(60, 430, W - 120, 2, '#78909c');

  if (backroomPhase === 0) {
    // Monologue
    const line = micheleLines[backroomLine] || micheleLines[micheleLines.length - 1];
    drawText('"' + line + '"', W/2, 470, '#e0e0e0', 14, 'center');
    const hint = backroomLine < micheleLines.length - 1 ? '[Click / Enter]' : '[Click / Enter]';
    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.08) * 0.3;
    drawText(hint, W/2, 498, '#78909c', 10, 'center');
    ctx.globalAlpha = 1;

    if (backroomCooldown <= 0 && (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space'])) {
      backroomLine++;
      backroomCooldown = 10;
      playSFX('hit');
      if (backroomLine >= micheleLines.length) {
        backroomPhase = 1;
        backroomChoice = -1;
        backroomCooldown = 15;
      }
      mouseClick = false;
    }
  } else if (backroomPhase === 1) {
    // Choice: Scarabeo or TMAX
    drawText('"Scarabeo... o TMAX?"', W/2, 455, '#e0e0e0', 14, 'center');

    const btnW = 160, btnH = 36;
    const btn1X = W/2 - btnW - 20, btn2X = W/2 + 20, btnY = 468;

    // Keyboard selection
    if (backroomCooldown <= 0) {
      if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) { backroomChoice = 0; playSFX('hit'); }
      if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) { backroomChoice = 1; playSFX('hit'); }
    }

    const hover1 = mouseX > btn1X && mouseX < btn1X + btnW && mouseY > btnY && mouseY < btnY + btnH;
    const hover2 = mouseX > btn2X && mouseX < btn2X + btnW && mouseY > btnY && mouseY < btnY + btnH;
    if (hover1) backroomChoice = 0;
    if (hover2) backroomChoice = 1;

    drawRect(btn1X, btnY, btnW, btnH, backroomChoice === 0 ? '#4e342e' : '#2c1e14');
    drawRect(btn1X, btnY, btnW, 2, backroomChoice === 0 ? '#ff8f00' : '#5d4037');
    drawText('SCARABEO', btn1X + btnW/2, btnY + 24, backroomChoice === 0 ? '#ff8f00' : '#8d6e63', 14, 'center');

    drawRect(btn2X, btnY, btnW, btnH, backroomChoice === 1 ? '#1a237e' : '#0d1b3e');
    drawRect(btn2X, btnY, btnW, 2, backroomChoice === 1 ? '#42a5f5' : '#263238');
    drawText('TMAX', btn2X + btnW/2, btnY + 24, backroomChoice === 1 ? '#42a5f5' : '#546e7a', 14, 'center');

    if (backroomCooldown <= 0 && backroomChoice >= 0 && (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space'])) {
      backroomPhase = 2;
      backroomLine = 0;
      backroomCooldown = 15;
      if (backroomChoice === 1) {
        // TMAX chosen — award Manganello (player chooses whether to equip)
        playSFX('victory_sweep');
        screenFlash = 15;
        flashColor = '#263238';
        spawnParticles(mx + 20, my + 30, '#ffd700', 20, 5);
      }
      mouseClick = false;
    }
  } else if (backroomPhase === 2) {
    // Response lines
    const lines = backroomChoice === 1 ? tmaxLines : scarabeoLines;
    const line = lines[backroomLine] || lines[lines.length - 1];
    drawText('"' + line + '"', W/2, 470, backroomChoice === 1 ? '#42a5f5' : '#ff8f00', 14, 'center');

    // Show equip prompt after showing the weapon award line (TMAX line index 1)
    if (backroomChoice === 1 && backroomLine === 1) {
      drawRect(W/2 - 120, 410, 240, 20, 'rgba(38,50,56,0.9)');
      drawText('Ricevuto: Manganello!', W/2, 424, '#ffd700', 11, 'center');
    }

    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.08) * 0.3;
    drawText('[Click / Enter]', W/2, 498, '#78909c', 10, 'center');
    ctx.globalAlpha = 1;

    if (backroomCooldown <= 0 && (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space'])) {
      backroomLine++;
      backroomCooldown = 10;
      playSFX('hit');
      if (backroomLine >= lines.length) {
        if (backroomChoice === 1) {
          // Move to equip choice phase
          backroomPhase = 4;
          backroomCooldown = 15;
          backroomChoice = -1;
        } else {
          backroomPhase = 3;
        }
      }
      mouseClick = false;
    }
  } else if (backroomPhase === 4) {
    // Equip choice for Manganello
    drawText('Vuoi equipaggiare il Manganello?', W/2, 455, '#e0e0e0', 14, 'center');

    const btnW = 120, btnH = 36;
    const btn1X = W/2 - btnW - 20, btn2X = W/2 + 20, btnY = 468;

    if (backroomCooldown <= 0) {
      if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) { backroomChoice = 0; playSFX('hit'); }
      if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) { backroomChoice = 1; playSFX('hit'); }
    }

    const hover1 = mouseX > btn1X && mouseX < btn1X + btnW && mouseY > btnY && mouseY < btnY + btnH;
    const hover2 = mouseX > btn2X && mouseX < btn2X + btnW && mouseY > btnY && mouseY < btnY + btnH;
    if (hover1) backroomChoice = 0;
    if (hover2) backroomChoice = 1;

    drawRect(btn1X, btnY, btnW, btnH, backroomChoice === 0 ? '#1b5e20' : '#1a2e1a');
    drawRect(btn1X, btnY, btnW, 2, backroomChoice === 0 ? '#66bb6a' : '#2e7d32');
    drawText('SI', btn1X + btnW/2, btnY + 24, backroomChoice === 0 ? '#66bb6a' : '#4caf50', 14, 'center');

    drawRect(btn2X, btnY, btnW, btnH, backroomChoice === 1 ? '#4e342e' : '#2c1e14');
    drawRect(btn2X, btnY, btnW, 2, backroomChoice === 1 ? '#ff8f00' : '#5d4037');
    drawText('NO', btn2X + btnW/2, btnY + 24, backroomChoice === 1 ? '#ff8f00' : '#8d6e63', 14, 'center');

    if (backroomCooldown <= 0 && backroomChoice >= 0 && (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space'])) {
      if (backroomChoice === 0) {
        // Equip Manganello
        weapons = [manganelloWeapon];
        weaponTier = 0;
        screenFlash = 10;
        flashColor = '#263238';
        spawnParticles(450, 300, '#ffd700', 15, 4);
        showQuickText('Manganello equipaggiato!', '#42a5f5');
      } else {
        showQuickText('Manganello conservato. Magari un\'altra volta.', '#78909c');
      }
      backroomPhase = 3;
      mouseClick = false;
    }
  }

  if (backroomPhase === 3) {
    micheleVisited = true;
    state = 'hub';
    hubVisitInited = false;
  }

  // ESC to exit at any time
  if (keysJustPressed['Escape']) {
    micheleVisited = true;
    state = 'hub';
    hubVisitInited = false;
    mouseClick = false;
  }

  mouseClick = false;
}

// ==========================================
// SHOP — 3 tabs: Potenzia Arma, Potenzia Helper, La Ruota (gacha)
// ==========================================
let shopScroll = 0;
let meleComment = '';
let meleCommentTimer = 0;
let shopJustEntered = false;
let shopPrevTab = -1;

function drawShop() {
  // Welcome trigger on entry
  if (!shopJustEntered) {
    shopJustEntered = true;
    shopPrevTab = shopTab;
    meleComment = getMeleComment('welcome');
    meleCommentTimer = 240;
  }
  // Idle comment trigger
  if (meleCommentTimer <= 0 && gameTime % 360 === 0) {
    meleComment = getMeleComment('idle');
    meleCommentTimer = 180;
  }
  // Warm interior background — inside Bar Vanni
  const shopBg = ctx.createLinearGradient(0, 0, 0, H);
  shopBg.addColorStop(0, '#2a2018');
  shopBg.addColorStop(0.5, '#241c14');
  shopBg.addColorStop(1, '#1a1510');
  ctx.fillStyle = shopBg;
  ctx.fillRect(0, 0, W, H);

  // Subtle warm wall texture
  for (let wy = 0; wy < 8; wy++) for (let wx = 0; wx < 12; wx++) {
    ctx.globalAlpha = 0.02 + ((wx * 5 + wy * 9) % 4) * 0.005;
    drawRect(wx * 78, wy * 70, 74, 66, (wx + wy) % 2 === 0 ? '#3a2e22' : '#2a2018');
  }
  ctx.globalAlpha = 1;

  // Warm ceiling light glow
  const shopGlow = ctx.createRadialGradient(W/2, 0, 20, W/2, 0, 350);
  shopGlow.addColorStop(0, 'rgba(255,200,120,0.08)');
  shopGlow.addColorStop(0.5, 'rgba(255,180,100,0.03)');
  shopGlow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = shopGlow;
  ctx.fillRect(0, 0, W, H);

  // Bar counter top strip (wooden bar feel)
  drawRect(0, 120, W, 6, '#4a3828');
  drawRect(0, 120, W, 1, '#6a5840');

  // Draw Mele (left, behind counter)
  drawMele(12, 30);
  // Draw Giammy (right, behind counter)
  drawGiammy(818, 24);

  // Title
  drawText('ARMERIA DI GIAMMY E MELE', W/2, 50, '#ffd54f', 18, 'center');
  ctx.globalAlpha = 0.06;
  drawText('ARMERIA DI GIAMMY E MELE', W/2, 50, '#fff', 19, 'center');
  ctx.globalAlpha = 1;
  drawText('COINS: ' + coins, W/2, 74, '#ffd700', 14, 'center');

  // === TAB BUTTONS ===
  const tabNames = ['ARMA', 'HELPER', 'LA RUOTA', 'STATS'];
  const tabColors = ['#ff8a65', '#e040fb', '#ffd700', '#4caf50'];
  const tabW = 205, tabH = 28, tabY = 128;
  for (let t = 0; t < 4; t++) {
    const tx = 18 + t * (tabW + 8);
    const active = shopTab === t;
    const hover = mouseX > tx && mouseX < tx + tabW && mouseY > tabY && mouseY < tabY + tabH;
    drawRect(tx, tabY, tabW, tabH, active ? tabColors[t] : hover ? '#3a3028' : '#2a2218');
    drawRect(tx, tabY + tabH - 2, tabW, 2, active ? tabColors[t] : '#3a3028');
    drawText(tabNames[t], tx + tabW/2, tabY + 20, active ? '#000' : '#999', 13, 'center');
    if (hover && mouseClick) {
      shopTab = t;
      mouseClick = false;
    }
  }
  // Tab keys
  if (keysJustPressed['Digit1']) shopTab = 0;
  if (keysJustPressed['Digit2']) shopTab = 1;
  if (keysJustPressed['Digit3']) shopTab = 2;
  if (keysJustPressed['Digit4']) shopTab = 3;
  // Mele comment on tab switch
  if (shopTab !== shopPrevTab) {
    meleComment = getMeleComment(shopTab === 2 ? 'gacha' : 'tab');
    meleCommentTimer = 150;
    shopPrevTab = shopTab;
  }

  const panelY = 160;

  if (shopTab === 0) drawShopWeapon(panelY);
  else if (shopTab === 1) drawShopHelper(panelY);
  else if (shopTab === 2) drawShopGacha(panelY);
  else drawShopStats(panelY);

  // Back button
  const backHover = mouseX > 30 && mouseX < 150 && mouseY > H - 38 && mouseY < H - 10;
  drawRect(30, H - 38, 120, 28, backHover ? '#5a4433' : '#3a2e22');
  drawRect(30, H - 38, 120, 2, backHover ? '#8a7460' : '#4a3828');
  drawText('INDIETRO [ESC]', 90, H - 20, backHover ? '#ffd54f' : '#aaa', 11, 'center');
  if ((backHover && mouseClick) || keys['Escape']) {
    state = 'hub';
    shopJustEntered = false;
    meleComment = '';
    meleCommentTimer = 0;
    mouseClick = false;
  }

  // Mele speech caption — compact inline, right of Mele in the header
  if (meleCommentTimer > 0) {
    meleCommentTimer--;
    const capX = 58; // just right of Mele
    const capY = 65; // vertically centered in header
    const capMaxW = 240;
    ctx.font = '10px monospace';
    // Word wrap
    const cWords = meleComment.split(' ');
    const cLines = [];
    let cCur = '';
    for (const cw of cWords) {
      const ct = cCur ? cCur + ' ' + cw : cw;
      if (ctx.measureText(ct).width > capMaxW - 16) { if (cCur) cLines.push(cCur); cCur = cw; } else { cCur = ct; }
    }
    if (cCur) cLines.push(cCur);
    const cLineH = 13;
    const cBubW = capMaxW;
    const cBubH = cLines.length * cLineH + 10;
    const cBy = capY - cBubH / 2;
    // Small tail pointing left toward Mele
    ctx.fillStyle = 'rgba(30,24,18,0.92)';
    ctx.beginPath();
    ctx.moveTo(capX, capY);
    ctx.lineTo(capX + 8, capY - 5);
    ctx.lineTo(capX + 8, capY + 5);
    ctx.fill();
    // Caption background
    drawRect(capX + 7, cBy, cBubW, cBubH, 'rgba(30,24,18,0.92)');
    drawRect(capX + 7, cBy, 2, cBubH, '#ff8a65');
    // Text
    for (let ci = 0; ci < cLines.length; ci++) {
      drawText(cLines[ci], capX + 16, cBy + 10 + ci * cLineH, '#ffcc80', 10);
    }
  }

  mouseClick = false;
}

// --- Tab 0: Weapon Upgrade ---
function drawShopWeapon(py) {
  const w = weapons[0];
  const tierNames = ['BASE', 'POTENZIATO', 'RINFORZATO', 'LEGGENDARIO'];
  const tierGlows = [null, '#ff8a65', '#ff5722', '#ffd700'];

  // Current weapon display
  drawRect(30, py, W - 60, 130, '#1e1812');
  drawRect(30, py, W - 60, 1, '#3a2e22');
  drawRect(30, py, 5, 130, w.color || '#888');

  // Tier glow effect
  if (weaponTier > 0 && tierGlows[weaponTier]) {
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.05) * 0.05;
    drawRect(30, py, W - 60, 130, tierGlows[weaponTier]);
    ctx.globalAlpha = 1;
  }

  // Rarity badge in shop
  let shopRarLetter = 'C', shopRarColor = '#9e9e9e';
  if (rareWeapons.some(rw => rw.name === w.name) || w.name === 'Manganello') { shopRarLetter = 'R'; shopRarColor = '#2196f3'; }
  else if (legendaryWeapons.some(lw => lw.name === w.name) || w.special === 'sbombo') { shopRarLetter = 'L'; shopRarColor = '#ffd700'; }
  drawRect(44, py + 8, 24, 24, shopRarColor);
  drawText(shopRarLetter, 56, py + 26, '#000', 14, 'center');
  drawText(w.name + ' — ' + tierNames[weaponTier], 78, py + 24, '#fff', 18);
  drawText(w.desc, 78, py + 44, '#bbb', 12);

  // Stats display
  const sx = 55, sy = py + 64;
  drawText('DMG: ' + w.damage, sx, sy, '#ff8a80', 13);
  drawText('RNG: ' + w.range, sx + 150, sy, '#80d8ff', 13);
  drawText('SPD: ' + (30 - w.speed), sx + 300, sy, '#b9f6ca', 13);
  drawText('CRIT: ' + w.crit + '%', sx + 440, sy, '#ffcc80', 13);
  drawText('COMBO: ' + w.comboHits + ' colpi', sx + 580, sy, '#e040fb', 13);
  drawText('Speciale: ' + (w.special || 'nessuno'), sx, sy + 20, '#ff8a65', 12);

  // Stat bars
  const bsy = py + 100;
  drawStatBar(55, bsy, 'DANNO', w.damage, 45, 170, '#f44336');
  drawStatBar(255, bsy, 'RAGGIO', Math.min(w.range, 100), 100, 170, '#2196f3');
  drawStatBar(455, bsy, 'VELOCITA\'', 20 - w.speed, 20, 170, '#4caf50');
  drawStatBar(660, bsy, 'CRITICO', w.crit, 35, 170, '#ffeb3b');

  // Upgrade tiers
  drawText('POTENZIAMENTI DISPONIBILI', W/2, py + 150, '#ff8a65', 14, 'center');

  const upgDescs = [
    { label: 'Lv.1 — Affilatura', desc: '+10% danno base', cost: WEAPON_UPGRADE_COSTS[0] },
    { label: 'Lv.2 — Tecnica Avanzata', desc: '+1 colpo combo', cost: WEAPON_UPGRADE_COSTS[1] },
    { label: 'Lv.3 — Arma Suprema', desc: '+12% raggio, bagliore', cost: WEAPON_UPGRADE_COSTS[2] }
  ];

  for (let i = 0; i < 3; i++) {
    const uy = py + 168 + i * 58;
    const unlocked = weaponTier > i;
    const canBuy = weaponTier === i && coins >= upgDescs[i].cost;
    const isNext = weaponTier === i;
    const hover = mouseX > 40 && mouseX < W - 40 && mouseY > uy && mouseY < uy + 52;

    drawRect(40, uy, W - 80, 52, unlocked ? '#1b3a18' : hover && canBuy ? '#3a2e22' : '#1e1812');
    drawRect(40, uy, W - 80, 1, unlocked ? '#2e5a28' : '#2a2018');
    drawRect(40, uy, 4, 52, unlocked ? '#4caf50' : isNext ? '#ff8a65' : '#3a2e22');

    drawText(upgDescs[i].label, 60, uy + 22, unlocked ? '#4caf50' : isNext ? '#fff' : '#555', 14);
    drawText(upgDescs[i].desc, 60, uy + 40, unlocked ? '#81c784' : '#888', 11);

    if (unlocked) {
      drawText('SBLOCCATO', W - 100, uy + 28, '#4caf50', 13, 'center');
    } else if (isNext) {
      drawText(upgDescs[i].cost + ' COINS', W - 100, uy + 28, canBuy ? '#ffd700' : '#666', 14, 'center');
      if (hover && mouseClick && canBuy) {
        coins -= upgDescs[i].cost;
        applyWeaponUpgrade(weaponTier);
        weaponTier++;
        playSFX('coin');
        spawnParticles(W/2, uy + 24, '#ff8a65', 15, 4);
        meleComment = getMeleComment('buy'); meleCommentTimer = 180;
        mouseClick = false;
      }
    } else {
      drawText('BLOCCATO', W - 100, uy + 28, '#444', 12, 'center');
    }
  }

}

function applyWeaponUpgrade(tier) {
  const w = weapons[0];
  switch(tier) {
    case 0: // +10% damage
      w.damage = Math.round(w.damage * 1.10);
      break;
    case 1: // +1 combo hit
      w.comboHits++;
      break;
    case 2: // +12% range + glow
      w.range = Math.round(w.range * 1.12);
      w.glow = true;
      break;
  }
}

// --- Tab 1: Helper Upgrade ---
function drawShopHelper(py) {
  drawText('POTENZIA I TUOI ALLEATI', W/2, py + 15, '#e040fb', 16, 'center');

  for (let i = 0; i < 4; i++) {
    const h = helpers[i];
    const hx = 30 + i * 215;
    const hy = py + 38;
    const boxW = 205;
    const boxH = 220;
    const nextTier = h.tier;
    const maxed = nextTier >= 3;

    drawRect(hx, hy, boxW, boxH, '#1e1812');
    drawRect(hx, hy, boxW, 3, h.color);
    ctx.strokeStyle = '#2a2018';
    ctx.strokeRect(hx, hy, boxW, boxH);

    // Helper name + level
    drawText(h.icon + ' ' + h.name, hx + boxW/2, hy + 24, '#fff', 14, 'center');
    drawText('Livello ' + h.tier + '/3', hx + boxW/2, hy + 42, h.color, 12, 'center');
    drawText(h.desc, hx + boxW/2, hy + 60, '#aaa', 10, 'center');

    // Tier pips
    for (let t = 0; t < 3; t++) {
      const pipX = hx + boxW/2 - 30 + t * 22;
      drawRect(pipX, hy + 70, 16, 8, t < h.tier ? h.color : '#2a2018');
    }

    // Current tier effects
    if (h.tier > 0) {
      for (let t = 0; t < h.tier; t++) {
        drawText('Lv.' + (t+1) + ': ' + h.tiers[t].desc, hx + 12, hy + 96 + t * 16, '#81c784', 9);
      }
    }

    // Unlock or upgrade button
    const btnY = hy + boxH - 46;
    if (!h.unlocked) {
      // Must unlock first
      const canUnlock = coins >= h.unlockCost;
      const btnHover = mouseX > hx + 10 && mouseX < hx + boxW - 10 && mouseY > btnY && mouseY < btnY + 38;
      drawRect(hx + 10, btnY, boxW - 20, 38, btnHover && canUnlock ? '#3a2e22' : '#1e1812');
      drawText('SBLOCCA', hx + boxW/2, btnY + 14, '#fff', 12, 'center');
      drawText(h.unlockCost + ' COINS', hx + boxW/2, btnY + 30, canUnlock ? '#ffd700' : '#666', 12, 'center');
      if (btnHover && mouseClick && canUnlock) {
        coins -= h.unlockCost;
        h.unlocked = true;
        playSFX('coin');
        spawnParticles(hx + boxW/2, btnY + 19, h.color, 15, 5);
        meleComment = getMeleComment('buy'); meleCommentTimer = 180;
        mouseClick = false;
      }
    } else if (maxed) {
      drawText('MASSIMO', hx + boxW/2, btnY + 22, '#4caf50', 14, 'center');
    } else {
      const tierData = h.tiers[nextTier];
      const canBuy = coins >= tierData.cost;
      const btnHover = mouseX > hx + 10 && mouseX < hx + boxW - 10 && mouseY > btnY && mouseY < btnY + 38;

      drawRect(hx + 10, btnY, boxW - 20, 38, btnHover && canBuy ? '#3a2e22' : '#1e1812');
      drawText('Lv.' + (nextTier+1) + ': ' + tierData.desc, hx + boxW/2, btnY + 14, '#ccc', 9, 'center');
      drawText(tierData.cost + ' COINS', hx + boxW/2, btnY + 30, canBuy ? '#ffd700' : '#666', 12, 'center');

      if (btnHover && mouseClick && canBuy) {
        coins -= tierData.cost;
        h.tier++;
        playSFX('coin');
        spawnParticles(hx + boxW/2, btnY + 19, h.color, 12, 4);
        meleComment = getMeleComment('buy'); meleCommentTimer = 180;
        mouseClick = false;
      }
    }
  }
}

// --- Tab 2: La Ruota (Gacha) ---
function drawShopGacha(py) {
  drawText('LA RUOTA DELLA FORTUNA', W/2, py + 15, '#ffd700', 18, 'center');
  drawText('"Gira gira, Conte... vediamo che esce!"', W/2, py + 36, '#aaa', 12, 'center');
  drawText('Costo: ' + GACHA_COST + ' coins', W/2, py + 56, coins >= GACHA_COST ? '#ffd700' : '#666', 14, 'center');

  // Slot machine frame
  const slotX = W/2 - 170, slotY = py + 72, slotW = 340, slotH = 140;
  drawRect(slotX - 4, slotY - 4, slotW + 8, slotH + 8, '#ffd700');
  drawRect(slotX, slotY, slotW, slotH, '#1a1510');

  if (gachaSpinning) {
    // Spinning animation — show random items
    gachaSpinTimer--;
    const symbols = ['?', '!', '*', '$', '#', '@', '&', '%'];
    for (let s = 0; s < 3; s++) {
      const sym = symbols[Math.floor((gameTime + s * 7) / (gachaSpinTimer < 20 ? 6 : 2)) % symbols.length];
      drawText(sym, slotX + 57 + s * 113, slotY + 80, '#ffd700', 40, 'center');
    }

    if (gachaSpinTimer <= 0) {
      gachaSpinning = false;
      gachaResult = rollGacha();
      gachaResultTimer = 300;
    }
  } else if (gachaResult && gachaResultTimer > 0) {
    gachaResultTimer--;
    // Show result
    const r = gachaResult;
    const bounce = Math.sin(gachaResultTimer * 0.1) * 3;

    if (r.type === 'nothing') {
      drawText('NIENTE!', W/2, slotY + 48 + bounce, '#ff5722', 28, 'center');
      drawText(r.joke, W/2, slotY + 82, '#ffcc80', 11, 'center');
      // Sad trombone particles
      if (gachaResultTimer === 298) spawnParticles(W/2, slotY + 60, '#666', 8, 3);
    } else if (r.type === 'rare') {
      drawText('ARMA RARA!', W/2, slotY + 36 + bounce, '#2196f3', 26, 'center');
      ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.1) * 0.1;
      drawRect(slotX + 20, slotY + 10, slotW - 40, slotH - 20, '#2196f3');
      ctx.globalAlpha = 1;
      drawText(r.weapon.name, W/2, slotY + 68, '#fff', 18, 'center');
      drawText(r.weapon.desc, W/2, slotY + 90, '#aaa', 12, 'center');
      drawText('DMG:' + r.weapon.damage + '  RNG:' + r.weapon.range + '  CRIT:' + r.weapon.crit + '%', W/2, slotY + 110, '#80d8ff', 11, 'center');
    } else if (r.type === 'legendary') {
      // Epic legendary reveal
      const flash = Math.sin(gameTime * 0.15) * 0.2 + 0.3;
      ctx.globalAlpha = flash;
      drawRect(slotX, slotY, slotW, slotH, '#ffd700');
      ctx.globalAlpha = 1;
      drawText('LEGGENDARIA!!!', W/2, slotY + 36 + bounce, '#ffd700', 28, 'center');
      drawText(r.weapon.name, W/2, slotY + 70, '#fff', 20, 'center');
      drawText(r.weapon.desc, W/2, slotY + 94, '#ffcc80', 12, 'center');
      drawText('DMG:' + r.weapon.damage + '  RNG:' + r.weapon.range + '  CRIT:' + r.weapon.crit + '%', W/2, slotY + 114, '#ffd700', 11, 'center');
      if (gachaResultTimer % 10 === 0) spawnParticles(W/2 + (Math.random()-0.5)*200, slotY + 60, '#ffd700', 5, 3);
    }

    // Equip button for weapon results
    if ((r.type === 'rare' || r.type === 'legendary') && r.equipped === false) {
      const eqY = slotY + slotH + 18;
      const eqHover = mouseX > W/2 - 90 && mouseX < W/2 + 90 && mouseY > eqY && mouseY < eqY + 34;
      drawRect(W/2 - 90, eqY, 180, 34, eqHover ? '#1b5e20' : '#2e7d32');
      drawText('EQUIPAGGIA [E]', W/2, eqY + 22, '#fff', 14, 'center');
      if ((eqHover && mouseClick) || keysJustPressed['KeyE']) {
        const newWeap = JSON.parse(JSON.stringify(r.weapon));
        if (newWeap.maxAmmo) newWeap.currentAmmo = newWeap.maxAmmo;
        weapons = [newWeap];
        weaponTier = 0;
        r.equipped = true;
        spawnParticles(W/2, eqY + 17, r.weapon.color || '#fff', 20, 5);
        playSFX('coin');
        mouseClick = false;
      }
    }
  } else {
    // Idle state — show "GIRA!"
    drawText('???', W/2, slotY + 80, '#555', 44, 'center');
  }

  // Spin button
  if (!gachaSpinning) {
    const btnY = slotY + slotH + 60;
    const canSpin = coins >= GACHA_COST;
    const btnHover = mouseX > W/2 - 110 && mouseX < W/2 + 110 && mouseY > btnY && mouseY < btnY + 44;
    drawRect(W/2 - 110, btnY, 220, 44, canSpin ? (btnHover ? '#e65100' : '#bf360c') : '#333');
    drawRect(W/2 - 110, btnY, 220, 3, canSpin ? '#ff6e40' : '#555');
    drawText('GIRA! (' + GACHA_COST + ' coins)', W/2, btnY + 29, canSpin ? '#fff' : '#666', 16, 'center');

    if (btnHover && mouseClick && canSpin) {
      coins -= GACHA_COST;
      gachaSpinning = true;
      gachaSpinTimer = 60 + Math.floor(Math.random() * 30);
      gachaResult = null;
      gachaResultTimer = 0;
      playSFX('hit');
      meleComment = getMeleComment('buy'); meleCommentTimer = 180;
      mouseClick = false;
    }
  }

  // Mystery hint
  drawText('Tenta la fortuna, Conte...', W/2, H - 58, '#444', 10, 'center');
}

function rollGacha() {
  const roll = Math.random();
  if (roll < 0.80) {
    // Nothing — joke
    return { type: 'nothing', joke: gachaJokes[Math.floor(Math.random() * gachaJokes.length)] };
  } else if (roll < 0.95) {
    // Rare weapon (15% chance)
    const w = rareWeapons[Math.floor(Math.random() * rareWeapons.length)];
    return { type: 'rare', weapon: w, equipped: false };
  } else {
    // Legendary!
    const w = legendaryWeapons[Math.floor(Math.random() * legendaryWeapons.length)];
    return { type: 'legendary', weapon: w, equipped: false };
  }
}


// --- Tab 3: Stats Upgrade ---
function drawShopStats(py) {
  drawText('POTENZIA IL CONTE', W/2, py + 15, '#4caf50', 18, 'center');

  const stats = [
    { name: 'SALUTE', desc: 'Vita massima aumentata', tier: healthTier, icon: '\u2665',
      color: '#e91e63', tierDescs: ['HP base (120)', 'HP 140 (+17%)', 'HP 165 (+38%)', 'HP 195 (+63%)'] },
    { name: 'SCHIVATA', desc: 'Cooldown schivata ridotto', tier: dodgeTier, icon: 'X',
      color: '#2196f3', tierDescs: ['Cooldown base', 'Cooldown -17%', 'Cooldown -31%', 'Cooldown -46%'] },
    { name: 'VELOCITA\'', desc: 'Movimento piu\' veloce', tier: speedTier, icon: '\u00BB',
      color: '#ff9800', tierDescs: ['Velocita\' base', 'Velocita\' +10%', 'Velocita\' +20%', 'Velocita\' +33%'] },
  ];

  for (let i = 0; i < 3; i++) {
    const s = stats[i];
    const sx = 30 + i * 286;
    const sy = py + 38;
    const boxW = 272, boxH = 310;

    drawRect(sx, sy, boxW, boxH, '#1e1812');
    drawRect(sx, sy, boxW, 3, s.color);
    ctx.strokeStyle = '#2a2018';
    ctx.strokeRect(sx, sy, boxW, boxH);

    // Icon + name
    drawText(s.icon, sx + boxW/2, sy + 36, s.color, 28, 'center');
    drawText(s.name, sx + boxW/2, sy + 56, '#fff', 15, 'center');
    drawText(s.desc, sx + boxW/2, sy + 72, '#aaa', 10, 'center');

    // Level pips
    for (let t = 0; t < 3; t++) {
      const pipX = sx + boxW/2 - 33 + t * 24;
      drawRect(pipX, sy + 84, 18, 8, t < s.tier ? s.color : '#2a2018');
    }
    drawText('Lv.' + s.tier + '/3', sx + boxW/2, sy + 106, s.color, 11, 'center');

    // Current effect
    drawText(s.tierDescs[s.tier], sx + boxW/2, sy + 122, '#81c784', 10, 'center');

    // Upgrade tiers
    for (let t = 0; t < 3; t++) {
      const uy = sy + 138 + t * 56;
      const unlocked = s.tier > t;
      const isNext = s.tier === t;
      const cost = STAT_UPGRADE_COSTS[t];
      const canBuy = isNext && coins >= cost;
      const hover = mouseX > sx + 10 && mouseX < sx + boxW - 10 && mouseY > uy && mouseY < uy + 48;

      drawRect(sx + 10, uy, boxW - 20, 48, unlocked ? '#1b3a18' : hover && canBuy ? '#3a2e22' : '#1e1812');
      drawRect(sx + 10, uy, 4, 48, unlocked ? '#4caf50' : isNext ? s.color : '#2a2018');

      drawText('Lv.' + (t+1), sx + 28, uy + 18, unlocked ? '#4caf50' : isNext ? '#fff' : '#555', 12);
      drawText(stats[i].tierDescs[t+1], sx + 28, uy + 34, unlocked ? '#81c784' : '#777', 10);

      if (unlocked) {
        drawText('SBLOCCATO', sx + boxW - 50, uy + 26, '#4caf50', 11, 'center');
      } else if (isNext) {
        drawText(cost + ' COINS', sx + boxW - 50, uy + 26, canBuy ? '#ffd700' : '#666', 12, 'center');
        if (hover && mouseClick && canBuy) {
          coins -= cost;
          if (i === 0) { healthTier++; const hpGain = HP_VALUES[healthTier] - HP_VALUES[healthTier - 1]; player.maxHp += hpGain; player.hp = Math.min(player.hp + hpGain, player.maxHp); }
          else if (i === 1) { dodgeTier++; }
          else { speedTier++; player.speed = SPEED_VALUES[speedTier]; }
          playSFX('coin');
          spawnParticles(sx + boxW/2, uy + 24, s.color, 15, 4);
          meleComment = getMeleComment('buy'); meleCommentTimer = 180;
          mouseClick = false;
        }
      } else {
        drawText('BLOCCATO', sx + boxW - 50, uy + 26, '#444', 11, 'center');
      }
    }
  }
}

// ==========================================
// SHOP NPCs — Giammy e Mele
// ==========================================

// --- NPC: Mele (shorter brother, bartender) ---
function drawMele(x, y) {
  const bob = Math.sin(gameTime * 0.05) * 1;
  const sc = 1.35;
  ctx.save();
  ctx.translate(x, y + bob);
  ctx.scale(sc, sc);
  ctx.translate(-x, -(y + bob));
  drawPixelChar(x, y + bob, 38, 44, '#5d4037', '#ffcc80', (px, py, w, h) => {
    // Apron over casual shirt
    drawRect(px + 4, py + 22, w - 8, h - 38, '#e0e0e0');
    drawRect(px + w/2 - 3, py + 22, 6, h - 38, '#bdbdbd');
    // Shirt collar peeking
    drawRect(px + 8, py + 18, w - 16, 6, '#795548');
    // Bar towel on left shoulder
    drawRect(px - 2, py + 20, 8, 14, '#fff9c4');
    drawRect(px - 1, py + 22, 6, 10, '#fff176');
    // Tired face — bags under eyes
    ctx.globalAlpha = 0.3;
    drawRect(px + 7, py + 14, 7, 2, '#8d6e63');
    drawRect(px + w - 14, py + 14, 7, 2, '#8d6e63');
    ctx.globalAlpha = 1;
    // Frown
    drawRect(px + 12, py + 18, 14, 2, '#5d4037');
    // Hair (short, messy)
    drawRect(px + 6, py - 2, w - 12, 4, '#3e2723');
    drawRect(px + 4, py, 4, 3, '#3e2723');
    drawRect(px + w - 8, py, 4, 3, '#3e2723');
    // Gesturing right arm
    const gestBob = Math.sin(gameTime * 0.08) * 2;
    drawRect(px + w - 2, py + 22, 8, 4, '#5d4037');
    drawRect(px + w + 4, py + 18 + gestBob, 6, 5, '#ffcc80');
  });
  ctx.restore();
}

// --- NPC: Giammy (bigger brother, gamer) ---
function drawGiammy(x, y) {
  const bob = Math.sin(gameTime * 0.03) * 1.5;
  const sc = 1.35;
  ctx.save();
  ctx.translate(x, y + bob);
  ctx.scale(sc, sc);
  ctx.translate(-x, -(y + bob));
  drawPixelChar(x, y + bob, 50, 48, '#37474f', '#ffcc80', (px, py, w, h) => {
    // Hoodie body (dark blue-gray)
    drawRect(px + 2, py + 20, w - 4, h - 36, '#37474f');
    drawRect(px + w/2 - 3, py + 22, 6, 14, '#263238'); // hoodie zipper
    // Hood behind head
    drawRect(px + 2, py - 2, w - 4, 6, '#37474f');
    // Headphones around neck
    drawRect(px + 4, py + 16, 6, 5, '#333');
    drawRect(px + w - 10, py + 16, 6, 5, '#333');
    drawRect(px + 4, py + 14, w - 8, 3, '#444');
    // Relaxed eyes (looking down at controller)
    drawRect(px + 9, py + 10, 4, 3, '#fff');
    drawRect(px + w - 13, py + 10, 4, 3, '#fff');
    drawRect(px + 10, py + 11, 2, 2, '#111');
    drawRect(px + w - 12, py + 11, 2, 2, '#111');
    // Slight smile
    drawRect(px + 14, py + 17, 8, 2, '#8d6e63');
    // Arms holding controller (lowered)
    drawRect(px - 3, py + 22, 8, 20, '#37474f');
    drawRect(px + w - 5, py + 22, 8, 20, '#37474f');
    // Hands (skin) holding controller
    drawRect(px + 6, py + 40, 6, 5, '#ffcc80');
    drawRect(px + w - 12, py + 40, 6, 5, '#ffcc80');
    // Game controller
    const ctrlBob = Math.sin(gameTime * 0.06) * 0.5;
    drawRect(px + 8, py + 42 + ctrlBob, w - 16, 6, '#222');
    drawRect(px + 10, py + 43 + ctrlBob, 4, 4, '#4caf50'); // green button
    drawRect(px + w - 14, py + 43 + ctrlBob, 4, 4, '#f44336'); // red button
    drawRect(px + w/2 - 3, py + 43 + ctrlBob, 6, 3, '#666'); // d-pad
    // Hair (short)
    drawRect(px + 6, py - 1, w - 12, 3, '#3e2723');
  });
  ctx.restore();
}

// --- Mele Dialogue Lines ---
const MELE_WELCOME = [
  '"Benvenuto all\'armeria! ...io faccio tutto, Giammy gioca."',
  '"Ah, Conte! Entra, entra... tanto qui lavoro solo io."',
  '"Eccolo il Conte! Giammy, saluta! ...no? Ok, come sempre."',
  '"Benvenuto da Giammy e Mele! ...cioe\', da Mele. Giammy sta giocando."',
  '"Che vuoi, Conte? Armi? Potenziamenti? Un fratello che lavora?"'
];
const MELE_IDLE = [
  '"Giammy, aiutami col magazzino! ...niente, sta su \'sta console."',
  '"Io pulisco, servo, ordino... lui gioca a Fortnite."',
  '"Un giorno chiudo e me ne vado. Ma chi lo gestisce \'sto bar?"',
  '"Senti che silenzio... ah no, e\' il pad di Giammy che clicca."',
  '"Mamma diceva: aprite un negozio INSIEME. Insieme un cazzo."',
  '"Ieri ho fatto 14 ore. Giammy ha fatto 14 kill su Warzone."',
  '"Se mi pagassero per le bestemmie che tiro, sarei ricco."',
  '"Giammy dice che e\' influencer. Ha 43 follower."',
  '"Almeno al casino Andreino lavora... a modo suo, ma lavora."',
  '"Io volevo fare il cuoco, non l\'armaiolo. Ma vabbe\'."'
];
const MELE_BUY = [
  '"Ottima scelta! Almeno qualcuno spende qui."',
  '"Grazie, Conte! Cosi\' pago l\'affitto... e il WiFi di Giammy."',
  '"Venduto! Un giorno queste armi ci renderanno famosi."',
  '"Eccoti servito. Giammy, segna sul registro! ...no? Ok."',
  '"Bella roba! Provata personalmente. Cioe\', l\'ho provata IO."',
  '"Affare fatto! Torno a pulire il bancone..."'
];
const MELE_TAB = [
  '"Guarda pure con calma, tanto io non mi muovo da qui."',
  '"Scegli bene, Conte... io consiglio tutto."',
  '"Eh, abbiamo tanta roba! Tutta organizzata da ME, ovviamente."',
  '"Sfoglia, sfoglia... Giammy non ti aiutera\' comunque."'
];
const MELE_GACHA = [
  '"La Ruota! Io non ci gioco, ho gia\' abbastanza sfiga."',
  '"Gira gira... magari esce qualcosa di bello!"',
  '"La ruota e\' l\'unica cosa che Giammy sa usare. Oltre al pad."',
  '"Tenta la fortuna, Conte! Peggio di lavorare con Giammy non puo\' andare."'
];
const MELE_BROKE = [
  '"Sei al verde, Conte. Ti capisco, pure io."',
  '"Zero coins? Vai a combattere e torna con i soldi."',
  '"Non hai una lira... come me dopo che Giammy ordina le pizze."'
];

function getMeleComment(type) {
  const lists = { welcome: MELE_WELCOME, idle: MELE_IDLE, buy: MELE_BUY, tab: MELE_TAB, gacha: MELE_GACHA, broke: MELE_BROKE };
  const list = lists[type] || MELE_IDLE;
  return list[Math.floor(Math.random() * list.length)];
}

// ==========================================
// CASINO — Bingo degli Ubaldi
// ==========================================

// --- NPC: Andreino Volpi (big version) ---
function drawAndreinoVolpi(x, y) {
  const bob = Math.sin(gameTime * 0.04) * 2;
  drawPixelChar(x, y + bob, 56, 82, '#2e7d32', '#ffcc80', (px, py, w, h) => {
    // PokerStars hat (dark red with gold star/spade)
    drawRect(px - 2, py - 10, w + 4, 8, '#8b0000');
    drawRect(px - 5, py - 3, w + 10, 6, '#8b0000');
    drawRect(px + 5, py - 12, 8, 4, '#ffd700'); // gold star
    drawRect(px + w - 14, py - 11, 7, 4, '#333'); // spade symbol
    // Hair peeking
    drawRect(px + 4, py, w - 8, 4, '#3e2723');
    // Stubble
    ctx.globalAlpha = 0.3;
    for (let sx = 0; sx < 6; sx++) {
      drawRect(px + 10 + sx * 7, py + 24, 3, 3, '#5d4037');
    }
    ctx.globalAlpha = 1;
    // Green hoodie body
    drawRect(px + 3, py + 30, w - 6, h - 50, '#2e7d32');
    drawRect(px + w/2 - 4, py + 32, 8, 16, '#1b5e20'); // hoodie zipper
    // Hoodie pocket
    drawRect(px + 10, py + 50, w - 20, 8, '#256028');
    // Arms
    drawRect(px - 5, py + 32, 9, 28, '#2e7d32');
    drawRect(px + w - 4, py + 32, 9, 28, '#2e7d32');
    // Hands (skin)
    drawRect(px - 4, py + 58, 7, 6, '#ffcc80');
    drawRect(px + w - 3, py + 58, 7, 6, '#ffcc80');
    // Joint in right hand
    drawRect(px + w + 3, py + 56, 16, 3, '#f5f5dc');
    drawRect(px + w + 16, py + 55, 4, 4, '#ff6f00');
    // Ember glow
    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.1) * 0.3;
    drawRect(px + w + 17, py + 54, 2, 2, '#ff3d00');
    ctx.globalAlpha = 1;
    // Smoke wisps (multiple, animated)
    const smokeT = gameTime * 0.06;
    for (let si = 0; si < 3; si++) {
      const sOff = si * 12;
      ctx.globalAlpha = 0.2 - si * 0.05;
      drawRect(px + w + 16 + Math.sin(smokeT + si) * 5, py + 48 - sOff - (gameTime % 35), 3, 4, '#bbb');
    }
    ctx.globalAlpha = 1;
    // Knee brace on left leg
    drawRect(px + 6, py + h - 18, 16, 6, '#90a4ae');
    drawRect(px + 7, py + h - 17, 14, 4, '#607d8b');
    drawRect(px + 10, py + h - 16, 2, 2, '#b0bec5'); // buckle
  });
}

// --- NPC: Panda (big version) ---
function drawPandaNpc(x, y) {
  const bob = Math.sin(gameTime * 0.035) * 2;
  const py = y + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(x - 2, py + 76, 64, 8);
  // Body (white round)
  drawRect(x + 6, py + 24, 48, 52, '#f5f5f5');
  // Belly spot
  drawRect(x + 16, py + 34, 28, 30, '#e8e8e8');
  // Head (white round, big)
  drawRect(x + 3, py, 54, 36, '#fafafa');
  // Ears (black, chunky)
  drawRect(x - 2, py - 8, 14, 14, '#222');
  drawRect(x + 48, py - 8, 14, 14, '#222');
  // Ear inner (pink)
  drawRect(x + 1, py - 5, 8, 8, '#444');
  drawRect(x + 51, py - 5, 8, 8, '#444');
  // Eye patches (black, big)
  drawRect(x + 8, py + 8, 16, 16, '#222');
  drawRect(x + 36, py + 8, 16, 16, '#222');
  // White eyes inside patches
  drawRect(x + 11, py + 11, 10, 10, '#fff');
  drawRect(x + 39, py + 11, 10, 10, '#fff');
  // Pupils (animated look)
  const lookX = Math.sin(gameTime * 0.02) * 2;
  drawRect(x + 15 + lookX, py + 14, 4, 5, '#111');
  drawRect(x + 43 + lookX, py + 14, 4, 5, '#111');
  // Eye shine
  drawRect(x + 14, py + 12, 2, 2, 'rgba(255,255,255,0.7)');
  drawRect(x + 42, py + 12, 2, 2, 'rgba(255,255,255,0.7)');
  // Nose
  drawRect(x + 24, py + 24, 10, 5, '#333');
  // Mouth / smile
  drawRect(x + 22, py + 29, 5, 2, '#555');
  drawRect(x + 33, py + 29, 5, 2, '#555');
  drawRect(x + 26, py + 30, 8, 2, '#555');
  // Arms (black, chunky)
  drawRect(x - 4, py + 28, 12, 36, '#222');
  drawRect(x + 52, py + 28, 12, 36, '#222');
  // Paws (lighter tips)
  drawRect(x - 3, py + 60, 10, 6, '#444');
  drawRect(x + 53, py + 60, 10, 6, '#444');
  // Padel racket in right paw
  drawRect(x + 62, py + 38, 4, 22, '#8d6e63'); // handle
  drawRect(x + 58, py + 24, 16, 16, '#1565c0'); // racket head
  drawRect(x + 61, py + 27, 10, 10, '#1976d2'); // inner grid
  // Grid lines on racket
  drawRect(x + 65, py + 27, 1, 10, '#0d47a1');
  drawRect(x + 61, py + 31, 10, 1, '#0d47a1');
  // Headband (blue sporty)
  drawRect(x + 3, py + 2, 54, 5, '#1565c0');
  drawRect(x + 50, py + 2, 14, 3, '#1976d2'); // headband tail
  drawRect(x + 56, py + 4, 8, 2, '#1565c0'); // tail end
  // Legs (black, short)
  drawRect(x + 12, py + 70, 14, 16, '#222');
  drawRect(x + 34, py + 70, 14, 16, '#222');
  // Feet
  drawRect(x + 10, py + 82, 18, 6, '#222');
  drawRect(x + 32, py + 82, 18, 6, '#222');
}

// --- NPC Dialogue Lines ---
const ANDREINO_IDLE = [
  '"Aho, oggi vinco io... come sempre su PokerStars."',
  '"Prima del ginocchio giocavo a pallone... adesso gioco a carte."',
  '"Tira, tira... tanto perdi."',
  '"Me so\' fumato er guadagno de ieri... in tutti i sensi."',
  '"Su PokerStars ero Andreino_il_Re. Bannato 3 volte."',
  '"Il poker e\' come er calcio: serve strategia... e culo."'
];
const ANDREINO_WIN = [
  '"Bravo, hai vinto! Ma io ho vinto de piu\' ieri sera."',
  '"Bella mano! Quasi come le mie su PokerStars."',
  '"Vince chi sa bluffare... e te nun stai bluffando."',
  '"Complimenti! Ma col ginocchio rotto io vincevo comunque."',
  '"Hai fortuna, Conte! Fumati \'sto successo."'
];
const ANDREINO_LOSE = [
  '"Ahahah! Come quando me so\' rotto er ginocchio: male."',
  '"Hai perso? Capita. A me capita ogni giorno su PokerStars."',
  '"Niente, Conte... riprova e rifumati la tristezza."',
  '"Mano morta! Come il mio ginocchio sinistro."',
  '"Dai su, nun piagne... piango gia\' io per la carriera."'
];
const ANDREINO_BIG_WIN = [
  '"MADONNA! Manco a PokerStars Vegas!"',
  '"BOOM! Hai spaccato! Come il mio legamento crociato!"',
  '"JACKPOT DELLA MADONNA! Me devi offrire er caffe\'!"'
];
const ANDREINO_BROKE = [
  '"Sei al verde... come la mia erba preferita."',
  '"Zero coins? Vai a lavorare, Conte!"'
];

const PANDA_IDLE = [
  '"Gira le slot come un rovescio: con potenza!"',
  '"Ogni spin e\' come un match point... tensione pura."',
  '"Io gioco a padel E gestisco le slot. Multitasking."',
  '"Le probabilita\'? Come vincere un tie-break: servono i nervi."',
  '"Pensa alla slot come un campo da padel: tutto puo\' succedere."',
  '"Facciamo un set? ...di slot, intendo."'
];
const PANDA_WIN = [
  '"ACE! Punto diretto! Che spin!"',
  '"Game, set, SOLDI! Bel colpo, Conte!"',
  '"Hai vinto come Alcaraz al Roland Garros!"',
  '"Dritto vincente! Cioe\'... slot vincente!"',
  '"Match point convertito! I coins sono tuoi!"'
];
const PANDA_LOSE = [
  '"Doppio fallo! Niente, riprova."',
  '"Fuori campo! Zero punti \'sto giro."',
  '"Palla in rete! Meglio al prossimo spin."',
  '"Hai perso come uno che gioca padel coi piedi."',
  '"Break subito! Ma il match e\' lungo..."'
];
const PANDA_BIG_WIN = [
  '"GOLDEN SET!!! MAI VISTO UNO SPIN COSI\'!"',
  '"SLAM! HAI VINTO LO SLAM DELLE SLOT!"',
  '"MATCHBALL CONVERTITO! SEI UN CAMPIONE!"'
];
const PANDA_BROKE = [
  '"Ritiro per infortunio economico."',
  '"Partita sospesa: zero coins in campo."'
];

function getAndreinoComment(type) {
  const lists = { idle: ANDREINO_IDLE, win: ANDREINO_WIN, lose: ANDREINO_LOSE, bigwin: ANDREINO_BIG_WIN, broke: ANDREINO_BROKE };
  const list = lists[type] || ANDREINO_IDLE;
  return list[Math.floor(Math.random() * list.length)];
}
function getPandaComment(type) {
  const lists = { idle: PANDA_IDLE, win: PANDA_WIN, lose: PANDA_LOSE, bigwin: PANDA_BIG_WIN, broke: PANDA_BROKE };
  const list = lists[type] || PANDA_IDLE;
  return list[Math.floor(Math.random() * list.length)];
}

// --- Card Utilities ---
function createShuffledDeck() {
  const deck = [];
  for (const suit of CARD_SUITS) {
    for (const rank of CARD_RANKS) {
      deck.push({ suit, rank });
    }
  }
  // Fisher-Yates shuffle
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

function cardRankValue(rank) {
  return CARD_RANKS.indexOf(rank);
}

function evaluatePokerHand(hand) {
  const ranks = hand.map(c => cardRankValue(c.rank)).sort((a, b) => a - b);
  const suits = hand.map(c => c.suit);
  const isFlush = suits.every(s => s === suits[0]);
  const isStraight = (ranks[4] - ranks[0] === 4 && new Set(ranks).size === 5) ||
    (ranks[0] === 0 && ranks[1] === 1 && ranks[2] === 2 && ranks[3] === 3 && ranks[4] === 12); // A-2-3-4-5
  const counts = {};
  ranks.forEach(r => { counts[r] = (counts[r] || 0) + 1; });
  const freq = Object.values(counts).sort((a, b) => b - a);

  if (isFlush && isStraight && ranks[0] === 8) return 'Royal Flush';
  if (isFlush && isStraight) return 'Straight Flush';
  if (freq[0] === 4) return 'Four of a Kind';
  if (freq[0] === 3 && freq[1] === 2) return 'Full House';
  if (isFlush) return 'Flush';
  if (isStraight) return 'Straight';
  if (freq[0] === 3) return 'Three of a Kind';
  if (freq[0] === 2 && freq[1] === 2) return 'Two Pair';
  if (freq[0] === 2) {
    // Check if pair is Jacks or better
    const pairRank = parseInt(Object.keys(counts).find(k => counts[k] === 2));
    if (pairRank >= 9) return 'Jacks or Better'; // J=9, Q=10, K=11, A=12
    return 'Nothing';
  }
  return 'Nothing';
}

function drawCard(x, y, card, w, h) {
  w = w || 64;
  h = h || 88;
  // Card shadow
  drawRect(x + 3, y + 3, w, h, 'rgba(0,0,0,0.25)');
  // Card background
  drawRect(x, y, w, h, '#fff');
  drawRect(x, y, w, 2, '#ddd');
  ctx.strokeStyle = '#999';
  ctx.strokeRect(x, y, w, h);
  // Suit & rank
  const sym = SUIT_SYMBOLS[card.suit];
  const col = SUIT_COLORS[card.suit];
  drawText(card.rank, x + 10, y + 18, col, 14);
  drawText(sym, x + 10, y + 32, col, 10);
  drawText(sym, x + w/2, y + h/2 + 8, col, 28, 'center');
  drawText(card.rank, x + w - 10, y + h - 10, col, 10, 'right');
}

function drawCardBack(x, y, w, h) {
  w = w || 64;
  h = h || 88;
  // Shadow
  drawRect(x + 3, y + 3, w, h, 'rgba(0,0,0,0.25)');
  drawRect(x, y, w, h, '#1565c0');
  drawRect(x + 4, y + 4, w - 8, h - 8, '#0d47a1');
  // Diamond pattern
  const cols = Math.floor((w - 16) / 14);
  const rows = Math.floor((h - 16) / 16);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      drawRect(x + 10 + c * 14, y + 10 + r * 16, 10, 10, '#1976d2');
    }
  }
  // Center emblem
  drawRect(x + w/2 - 8, y + h/2 - 8, 16, 16, '#ffd700');
  drawRect(x + w/2 - 5, y + h/2 - 5, 10, 10, '#0d47a1');
}

// --- Casino Speech Bubble ---
function drawCasinoBubble(x, y, text, maxW, accentColor) {
  maxW = maxW || 220;
  accentColor = accentColor || '#555';
  ctx.font = '11px monospace';
  // Word wrap
  const words = text.split(' ');
  const lines = [];
  let curLine = '';
  for (const word of words) {
    const test = curLine ? curLine + ' ' + word : word;
    if (ctx.measureText(test).width > maxW - 20) {
      if (curLine) lines.push(curLine);
      curLine = word;
    } else {
      curLine = test;
    }
  }
  if (curLine) lines.push(curLine);
  const lineH = 15;
  const bubW = maxW;
  const bubH = lines.length * lineH + 16;
  const bx = x - bubW/2;
  const by = y - bubH - 10;
  // Bubble shadow
  drawRect(bx + 3, by + 3, bubW, bubH, 'rgba(0,0,0,0.3)');
  // Bubble background
  drawRect(bx, by, bubW, bubH, 'rgba(255,255,255,0.95)');
  drawRect(bx, by, bubW, 3, accentColor);
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = 1.5;
  ctx.strokeRect(bx, by, bubW, bubH);
  ctx.lineWidth = 1;
  // Tail
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.moveTo(x - 8, by + bubH);
  ctx.lineTo(x + 8, by + bubH);
  ctx.lineTo(x, by + bubH + 10);
  ctx.fill();
  ctx.strokeStyle = accentColor;
  ctx.beginPath();
  ctx.moveTo(x - 8, by + bubH);
  ctx.lineTo(x, by + bubH + 10);
  ctx.lineTo(x + 8, by + bubH);
  ctx.stroke();
  // Text
  for (let i = 0; i < lines.length; i++) {
    drawText(lines[i], x, by + 14 + i * lineH, '#222', 11, 'center');
  }
}

// --- Main Casino Draw ---
function drawCasino() {
  // Dark smoky background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0d0a1a');
  grad.addColorStop(0.3, '#140e28');
  grad.addColorStop(0.7, '#120e24');
  grad.addColorStop(1, '#0d0a1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Ambient smoke particles
  ctx.globalAlpha = 0.05;
  for (let i = 0; i < 10; i++) {
    const sx = (i * 113 + gameTime * 0.25) % W;
    const sy = 80 + Math.sin(gameTime * 0.008 + i * 0.7) * 60;
    drawRect(sx, sy, 50 + i * 12, 15 + i * 3, '#776');
  }
  ctx.globalAlpha = 1;

  // Floor — dark carpet with subtle pattern
  drawRect(0, H - 60, W, 60, '#1a0e28');
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = 0.06;
    drawRect(i * 32, H - 58, 28, 4, '#2a1a3a');
    drawRect(i * 32 + 16, H - 52, 28, 4, '#2a1a3a');
    ctx.globalAlpha = 1;
  }
  drawRect(0, H - 60, W, 2, '#3d2050');

  // Pulsing neon title
  const neonPulse = 0.7 + Math.sin(gameTime * 0.05) * 0.3;
  // Glow behind title
  ctx.globalAlpha = neonPulse * 0.12;
  drawRect(W/2 - 180, 4, 360, 32, '#9c27b0');
  ctx.globalAlpha = 1;
  drawText('BINGO DEGLI UBALDI', W/2, 26, '#ce93d8', 20, 'center');
  ctx.globalAlpha = neonPulse * 0.4;
  drawText('BINGO DEGLI UBALDI', W/2, 27, '#e1bee7', 20, 'center');
  ctx.globalAlpha = 1;

  // Coins display
  drawRect(W/2 - 60, 30, 120, 18, 'rgba(0,0,0,0.4)');
  drawText('COINS: ' + coins, W/2, 44, '#ffd700', 13, 'center');

  // === TAB BUTTONS ===
  const tabNames = ['VIDEO POKER [1]', 'SLOT MACHINE [2]'];
  const tabColors = ['#4caf50', '#ff9800'];
  const tabW = 220, tabH = 30, tabY = 52;
  for (let t = 0; t < 2; t++) {
    const tx = W/2 - 230 + t * 240;
    const active = casinoTab === t;
    const hover = mouseX > tx && mouseX < tx + tabW && mouseY > tabY && mouseY < tabY + tabH;
    drawRect(tx, tabY, tabW, tabH, active ? tabColors[t] : hover ? '#333' : '#1a1a2e');
    drawRect(tx, tabY, tabW, 2, tabColors[t]);
    if (active) {
      drawRect(tx, tabY + tabH - 2, tabW, 2, tabColors[t]);
    }
    drawText(tabNames[t], tx + tabW/2, tabY + 20, active ? '#000' : '#888', 12, 'center');
    if (hover && mouseClick) {
      casinoTab = t;
      mouseClick = false;
    }
  }
  // Tab keys — only when not in active game (avoid conflict with poker hold keys)
  if (pokerPhase === 'idle' && slotPhase === 'idle') {
    if (keysJustPressed['Digit1']) casinoTab = 0;
    if (keysJustPressed['Digit2']) casinoTab = 1;
  }

  const panelY = 86;
  if (!casinoDialogueActive) {
    if (casinoTab === 0) drawVideoPoker(panelY);
    else drawSlotMachine(panelY);
  }

  // Back button
  const backHover = mouseX > 20 && mouseX < 150 && mouseY > H - 40 && mouseY < H - 10;
  drawRect(20, H - 40, 130, 30, backHover ? '#c62828' : '#b71c1c');
  drawRect(20, H - 40, 130, 2, '#e94560');
  drawText('INDIETRO [ESC]', 85, H - 20, '#fff', 12, 'center');
  if ((backHover && mouseClick) || keysJustPressed['Escape']) {
    state = 'hub';
    mouseClick = false;
  }

  // Casino dialogue overlay
  if (casinoDialogueActive) {
    drawCasinoDialogue();
  }

  mouseClick = false;
}

// --- Casino Dialogue ---
function drawCasinoDialogue() {
  // Dark overlay
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, W, H);

  // Dialogue box
  const dlgY = isTouchDevice ? 200 : H - 160;
  drawRect(50, dlgY, W - 100, 120, 'rgba(20,20,40,0.95)');
  drawRect(50, dlgY, W - 100, 3, '#ce93d8');

  if (casinoDialogueIndex < casinoDialogueLines.length) {
    const line = casinoDialogueLines[casinoDialogueIndex];
    drawText(line, W/2, dlgY + 55, '#fff', 15, 'center');

    if (Math.floor(gameTime / 30) % 2 === 0) {
      drawText('[ENTER]', W/2, dlgY + 100, '#888', 11, 'center');
    }

    casinoDialogueCooldown = Math.max(0, casinoDialogueCooldown - 1);
    if ((keysJustPressed['Enter'] || mouseClick) && casinoDialogueCooldown === 0) {
      casinoDialogueIndex++;
      casinoDialogueCooldown = 15;
      mouseClick = false;
    }
  } else {
    casinoDialogueActive = false;
  }
}

// --- Video Poker ---
function drawVideoPoker(panelY) {
  // NPC column (left side)
  const npcX = 20, npcW = 140;
  drawRect(npcX, panelY, npcW, H - panelY - 50, 'rgba(0,0,0,0.3)');
  drawRect(npcX + npcW, panelY, 2, H - panelY - 50, '#2e7d32');

  // Draw NPC centered in column
  drawAndreinoVolpi(npcX + 40, panelY + 120);
  // NPC name plate
  drawRect(npcX + 10, panelY + 6, npcW - 20, 22, 'rgba(0,0,0,0.6)');
  drawRect(npcX + 10, panelY + 6, npcW - 20, 2, '#4caf50');
  drawText('ANDREINO VOLPI', npcX + npcW/2, panelY + 22, '#4caf50', 9, 'center');

  // NPC comment bubble
  if (pokerNpcCommentTimer > 0) {
    pokerNpcCommentTimer--;
    drawCasinoBubble(npcX + npcW/2, panelY + 110, pokerNpcComment, 190, '#4caf50');
  } else if (pokerPhase === 'idle') {
    if (gameTime % 360 === 0) pokerNpcComment = getAndreinoComment('idle');
    if (pokerNpcComment) drawCasinoBubble(npcX + npcW/2, panelY + 110, pokerNpcComment, 190, '#4caf50');
  }

  // Poker table area (right of NPC)
  const tableX = npcX + npcW + 8;
  const tableW = W - tableX - 10;
  drawRect(tableX, panelY, tableW, H - panelY - 50, 'rgba(0,60,0,0.12)');
  drawRect(tableX, panelY, tableW, 2, '#4caf50');

  // Payout table (compact strip on right)
  const payW = 150;
  const payX = tableX + tableW - payW - 4;
  const payY = panelY + 4;
  drawRect(payX, payY, payW, 182, 'rgba(0,0,0,0.55)');
  drawRect(payX, payY, payW, 3, '#ffd700');
  drawText('PAGAMENTI', payX + payW/2, payY + 16, '#ffd700', 12, 'center');
  const payNames = Object.keys(POKER_PAYOUTS);
  for (let i = 0; i < payNames.length - 1; i++) {
    const name = payNames[i];
    const mult = POKER_PAYOUTS[name];
    const isActive = pokerPhase === 'result' && pokerResult === name;
    if (isActive) drawRect(payX + 3, payY + 22 + i * 17, payW - 6, 16, 'rgba(255,215,0,0.15)');
    drawText(name, payX + 8, payY + 36 + i * 17, isActive ? '#ffd700' : '#bbb', 10);
    drawText(mult + 'x', payX + payW - 8, payY + 36 + i * 17, isActive ? '#ffd700' : '#999', 10, 'right');
  }

  // Cards area — big cards, centered in table (left of payout)
  const cardW = 80, cardH = 110;
  const cardAreaW = tableW - payW - 20;
  const cardSpacing = Math.min(90, Math.floor((cardAreaW - cardW) / 4));
  const totalCardsW = 4 * cardSpacing + cardW;
  const cardStartX = tableX + (cardAreaW - totalCardsW) / 2;
  const cardY = panelY + 10;

  if (pokerPhase === 'idle') {
    // Show face-down cards
    for (let i = 0; i < 5; i++) {
      drawCardBack(cardStartX + i * cardSpacing, cardY, cardW, cardH);
    }

    // Bet controls (below cards)
    const betY = cardY + cardH + 16;
    const betCenterX = cardStartX + totalCardsW / 2;
    drawText('PUNTATA: ' + pokerBet, betCenterX, betY + 16, '#ffd700', 16, 'center');

    const minusBx = betCenterX - 90;
    const plusBx = betCenterX + 60;
    const minusHover = mouseX > minusBx && mouseX < minusBx + 36 && mouseY > betY && mouseY < betY + 28;
    const plusHover = mouseX > plusBx && mouseX < plusBx + 36 && mouseY > betY && mouseY < betY + 28;
    drawRect(minusBx, betY, 36, 28, minusHover ? '#555' : '#333');
    drawRect(minusBx, betY, 36, 2, '#666');
    drawText('<', minusBx + 18, betY + 19, '#fff', 16, 'center');
    drawRect(plusBx, betY, 36, 28, plusHover ? '#555' : '#333');
    drawRect(plusBx, betY, 36, 2, '#666');
    drawText('>', plusBx + 18, betY + 19, '#fff', 16, 'center');

    if ((minusHover && mouseClick) || keysJustPressed['ArrowLeft']) {
      pokerBet = Math.max(POKER_BET_MIN, pokerBet - POKER_BET_STEP);
      mouseClick = false;
    }
    if ((plusHover && mouseClick) || keysJustPressed['ArrowRight']) {
      pokerBet = Math.min(POKER_BET_MAX, pokerBet + POKER_BET_STEP);
      mouseClick = false;
    }

    // Deal button
    const canDeal = coins >= pokerBet;
    const dealY = betY + 38;
    const dealBx = betCenterX - 95;
    const dealBw = 190;
    const dealHover = mouseX > dealBx && mouseX < dealBx + dealBw && mouseY > dealY && mouseY < dealY + 38;
    drawRect(dealBx, dealY, dealBw, 38, canDeal ? (dealHover ? '#2e7d32' : '#1b5e20') : '#333');
    drawRect(dealBx, dealY, dealBw, 2, canDeal ? '#4caf50' : '#555');
    drawText('DISTRIBUISCI [ENTER]', dealBx + dealBw/2, dealY + 25, canDeal ? '#fff' : '#666', 13, 'center');

    if (canDeal && ((dealHover && mouseClick) || keysJustPressed['Enter'])) {
      coins -= pokerBet;
      pokerDeck = createShuffledDeck();
      pokerHand = pokerDeck.splice(0, 5);
      pokerHeld = [false, false, false, false, false];
      pokerPhase = 'hold';
      pokerDealAnim = 30;
      pokerNpcComment = '';
      pokerNpcCommentTimer = 0;
      playSFX('hit');
      mouseClick = false;
    } else if (!canDeal && ((dealHover && mouseClick) || keysJustPressed['Enter'])) {
      pokerNpcComment = getAndreinoComment('broke');
      pokerNpcCommentTimer = 180;
      mouseClick = false;
    }

  } else if (pokerPhase === 'hold') {
    pokerDealAnim = Math.max(0, pokerDealAnim - 1);

    for (let i = 0; i < 5; i++) {
      const cx = cardStartX + i * cardSpacing;
      const cy = cardY;
      const revealed = pokerDealAnim < (25 - i * 5);

      if (revealed && pokerHand[i]) {
        drawCard(cx, cy, pokerHand[i], cardW, cardH);
        // Subtle border on non-held cards to hint they're tappable
        if (!pokerHeld[i] && pokerDealAnim === 0) {
          ctx.globalAlpha = 0.25 + Math.sin(gameTime * 0.1 + i) * 0.15;
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 2;
          ctx.strokeRect(cx, cy, cardW, cardH);
          ctx.globalAlpha = 1;
        }
        // Hold indicator
        if (pokerHeld[i]) {
          drawRect(cx, cy + cardH + 2, cardW, 18, '#ffd700');
          drawText('TIENI', cx + cardW/2, cy + cardH + 16, '#000', 10, 'center');
        }
        // Number label
        drawText(String(i + 1), cx + cardW/2, cy + cardH + (pokerHeld[i] ? 34 : 16), '#666', 9, 'center');
        // Click to toggle hold
        const cardHover = mouseX > cx && mouseX < cx + cardW && mouseY > cy && mouseY < cy + cardH;
        if (cardHover && mouseClick) {
          pokerHeld[i] = !pokerHeld[i];
          playSFX('hit');
          mouseClick = false;
        }
      } else {
        drawCardBack(cx, cy, cardW, cardH);
      }
    }
    // Keyboard hold: keys 1-5
    if (pokerDealAnim === 0) {
      for (let i = 0; i < 5; i++) {
        if (keysJustPressed['Digit' + (i + 1)]) {
          pokerHeld[i] = !pokerHeld[i];
          playSFX('hit');
        }
      }
    }

    // Draw button
    if (pokerDealAnim === 0) {
      const drawBtnY = cardY + cardH + 40;
      const drawBx = cardStartX + totalCardsW / 2 - 95;
      const drawBw = 190;
      const drawHover = mouseX > drawBx && mouseX < drawBx + drawBw && mouseY > drawBtnY && mouseY < drawBtnY + 38;
      drawRect(drawBx, drawBtnY, drawBw, 38, drawHover ? '#e65100' : '#bf360c');
      drawRect(drawBx, drawBtnY, drawBw, 2, '#ff6e40');
      drawText('PESCA [ENTER]', drawBx + drawBw/2, drawBtnY + 25, '#fff', 13, 'center');

      const hintPulse = 0.5 + Math.sin(gameTime * 0.1) * 0.3;
      ctx.globalAlpha = hintPulse;
      drawText('TOCCA LE CARTE PER TENERLE', drawBx + drawBw/2, drawBtnY + 52, '#ffd700', 10, 'center');
      ctx.globalAlpha = 1;

      if ((drawHover && mouseClick) || keysJustPressed['Enter']) {
        for (let i = 0; i < 5; i++) {
          if (!pokerHeld[i]) pokerHand[i] = pokerDeck.pop();
        }
        pokerPhase = 'redraw';
        pokerRedrawAnim = 35;
        playSFX('hit');
        mouseClick = false;
      }
    }

  } else if (pokerPhase === 'redraw') {
    pokerRedrawAnim = Math.max(0, pokerRedrawAnim - 1);
    // Staggered reveal: each non-held card flips at a different time
    let redrawIdx = 0;
    for (let i = 0; i < 5; i++) {
      const cx = cardStartX + i * cardSpacing;
      const cy = cardY;
      if (pokerHeld[i]) {
        // Held cards stay face up
        if (pokerHand[i]) drawCard(cx, cy, pokerHand[i], cardW, cardH);
        drawRect(cx, cy + cardH + 2, cardW, 18, '#ffd700');
        drawText('TIENI', cx + cardW/2, cy + cardH + 16, '#000', 10, 'center');
      } else {
        // Non-held cards: flip animation (back → squeeze → face)
        const flipDelay = redrawIdx * 6; // stagger each redrawn card by 6 frames
        const flipProgress = Math.max(0, (35 - pokerRedrawAnim) - flipDelay);
        const flipDuration = 14;
        if (flipProgress <= 0) {
          // Still showing back
          drawCardBack(cx, cy, cardW, cardH);
        } else if (flipProgress < flipDuration / 2) {
          // Squeezing down (card narrows to center)
          const t = flipProgress / (flipDuration / 2);
          const squeeze = 1 - t;
          const sw = Math.max(2, cardW * squeeze);
          const sx = cx + (cardW - sw) / 2;
          drawCardBack(sx, cy, sw, cardH);
        } else if (flipProgress < flipDuration) {
          // Expanding back (showing face)
          const t = (flipProgress - flipDuration / 2) / (flipDuration / 2);
          const squeeze = t;
          const sw = Math.max(2, cardW * squeeze);
          const sx = cx + (cardW - sw) / 2;
          if (pokerHand[i]) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(sx, cy, sw, cardH);
            ctx.clip();
            drawCard(cx, cy, pokerHand[i], cardW, cardH);
            ctx.restore();
          }
        } else {
          // Fully revealed
          if (pokerHand[i]) drawCard(cx, cy, pokerHand[i], cardW, cardH);
        }
        redrawIdx++;
      }
    }
    // Transition to result when animation finishes
    if (pokerRedrawAnim <= 0) {
      pokerResult = evaluatePokerHand(pokerHand);
      const mult = POKER_PAYOUTS[pokerResult] || 0;
      pokerWinAmount = mult * pokerBet;
      coins += pokerWinAmount;
      pokerPhase = 'result';
      pokerResultTimer = 180;
      if (pokerWinAmount >= pokerBet * 10) {
        pokerNpcComment = getAndreinoComment('bigwin');
      } else if (pokerWinAmount > 0) {
        pokerNpcComment = getAndreinoComment('win');
      } else {
        pokerNpcComment = getAndreinoComment('lose');
      }
      pokerNpcCommentTimer = 180;
      if (pokerWinAmount > 0) {
        playSFX('coin');
        spawnParticles(cardStartX + totalCardsW/2, cardY + 40, '#ffd700', 20, 5);
      } else {
        playSFX('hurt');
      }
    }

  } else if (pokerPhase === 'result') {
    pokerResultTimer--;
    for (let i = 0; i < 5; i++) {
      if (pokerHand[i]) drawCard(cardStartX + i * cardSpacing, cardY, pokerHand[i], cardW, cardH);
    }
    const bounce = Math.sin(pokerResultTimer * 0.12) * 5;
    const resY = cardY + cardH + 20;
    const resCenterX = cardStartX + totalCardsW / 2;
    if (pokerWinAmount > 0) {
      // Win glow
      ctx.globalAlpha = 0.08 + Math.sin(pokerResultTimer * 0.1) * 0.04;
      drawRect(tableX, panelY, tableW, H - panelY - 50, '#ffd700');
      ctx.globalAlpha = 1;
      drawText(pokerResult + '!', resCenterX, resY + bounce, '#ffd700', 20, 'center');
      drawText('+' + pokerWinAmount + ' COINS', resCenterX, resY + 24, '#4caf50', 16, 'center');
    } else {
      drawText('Niente...', resCenterX, resY + bounce, '#e94560', 20, 'center');
      drawText('Riprova!', resCenterX, resY + 24, '#888', 12, 'center');
    }

    if (pokerResultTimer <= 0 || keysJustPressed['Enter'] || mouseClick) {
      pokerPhase = 'idle';
      pokerNpcComment = '';
      mouseClick = false;
    }
  }
}

// --- Slot Machine ---
function drawSlotMachine(panelY) {
  // NPC column (left side)
  const npcX = 20, npcW = 140;
  drawRect(npcX, panelY, npcW, H - panelY - 50, 'rgba(0,0,0,0.3)');
  drawRect(npcX + npcW, panelY, 2, H - panelY - 50, '#ff9800');

  // Draw NPC centered in column
  drawPandaNpc(npcX + 36, panelY + 120);
  // NPC name plate
  drawRect(npcX + 10, panelY + 6, npcW - 20, 22, 'rgba(0,0,0,0.6)');
  drawRect(npcX + 10, panelY + 6, npcW - 20, 2, '#ff9800');
  drawText('PANDA', npcX + npcW/2, panelY + 22, '#ff9800', 10, 'center');

  // NPC comment bubble
  if (slotNpcCommentTimer > 0) {
    slotNpcCommentTimer--;
    drawCasinoBubble(npcX + npcW/2, panelY + 110, slotNpcComment, 190, '#ff9800');
  } else if (slotPhase === 'idle') {
    if (gameTime % 360 === 0) slotNpcComment = getPandaComment('idle');
    if (slotNpcComment) drawCasinoBubble(npcX + npcW/2, panelY + 110, slotNpcComment, 190, '#ff9800');
  }

  // Main area
  const areaX = npcX + npcW + 8;
  const areaW = W - areaX - 10;

  // Slot machine frame — wide
  const machW = areaW - 20, machH = 260;
  const machX = areaX + 10;
  const machY = panelY + 4;
  // Outer frame (gray metal)
  drawRect(machX - 8, machY - 8, machW + 16, machH + 16, '#555');
  drawRect(machX - 6, machY - 6, machW + 12, machH + 12, '#666');
  drawRect(machX - 4, machY - 4, machW + 8, machH + 8, '#757575');
  // Gold trim
  drawRect(machX - 8, machY - 8, machW + 16, 4, '#ffd700');
  drawRect(machX - 8, machY + machH + 4, machW + 16, 4, '#ffd700');
  drawRect(machX - 8, machY - 8, 4, machH + 16, '#c9a900');
  drawRect(machX + machW + 4, machY - 8, 4, machH + 16, '#c9a900');
  // Machine body
  drawRect(machX, machY, machW, machH, '#1a1a1a');
  // Machine title
  drawRect(machX + 20, machY + 6, machW - 40, 24, 'rgba(0,0,0,0.5)');
  drawText('SLOT UBALDI', machX + machW/2, machY + 22, '#ffd700', 14, 'center');

  // Decorative lights on top
  for (let li = 0; li < 8; li++) {
    const lx = machX + 30 + li * 42;
    const on = (Math.floor(gameTime / 10) + li) % 3 === 0;
    drawRect(lx, machY - 4, 6, 4, on ? '#ffd700' : '#555');
  }

  // Reel window
  const reelY = machY + 38;
  const reelH = 150;
  drawRect(machX + 20, reelY, machW - 40, reelH, '#0a0a0a');
  drawRect(machX + 20, reelY, machW - 40, 2, '#444');
  drawRect(machX + 20, reelY + reelH - 2, machW - 40, 2, '#444');
  // Reel dividers
  const reelSlotW = Math.floor((machW - 40) / 3);
  drawRect(machX + 20 + reelSlotW, reelY, 2, reelH, '#333');
  drawRect(machX + 20 + reelSlotW * 2, reelY, 2, reelH, '#333');
  // Red payline indicator
  drawRect(machX + 15, reelY + reelH/2 - 2, machW - 30, 4, 'rgba(233,69,96,0.4)');
  // Payline arrows
  drawText('\u25B6', machX + 12, reelY + reelH/2 + 5, '#e94560', 12);
  drawText('\u25C0', machX + machW - 20, reelY + reelH/2 + 5, '#e94560', 12);

  // Draw reels
  for (let r = 0; r < 3; r++) {
    const rx = machX + 25 + r * reelSlotW;
    const ry = reelY + 8;
    const rw = reelSlotW - 8;

    if (slotPhase === 'spinning' && slotSpinTimers[r] > 0) {
      slotSpinTimers[r]--;
      const speed = slotSpinTimers[r] < 10 ? 5 : 2;
      const symIdx = Math.floor(gameTime / speed) % SLOT_SYMBOLS.length;
      const sym = SLOT_SYMBOLS[symIdx];
      drawText(sym.symbol, rx + rw/2, ry + 82, sym.color, 68, 'center');

      if (slotSpinTimers[r] <= 0) {
        slotReels[r] = slotTargetReels[r];
        playSFX('hit');
        if (slotSpinTimers.every(t => t <= 0)) {
          const r0 = slotReels[0], r1 = slotReels[1], r2 = slotReels[2];
          if (r0 === r1 && r1 === r2) {
            slotResult = '3x ' + SLOT_SYMBOLS[r0].name;
            slotWinAmount = SLOT_PAYOUTS_3[r0] * slotBet;
          } else if (r0 === r1) {
            slotResult = '2x ' + SLOT_SYMBOLS[r0].name;
            slotWinAmount = SLOT_PAYOUTS_2[r0] * slotBet;
          } else if (r1 === r2) {
            slotResult = '2x ' + SLOT_SYMBOLS[r1].name;
            slotWinAmount = SLOT_PAYOUTS_2[r1] * slotBet;
          } else if (r0 === r2) {
            slotResult = '2x ' + SLOT_SYMBOLS[r0].name;
            slotWinAmount = SLOT_PAYOUTS_2[r0] * slotBet;
          } else {
            slotResult = 'Niente';
            slotWinAmount = 0;
          }
          coins += slotWinAmount;
          slotPhase = 'result';
          slotResultTimer = 150;
          if (slotWinAmount >= slotBet * 15) {
            slotNpcComment = getPandaComment('bigwin');
          } else if (slotWinAmount > 0) {
            slotNpcComment = getPandaComment('win');
          } else {
            slotNpcComment = getPandaComment('lose');
          }
          slotNpcCommentTimer = 150;
          if (slotWinAmount > 0) {
            playSFX('coin');
            spawnParticles(machX + machW/2, reelY + reelH/2, '#ffd700', 25, 5);
          } else {
            playSFX('hurt');
          }
        }
      }
    } else {
      const sym = SLOT_SYMBOLS[slotReels[r]];
      drawText(sym.symbol, rx + rw/2, ry + 82, sym.color, 68, 'center');
      drawText(sym.name, rx + rw/2, ry + 105, '#777', 11, 'center');
    }
  }

  // Controls area below machine
  const ctrlY = machY + machH + 14;

  if (slotPhase === 'idle') {
    // Bet controls
    drawText('PUNTATA: ' + slotBet, machX + machW/2, ctrlY + 16, '#ffd700', 16, 'center');

    const minusBx = machX + machW/2 - 100;
    const plusBx = machX + machW/2 + 65;
    const minusHover = mouseX > minusBx && mouseX < minusBx + 36 && mouseY > ctrlY && mouseY < ctrlY + 28;
    const plusHover = mouseX > plusBx && mouseX < plusBx + 36 && mouseY > ctrlY && mouseY < ctrlY + 28;
    drawRect(minusBx, ctrlY, 36, 28, minusHover ? '#555' : '#333');
    drawRect(minusBx, ctrlY, 36, 2, '#666');
    drawText('<', minusBx + 18, ctrlY + 19, '#fff', 16, 'center');
    drawRect(plusBx, ctrlY, 36, 28, plusHover ? '#555' : '#333');
    drawRect(plusBx, ctrlY, 36, 2, '#666');
    drawText('>', plusBx + 18, ctrlY + 19, '#fff', 16, 'center');

    if ((minusHover && mouseClick) || keysJustPressed['ArrowLeft']) {
      slotBet = Math.max(SLOT_BET_MIN, slotBet - SLOT_BET_STEP);
      mouseClick = false;
    }
    if ((plusHover && mouseClick) || keysJustPressed['ArrowRight']) {
      slotBet = Math.min(SLOT_BET_MAX, slotBet + SLOT_BET_STEP);
      mouseClick = false;
    }

    // Spin button
    const canSpin = coins >= slotBet;
    const spinY = ctrlY + 36;
    const spinBx = machX + machW/2 - 110;
    const spinBw = 220;
    const spinHover = mouseX > spinBx && mouseX < spinBx + spinBw && mouseY > spinY && mouseY < spinY + 40;
    drawRect(spinBx, spinY, spinBw, 40, canSpin ? (spinHover ? '#e65100' : '#bf360c') : '#333');
    drawRect(spinBx, spinY, spinBw, 3, canSpin ? '#ff6e40' : '#555');
    drawText('GIRA! [ENTER]', machX + machW/2, spinY + 27, canSpin ? '#fff' : '#666', 15, 'center');

    if (canSpin && ((spinHover && mouseClick) || keysJustPressed['Enter'])) {
      coins -= slotBet;
      slotPhase = 'spinning';
      slotSpinTimers = [30 + Math.floor(Math.random() * 15), 50 + Math.floor(Math.random() * 15), 70 + Math.floor(Math.random() * 15)];
      slotTargetReels = [
        Math.floor(Math.random() * SLOT_SYMBOLS.length),
        Math.floor(Math.random() * SLOT_SYMBOLS.length),
        Math.floor(Math.random() * SLOT_SYMBOLS.length)
      ];
      slotNpcComment = '';
      slotNpcCommentTimer = 0;
      playSFX('hit');
      mouseClick = false;
    } else if (!canSpin && ((spinHover && mouseClick) || keysJustPressed['Enter'])) {
      slotNpcComment = getPandaComment('broke');
      slotNpcCommentTimer = 180;
      mouseClick = false;
    }
  } else if (slotPhase === 'result') {
    slotResultTimer--;
    const bounce = Math.sin(slotResultTimer * 0.12) * 4;
    if (slotWinAmount > 0) {
      // Win glow on machine
      ctx.globalAlpha = 0.08 + Math.sin(slotResultTimer * 0.1) * 0.04;
      drawRect(machX, machY, machW, machH, '#ffd700');
      ctx.globalAlpha = 1;
      drawText(slotResult + '!', machX + machW/2, ctrlY + 10 + bounce, '#ffd700', 20, 'center');
      drawText('+' + slotWinAmount + ' COINS', machX + machW/2, ctrlY + 34, '#4caf50', 16, 'center');
    } else {
      drawText('Niente...', machX + machW/2, ctrlY + 10 + bounce, '#e94560', 20, 'center');
      drawText('Riprova!', machX + machW/2, ctrlY + 34, '#888', 12, 'center');
    }

    if (slotResultTimer <= 0 || keysJustPressed['Enter'] || mouseClick) {
      slotPhase = 'idle';
      slotNpcComment = '';
      mouseClick = false;
    }
  }

  // Payout table — compact horizontal strip below controls
  const ptY = ctrlY + 82;
  const ptX = machX;
  const ptW = machW;
  drawRect(ptX, ptY, ptW, 46, 'rgba(0,0,0,0.5)');
  drawRect(ptX, ptY, ptW, 2, '#ff9800');
  // 3-of-a-kind payouts in a row
  let px3 = ptX + 6;
  drawText('3x:', px3, ptY + 16, '#ffd700', 11);
  px3 += 28;
  for (let i = 0; i < SLOT_SYMBOLS.length; i++) {
    if (SLOT_PAYOUTS_3[i] === 0) continue;
    const sym = SLOT_SYMBOLS[i];
    drawText(sym.symbol + SLOT_PAYOUTS_3[i] + 'x', px3, ptY + 16, sym.color, 11);
    px3 += 56;
  }
  // 2-of-a-kind payouts in a row
  let px2 = ptX + 6;
  drawText('2x:', px2, ptY + 36, '#aaa', 11);
  px2 += 28;
  for (let i = 0; i < SLOT_SYMBOLS.length; i++) {
    if (SLOT_PAYOUTS_2[i] === 0) continue;
    const sym = SLOT_SYMBOLS[i];
    drawText(sym.symbol + SLOT_PAYOUTS_2[i] + 'x', px2, ptY + 36, sym.color, 11);
    px2 += 56;
  }
}

// ==========================================
// UPGRADE SELECTION (after level victory)
// ==========================================
let upgradeSelection = 0;

function calculateLevelGrade() {
  const parTime = 3600 + currentLevel * 600; // 60s base + 10s per level
  const elapsed = gameTime - levelStartTime;
  const timeBonus = elapsed < parTime ? 1.5 : elapsed < parTime * 1.5 ? 1.0 : 0.7;
  const dmgRatio = Math.min(1, levelDamageTaken / player.maxHp);
  const finalScore = Math.floor((levelScore + stylePoints) * (1 - dmgRatio * 0.3) * timeBonus);
  const maxPossible = (totalKills * 100 + 500) * 1.5; // rough estimate
  const pct = Math.min(1, finalScore / Math.max(1, maxPossible));

  let grade, gradeColor;
  if (pct >= 0.95) { grade = 'S'; gradeColor = '#ffd700'; }
  else if (pct >= 0.80) { grade = 'A'; gradeColor = '#4caf50'; }
  else if (pct >= 0.60) { grade = 'B'; gradeColor = '#2196f3'; }
  else if (pct >= 0.40) { grade = 'C'; gradeColor = '#ff9800'; }
  else { grade = 'D'; gradeColor = '#f44336'; }

  lastLevelGrade = grade;
  lastLevelBreakdown = {
    score: finalScore,
    kills: totalKills,
    dmgTaken: Math.floor(levelDamageTaken),
    timeBonus: timeBonus,
    grade: grade,
    gradeColor: gradeColor,
    elapsed: Math.floor(elapsed / 60)
  };
  return grade;
}

function generateUpgradeChoices() {
  // Grade-based rewards: more choices for better grades
  const grade = lastLevelGrade;
  const gradeBonus = { S: 75, A: 45, B: 25, C: 10, D: 0 };
  const bonus = gradeBonus[grade] || 0;
  if (bonus > 0) {
    coins += bonus;
    spawnParticles(W/2, 80, '#ffd700', bonus > 20 ? 20 : 10, 4);
  }
  lastLevelBreakdown.coinBonus = bonus;

  // Pick upgrades not already owned — S/A get 4 choices, others get 3
  const numChoices = (grade === 'S' || grade === 'A') ? 4 : 3;
  const owned = player.upgrades.map(u => u.effect);
  let available = UPGRADE_POOL.filter(u => !owned.includes(u.effect));

  // S grade: bias toward mossa/mod upgrades (the powerful ones)
  if (grade === 'S' && available.length > numChoices) {
    const powerful = available.filter(u => u.cat === 'mossa' || u.cat === 'mod');
    const basic = available.filter(u => u.cat === 'stat');
    // Guarantee at least 1 powerful if available
    if (powerful.length > 0) {
      const shuffledPowerful = powerful.sort(() => Math.random() - 0.5);
      const shuffledBasic = basic.sort(() => Math.random() - 0.5);
      available = [...shuffledPowerful, ...shuffledBasic];
    }
  } else {
    available = available.sort(() => Math.random() - 0.5);
  }

  upgradeChoices = [];
  for (let i = 0; i < Math.min(numChoices, available.length); i++) {
    upgradeChoices.push(available[i]);
  }
  upgradeSelection = 0;
}

function applyUpgrade(upgrade) {
  player.upgrades.push(upgrade);
  switch(upgrade.effect) {
    case 'dmg15': break; // applied in damage calc
    case 'hp20': player.maxHp += 20; player.hp = Math.min(player.hp + 20, player.maxHp); break;
    case 'st20': player.maxStamina += 20; player.stamina += 20; break;
    case 'stregen': break; // applied in regen calc
    case 'spd10': player.speed *= 1.1; break;
    case 'crit15': break; // applied in crit calc
    case 'armor15': break; // applied in hurtPlayer
    case 'poise25': break; // applied in attack calc
    case 'comboext': weapons[0].comboHits++; break;
    // move/mod effects are checked during gameplay
  }
}

function drawUpgradeScreen() {
  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, '#0d0d1a');
  bgGrad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  // Category labels
  const catLabels = { stat: 'STATISTICA', mossa: 'MOSSA', mod: 'ULTRA MOD' };

  // Level grade display — compact top bar
  if (lastLevelBreakdown) {
    const b = lastLevelBreakdown;
    // Grade circle
    ctx.beginPath();
    ctx.arc(55, 36, 24, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fill();
    ctx.strokeStyle = b.gradeColor;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.lineWidth = 1;
    drawText(b.grade, 55, 44, b.gradeColor, 26, 'center');
    // Stats next to grade
    drawText('Punteggio: ' + b.score + '  |  Tempo: ' + b.elapsed + 's  |  Danno: ' + b.dmgTaken, 90, 28, '#999', 9);
    drawText('Bonus tempo: x' + b.timeBonus.toFixed(1) + (b.coinBonus > 0 ? '  |  +' + b.coinBonus + ' COINS' : ''), 90, 44, b.coinBonus > 0 ? '#ffd700' : '#777', 9);
  }

  // Title
  drawText('SCEGLI UN POTENZIAMENTO', W/2, 75, '#ffd700', 20, 'center');

  // Keyboard nav
  if (keysJustPressed['ArrowLeft'] || keysJustPressed['KeyA']) upgradeSelection = Math.max(0, upgradeSelection - 1);
  if (keysJustPressed['ArrowRight'] || keysJustPressed['KeyD']) upgradeSelection = Math.min(upgradeChoices.length - 1, upgradeSelection + 1);

  // Dynamic layout
  const nc = upgradeChoices.length;
  const cw = nc <= 3 ? 220 : 195;
  const ch = 310;
  const spacing = nc <= 3 ? 235 : 210;
  const startX = Math.floor((W - nc * spacing + (spacing - cw)) / 2);
  const cardY = 92;

  for (let i = 0; i < upgradeChoices.length; i++) {
    const u = upgradeChoices[i];
    const cx = startX + i * spacing;
    const isHover = mouseX > cx && mouseX < cx + cw && mouseY > cardY && mouseY < cardY + ch;
    const isSelected = i === upgradeSelection;
    const accent = u.color || '#fff';

    if (isHover && (mouseX !== 0 || mouseY !== 0)) upgradeSelection = i;

    // Card background
    ctx.globalAlpha = isSelected ? 1 : 0.55;
    drawRect(cx, cardY, cw, ch, isSelected ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.3)');
    // Top accent bar
    drawRect(cx, cardY, cw, 3, accent);

    // Selection border
    if (isSelected) {
      const pulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
      drawRect(cx, cardY + ch - 3, cw, 3, accent);
      drawRect(cx, cardY, 3, ch, accent);
      drawRect(cx + cw - 3, cardY, 3, ch, accent);
      ctx.strokeStyle = accent;
      ctx.lineWidth = 1 + pulse;
      ctx.strokeRect(cx - 1, cardY - 1, cw + 2, ch + 2);
      ctx.lineWidth = 1;
    }

    // Icon — circle background
    const iconCx = cx + cw / 2, iconCy = cardY + 45;
    ctx.beginPath();
    ctx.arc(iconCx, iconCy, 26, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fill();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.lineWidth = 1;
    drawText(u.icon, iconCx, iconCy + 10, accent, 28, 'center');

    // Category tag
    drawText(catLabels[u.cat] || u.cat.toUpperCase(), cx + cw / 2, cardY + 84, accent, 8, 'center');

    // Separator
    drawRect(cx + 20, cardY + 92, cw - 40, 1, 'rgba(255,255,255,0.08)');

    // Name
    drawText(u.name, cx + cw / 2, cardY + 112, '#fff', 13, 'center');

    // Description — proper word wrap
    const maxChars = Math.floor(cw / 6);
    const words = u.desc.split(' ');
    let line = '', lineY = cardY + 138;
    words.forEach(w => {
      const test = line + w + ' ';
      if (test.length > maxChars && line.length > 0) {
        drawText(line.trim(), cx + cw / 2, lineY, '#bbb', 9, 'center');
        lineY += 14;
        line = w + ' ';
      } else {
        line = test;
      }
    });
    if (line.trim()) drawText(line.trim(), cx + cw / 2, lineY, '#bbb', 9, 'center');

    ctx.globalAlpha = 1;

    // Click/tap to highlight
    if (isHover && mouseClick) upgradeSelection = i;
  }

  // Confirm button
  const selUpgrade = upgradeChoices[upgradeSelection];
  const selColor = selUpgrade?.color || '#ffd700';
  const confirmW = 220, confirmH = 40;
  const confirmX = W / 2 - confirmW / 2, confirmY = cardY + ch + 15;
  const confirmHover = mouseX >= confirmX && mouseX <= confirmX + confirmW && mouseY >= confirmY && mouseY <= confirmY + confirmH;
  const pulse = Math.sin(gameTime * 0.06) * 0.3 + 0.7;
  ctx.globalAlpha = pulse;
  drawRect(confirmX, confirmY, confirmW, confirmH, confirmHover ? selColor : 'rgba(255,255,255,0.08)');
  drawRect(confirmX, confirmY, confirmW, 2, selColor);
  drawText('CONFERMA', W / 2, confirmY + 27, confirmHover ? '#1a1a2e' : '#fff', 16, 'center');
  ctx.globalAlpha = 1;

  // Enter/Space/click confirm button to apply
  const confirmTap = confirmHover && mouseClick;
  if (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || confirmTap) {
    if (selUpgrade) {
      applyUpgrade(selUpgrade);
      state = 'hub';
    }
  }

  // Show owned upgrades as colored icons
  if (player.upgrades.length > 0) {
    const ownedX = W / 2 - player.upgrades.length * 14;
    drawText('Ottenuti:', ownedX - 40, H - 22, '#555', 8);
    for (let j = 0; j < player.upgrades.length; j++) {
      const ou = player.upgrades[j];
      drawText(ou.icon, ownedX + j * 28, H - 22, ou.color || '#888', 14);
    }
  }

  // Nav hint
  drawText('\u2190 \u2192 naviga  |  ENTER conferma', W / 2, H - 6, '#333', 8, 'center');

  mouseClick = false;
}

// ==========================================
// START LEVEL
// ==========================================
let isReplayLevel = false; // true if replaying a beaten level

function startLevel(idx) {
  currentLevel = idx;
  hubVisitInited = false; // reset hub visit flag so secrets reset next visit
  isReplayLevel = bossDefeated[idx]; // track if this was already beaten
  // medium + hard: lives carry over; easy: infinite (lives never decremented)
  state = 'dialogue';
  resetPlayer();
  player.x = 100;
  boss = null;
  goons = [];
  projectiles = [];
  particles = [];
  damageNumbers = [];
  coinPickups = [];
  reginaActive = false;
  regina = null;
  mariusoActive = false;
  mariuso = null;
  activeHelperVisuals = [];
  bossIntro = false;
  bossIntroTimer = 0;
  waveClearTimer = 0;
  waveBreatherTimer = 0;
  levelTimer = 0;
  comboCount = 0;
  comboTimer = 0;
  helperCooldowns = [0, 0, 0, 0];
  helperReviveUsed = false;
  warCryTimer = 0;
  warCryCooldown = 0;
  levelDamageTaken = 0;
  levelScore = 0;
  stylePoints = 0;
  levelStartTime = gameTime;
  initHazards(idx);
  // Wave configs: L0: 2+2, L1: 2+2+2, L2: 2+3+2, L3: 3+3+2, L4: 3+3+3
  const WAVE_CONFIGS = [[3,3],[3,3,3],[3,4,3],[4,3,3],[4,4,3]];
  waveConfig = WAVE_CONFIGS[idx] || [3,3];
  currentWave = 0;

  const lvl = levels[idx];
  dialogueLines = [
    '[ ' + lvl.name.toUpperCase() + ' ]',
    lvl.subtitle,
    '---',
    ...lvl.bossLines
  ];
  dialogueIndex = 0;
  dialogueCallback = () => {
    state = 'level';
    spawnGoons(waveConfig[0] || 2); // Spawn first wave
    currentWave = 1;
    showQuickText('WAVE 1/' + waveConfig.length, '#ff9800');
    boss = createBoss(idx);
    boss.x = W + 100; // Boss enters after all waves cleared
  };
}

// ==========================================
// DIALOGUE
// ==========================================
let dialogueCooldown = 0;

function drawDialogue() {
  // Show level background
  drawLevelBg();

  // Darken
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, W, H);

  // Dialogue box
  const dlgY = isTouchDevice ? 200 : H - 160;
  drawRect(50, dlgY, W - 100, 120, 'rgba(20,20,40,0.95)');
  drawRect(50, dlgY, W - 100, 3, '#e94560');

  if (dialogueIndex < dialogueLines.length) {
    const line = dialogueLines[dialogueIndex];
    drawText(line, W/2, dlgY + 60, '#fff', 16, 'center');

    if (Math.floor(gameTime / 30) % 2 === 0) {
      drawText('[ENTER]', W/2, dlgY + 100, '#888', 11, 'center');
    }

    dialogueCooldown = Math.max(0, dialogueCooldown - 1);
    if ((keysJustPressed['Enter'] || mouseClick) && dialogueCooldown === 0) {
      dialogueIndex++;
      dialogueCooldown = 15;
      mouseClick = false;
    }
  } else {
    if (dialogueCallback) dialogueCallback();
  }

  mouseClick = false;
}

// ==========================================
// LEVEL BACKGROUND
// ==========================================
function drawLevelBg() {
  const lvl = levels[currentLevel];
  ctx.fillStyle = lvl.bgColor;
  ctx.fillRect(0, 0, W, H);

  switch(currentLevel) {
    case 0: drawBgViaPlava(); break;
    case 1: drawBgDownUnder(); break;
    case 2: drawBgPiazzaBainsizza(); break;
    case 3: drawBgPizzeria(); break;
    case 4: drawBgPiazzaMazzini(); break;
  }

  // Street sign (always) — below player info panel
  drawRect(8, 98, 195, 22, 'rgba(0,0,0,0.75)');
  drawRect(8, 98, 195, 2, '#fff');
  drawText(lvl.name.toUpperCase(), 105, 114, '#fff', 11, 'center');

  // Ground
  drawRect(0, GROUND_Y, W, H - GROUND_Y, lvl.groundColor);
  drawRect(0, GROUND_Y, W, 3, shadeColor(lvl.groundColor, 30));
}

// Via Plava - residential Roman street with palazzi
function drawBgViaPlava() {
  // Sky gradient - deep evening
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#0d0d25');
  sky.addColorStop(1, '#1a1a38');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Roman palazzi - darker ochre/terracotta for contrast with characters
  const buildings = [
    { x: -20, w: 200, h: 260, color: '#7a6540' },
    { x: 190, w: 180, h: 240, color: '#856d48' },
    { x: 380, w: 160, h: 280, color: '#6e5838' },
    { x: 550, w: 200, h: 250, color: '#7a6540' },
    { x: 760, w: 180, h: 270, color: '#856d48' }
  ];
  buildings.forEach(b => {
    drawRect(b.x, GROUND_Y - b.h, b.w, b.h, b.color);
    drawRect(b.x, GROUND_Y - b.h, b.w, 6, shadeColor(b.color, -20));
    // Windows (simplified for performance — fewer, bigger)
    for (let row = 0; row < Math.min(3, Math.floor(b.h / 80)); row++) {
      for (let col = 0; col < Math.min(2, Math.floor(b.w / 70)); col++) {
        const wx = b.x + 20 + col * 70;
        const wy = GROUND_Y - b.h + 25 + row * 80;
        drawRect(wx, wy, 28, 36, '#1a1a2e');
        drawRect(wx - 3, wy, 3, 36, '#2e7d32');
        drawRect(wx + 28, wy, 3, 36, '#2e7d32');
        if ((row + col) % 2 === 0) {
          ctx.globalAlpha = 0.35;
          drawRect(wx + 2, wy + 2, 24, 32, '#fff9c4');
          ctx.globalAlpha = 1;
        }
      }
    }
  });
  // Laundry lines between buildings
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(180, GROUND_Y - 180);
  ctx.lineTo(390, GROUND_Y - 190);
  ctx.stroke();
  // Clothes
  const clothes = ['#e53935','#1e88e5','#fff','#ffb300'];
  for (let i = 0; i < 4; i++) {
    drawRect(200 + i * 45, GROUND_Y - 185 + Math.sin(gameTime*0.02+i)*3, 15, 20, clothes[i]);
  }
  // Street lamps
  [80, 500, 830].forEach(lx => {
    drawRect(lx, GROUND_Y - 100, 4, 100, '#424242');
    drawRect(lx - 8, GROUND_Y - 105, 20, 6, '#616161');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx * 0.1) * 0.1;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx + 2, GROUND_Y - 110, 16, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Parked Vespa
  drawRect(650, GROUND_Y - 30, 40, 20, '#1e88e5'); // body
  drawRect(645, GROUND_Y - 38, 12, 12, '#1565c0'); // handlebar
  drawRect(640, GROUND_Y - 12, 14, 12, '#424242'); // front wheel
  drawRect(680, GROUND_Y - 12, 14, 12, '#424242'); // back wheel
  drawRect(660, GROUND_Y - 42, 4, 8, '#90a4ae'); // mirror

  // Trash bins
  drawRect(42, GROUND_Y - 28, 18, 28, '#424242');
  drawRect(40, GROUND_Y - 30, 22, 4, '#616161');

  // Stray cat (small pixel silhouette, subtle animation)
  const catX = 280, catY = GROUND_Y - 10;
  const catBob = Math.sin(gameTime * 0.02) * 1;
  drawRect(catX, catY + catBob - 8, 12, 8, '#333'); // body
  drawRect(catX + 10, catY + catBob - 12, 6, 6, '#333'); // head
  drawRect(catX + 10, catY + catBob - 15, 2, 4, '#333'); // ear
  drawRect(catX + 14, catY + catBob - 15, 2, 4, '#333'); // ear
  drawRect(catX - 4, catY + catBob - 6, 6, 2, '#333'); // tail
  ctx.globalAlpha = 0.8;
  drawRect(catX + 12, catY + catBob - 10, 2, 2, '#76ff03'); // eye
  ctx.globalAlpha = 1;

  // Cobblestone hint on ground
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = 0.15;
    drawRect(i * 32, GROUND_Y + 5, 28, 12, '#5d4037');
    ctx.globalAlpha = 1;
  }
}

// Down Under Pub - interior
function drawBgDownUnder() {
  // Dark pub interior
  ctx.fillStyle = '#1b1b2b';
  ctx.fillRect(0, 0, W, GROUND_Y);
  // Brick wall (reduced density for performance)
  ctx.globalAlpha = 0.15;
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 10; col++) {
      const offset = row % 2 === 0 ? 0 : 50;
      drawRect(col * 100 + offset, row * 42 + 30, 92, 36, '#8d6e63');
    }
  }
  ctx.globalAlpha = 1;
  // Bar counter
  drawRect(0, GROUND_Y - 90, W, 10, '#4e342e');
  drawRect(0, GROUND_Y - 80, W, 80, '#3e2723');
  // Beer taps
  for (let i = 0; i < 5; i++) {
    drawRect(80 + i * 180, GROUND_Y - 120, 8, 35, '#ffd54f');
    drawRect(75 + i * 180, GROUND_Y - 125, 18, 8, '#ffc107');
  }
  // Bottles on shelf
  drawRect(0, GROUND_Y - 160, W, 6, '#5d4037');
  const bottleColors = ['#4caf50','#f44336','#2196f3','#ff9800','#4caf50','#9c27b0','#f44336','#ffeb3b','#4caf50','#2196f3','#ff9800','#9c27b0'];
  bottleColors.forEach((c, i) => {
    drawRect(30 + i * 72, GROUND_Y - 190, 10, 30, c);
    drawRect(28 + i * 72, GROUND_Y - 192, 14, 4, c);
  });
  // Neon signs
  const glow = 0.5 + Math.sin(gameTime * 0.03) * 0.3;
  ctx.globalAlpha = glow;
  drawText('DOWN UNDER', W/2, 80, '#00e5ff', 22, 'center');
  drawText('PUB', W/2, 105, '#ff1744', 18, 'center');
  ctx.globalAlpha = 1;
  // Dartboard
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(780, 160, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#d32f2f';
  ctx.beginPath();
  ctx.arc(780, 160, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(780, 160, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#d32f2f';
  ctx.beginPath();
  ctx.arc(780, 160, 4, 0, Math.PI * 2);
  ctx.fill();
  // Hanging pendant lights
  [150, 350, 550, 750].forEach(lx => {
    drawRect(lx, 0, 1, 45, '#555');
    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 0.025 + lx * 0.1) * 0.08;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath(); ctx.arc(lx, 50, 18, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    drawRect(lx - 6, 44, 12, 8, '#ff8f00');
  });

  // Band posters on wall
  drawRect(30, 130, 50, 65, '#1a237e');
  drawText('LIVE', 55, 155, '#f44336', 8, 'center');
  drawText('MUSIC', 55, 168, '#fff', 7, 'center');
  drawRect(840, 140, 45, 55, '#b71c1c');
  drawText('PUB', 862, 160, '#fff', 7, 'center');
  drawText('QUIZ', 862, 175, '#ffd700', 7, 'center');

  // Pool table (background, behind counter)
  drawRect(300, GROUND_Y - 140, 100, 55, '#1b5e20');
  drawRect(296, GROUND_Y - 144, 108, 4, '#5d4037');
  drawRect(296, GROUND_Y - 89, 108, 4, '#5d4037');
  drawRect(296, GROUND_Y - 140, 4, 55, '#5d4037');
  drawRect(400, GROUND_Y - 140, 4, 55, '#5d4037');
  // Pool balls
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(330, GROUND_Y - 115, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#f44336'; ctx.beginPath(); ctx.arc(350, GROUND_Y - 120, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(365, GROUND_Y - 110, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1565c0'; ctx.beginPath(); ctx.arc(380, GROUND_Y - 118, 3, 0, Math.PI * 2); ctx.fill();

  // Stools
  for (let i = 0; i < 6; i++) {
    drawRect(60 + i * 140, GROUND_Y - 10, 30, 10, '#5d4037');
    drawRect(72 + i * 140, GROUND_Y, 6, 20, '#795548');
  }

  // Spilled drink stain (subtle)
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = '#795548';
  ctx.beginPath(); ctx.arc(420, GROUND_Y + 20, 15, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Wooden floor
  for (let i = 0; i < 12; i++) {
    ctx.globalAlpha = 0.1;
    drawRect(i * 80, GROUND_Y + 3, 76, H - GROUND_Y, '#8d6e63');
    ctx.globalAlpha = 1;
  }
}

// Piazza Bainsizza - open piazza with fountain
function drawBgPiazzaBainsizza() {
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#1a2030');
  sky.addColorStop(1, '#263248');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Stars
  for (let i = 0; i < 20; i++) {
    const sx = (i * 97) % W;
    const sy = (i * 41) % 120 + 10;
    ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.02 + i) * 0.2;
    drawRect(sx, sy, 2, 2, '#fff');
  }
  ctx.globalAlpha = 1;

  // Surrounding buildings - typical Roman
  const bColors = ['#c9a96e','#bfa47a','#d4a76a','#c9a96e'];
  [{ x: -10, w: 200 },{ x: 200, w: 150 },{ x: 600, w: 180 },{ x: 790, w: 150 }].forEach((b, i) => {
    const bh = 180 + (i * 30);
    drawRect(b.x, GROUND_Y - bh, b.w, bh, bColors[i]);
    for (let r = 0; r < 4; r++) for (let c = 0; c < 3; c++) {
      drawRect(b.x + 15 + c * 50, GROUND_Y - bh + 20 + r * 45, 22, 30, '#2a2a3e');
    }
  });

  // Fountain in center background
  drawRect(390, GROUND_Y - 60, 120, 60, '#78909c');
  drawRect(380, GROUND_Y - 30, 140, 8, '#90a4ae');
  drawRect(430, GROUND_Y - 100, 40, 45, '#90a4ae');
  // Water
  ctx.globalAlpha = 0.4;
  const waterY = Math.sin(gameTime * 0.05) * 2;
  drawRect(395, GROUND_Y - 25 + waterY, 110, 20, '#42a5f5');
  ctx.globalAlpha = 1;
  // Water spout
  if (gameTime % 10 < 7) {
    drawRect(448, GROUND_Y - 110, 4, 12, '#64b5f6');
  }

  // Trees
  [120, 350, 560, 780].forEach(tx => {
    drawRect(tx + 8, GROUND_Y - 50, 8, 50, '#5d4037');
    ctx.fillStyle = '#2e7d32';
    ctx.beginPath();
    ctx.arc(tx + 12, GROUND_Y - 65, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#388e3c';
    ctx.beginPath();
    ctx.arc(tx + 8, GROUND_Y - 55, 18, 0, Math.PI * 2);
    ctx.fill();
  });

  // Street lamps with warm glow
  [60, 280, 620, 850].forEach(lx => {
    drawRect(lx, GROUND_Y - 90, 4, 90, '#37474f');
    drawRect(lx - 6, GROUND_Y - 94, 16, 5, '#455a64');
    ctx.globalAlpha = 0.2 + Math.sin(gameTime * 0.03 + lx * 0.05) * 0.1;
    ctx.fillStyle = '#ffe0b2';
    ctx.beginPath(); ctx.arc(lx + 2, GROUND_Y - 98, 14, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Benches
  [200, 680].forEach(bx => {
    drawRect(bx, GROUND_Y - 20, 50, 6, '#5d4037'); // seat
    drawRect(bx + 2, GROUND_Y - 14, 4, 14, '#4e342e'); // leg
    drawRect(bx + 44, GROUND_Y - 14, 4, 14, '#4e342e'); // leg
    drawRect(bx, GROUND_Y - 32, 50, 4, '#5d4037'); // backrest
    drawRect(bx, GROUND_Y - 32, 2, 16, '#4e342e'); // back support
    drawRect(bx + 48, GROUND_Y - 32, 2, 16, '#4e342e');
  });

  // Pigeons (small pixel birds, subtle movement)
  [{ x: 150, d: 0 }, { x: 170, d: 1.5 }, { x: 500, d: 3 }, { x: 520, d: 4.5 }].forEach(p => {
    const bob = Math.sin(gameTime * 0.04 + p.d) * 1.5;
    const px = p.x + Math.sin(gameTime * 0.01 + p.d) * 3;
    drawRect(px, GROUND_Y - 6 + bob, 8, 5, '#78909c'); // body
    drawRect(px + 6, GROUND_Y - 9 + bob, 4, 4, '#90a4ae'); // head
    drawRect(px + 9, GROUND_Y - 8 + bob, 3, 1, '#ff8f00'); // beak
  });

  // Moon
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = '#e0e0e0';
  ctx.beginPath(); ctx.arc(780, 40, 18, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#263248';
  ctx.beginPath(); ctx.arc(786, 36, 16, 0, Math.PI * 2); ctx.fill(); // crescent shadow
  ctx.globalAlpha = 1;

  // Cobblestone piazza
  for (let i = 0; i < 40; i++) {
    ctx.globalAlpha = 0.12;
    const cx = (i * 47) % W;
    const cy = GROUND_Y + 5 + (i * 13) % 40;
    drawRect(cx, cy, 20, 10, '#607d8b');
    ctx.globalAlpha = 1;
  }
}

// Pizzarium - pizzeria exterior/interior
function drawBgPizzeria() {
  ctx.fillStyle = '#3e2723';
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Pizzeria building
  drawRect(0, 50, W, GROUND_Y - 50, '#5d4037');
  // Awning - Italian flag colors
  drawRect(0, 50, W, 15, '#009246');
  drawRect(0, 65, W, 15, '#fff');
  drawRect(0, 80, W, 15, '#ce2b37');

  // Sign
  drawRect(300, 100, 300, 40, '#b71c1c');
  drawText('PIZZARIUM', W/2, 126, '#ffd54f', 18, 'center');

  // Pizza oven in background
  drawRect(620, GROUND_Y - 150, 140, 150, '#4e342e');
  ctx.fillStyle = '#ff6f00';
  ctx.beginPath();
  ctx.arc(690, GROUND_Y - 100, 50, Math.PI, 0);
  ctx.fill();
  // Fire glow inside oven
  ctx.globalAlpha = 0.5 + Math.sin(gameTime * 0.1) * 0.3;
  ctx.fillStyle = '#ff3d00';
  ctx.beginPath();
  ctx.arc(690, GROUND_Y - 90, 35, Math.PI, 0);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Counter with pizzas
  drawRect(50, GROUND_Y - 60, 500, 12, '#795548');
  drawRect(50, GROUND_Y - 48, 500, 48, '#5d4037');
  // Pizza display (simplified — rects instead of arcs)
  for (let i = 0; i < 4; i++) {
    drawRect(100 + i * 120, GROUND_Y - 88, 40, 40, '#ffd54f');
    drawRect(108 + i * 120, GROUND_Y - 80, 6, 6, '#f44336');
    drawRect(120 + i * 120, GROUND_Y - 76, 6, 6, '#f44336');
    drawRect(114 + i * 120, GROUND_Y - 68, 6, 6, '#f44336');
  }

  // Checkered floor (reduced)
  ctx.globalAlpha = 0.15;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 10; c++) {
      drawRect(c * 100, GROUND_Y + r * 40, 50, 40, (r + c) % 2 === 0 ? '#fff' : '#d32f2f');
    }
  }
  ctx.globalAlpha = 1;

  // Menu board
  drawRect(30, 120, 120, 160, '#212121');
  drawText('MENU', 90, 145, '#fff', 12, 'center');
  drawText('Margherita  5E', 90, 165, '#ffd54f', 8, 'center');
  drawText('Diavola     7E', 90, 180, '#ffd54f', 8, 'center');
  drawText('Capricciosa 8E', 90, 195, '#ffd54f', 8, 'center');
  drawText('Pugni  GRATIS', 90, 215, '#f44336', 8, 'center');

  // Hanging garlic braids
  [200, 350, 500].forEach(gx => {
    drawRect(gx, 94, 2, 18, '#8d6e63');
    for (let g = 0; g < 3; g++) {
      ctx.fillStyle = '#f5f5dc';
      ctx.beginPath(); ctx.arc(gx + 1, 115 + g * 10, 5, 0, Math.PI * 2); ctx.fill();
    }
  });

  // Steam from oven (animated particles rising)
  for (let s = 0; s < 4; s++) {
    const sx = 675 + Math.sin(gameTime * 0.03 + s * 1.5) * 20;
    const sy = GROUND_Y - 155 - (gameTime * 0.5 + s * 30) % 60;
    ctx.globalAlpha = 0.08 + (1 - ((gameTime * 0.5 + s * 30) % 60) / 60) * 0.1;
    ctx.fillStyle = '#bdbdbd';
    ctx.beginPath(); ctx.arc(sx, sy, 8 + s * 2, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Hanging pepper lights (red string lights along awning)
  for (let i = 0; i < 15; i++) {
    const lx = 30 + i * 60;
    const bob = Math.sin(gameTime * 0.02 + i * 0.8) * 1;
    ctx.fillStyle = i % 3 === 0 ? '#f44336' : i % 3 === 1 ? '#4caf50' : '#fff';
    ctx.globalAlpha = 0.5;
    ctx.beginPath(); ctx.arc(lx, 96 + bob, 3, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Piazza Mazzini - the famous piazza with central garden
function drawBgPiazzaMazzini() {
  // Dark ominous sky for final boss
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#0a0a15');
  sky.addColorStop(0.5, '#111128');
  sky.addColorStop(1, '#1a1a30');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Lightning flashes
  if (Math.random() < 0.005) {
    screenFlash = 3;
    flashColor = '#b0bec5';
  }

  // Surrounding elegant buildings - Piazza Mazzini has grand architecture
  const palazzi = [
    { x: -20, w: 220, h: 300, color: '#4a4a58' },
    { x: 210, w: 180, h: 280, color: '#3d3d4d' },
    { x: 520, w: 200, h: 310, color: '#4a4a58' },
    { x: 730, w: 200, h: 290, color: '#3d3d4d' }
  ];
  palazzi.forEach(p => {
    drawRect(p.x, GROUND_Y - p.h, p.w, p.h, p.color);
    // Windows (simplified — no arches for performance)
    for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
      const wx = p.x + 20 + c * 80;
      const wy = GROUND_Y - p.h + 30 + r * 80;
      drawRect(wx, wy, 30, 38, '#111');
      ctx.globalAlpha = 0.2;
      drawRect(wx + 2, wy + 5, 26, 30, '#b0bec5');
      ctx.globalAlpha = 1;
    }
  });

  // Central garden area (Piazza Mazzini's garden)
  drawRect(350, GROUND_Y - 35, 200, 35, '#1b5e20');
  ctx.globalAlpha = 0.4;
  drawRect(360, GROUND_Y - 30, 180, 25, '#2e7d32');
  ctx.globalAlpha = 1;
  // Trees in garden
  [380, 430, 480, 530].forEach(tx => {
    drawRect(tx + 3, GROUND_Y - 55, 6, 25, '#3e2723');
    ctx.fillStyle = '#1b5e20';
    ctx.beginPath();
    ctx.arc(tx + 6, GROUND_Y - 60, 18, 0, Math.PI * 2);
    ctx.fill();
  });

  // Street lamps - eerie glow
  [100, 400, 700].forEach(lx => {
    drawRect(lx, GROUND_Y - 120, 4, 120, '#424242');
    drawRect(lx - 8, GROUND_Y - 125, 20, 6, '#424242');
    ctx.globalAlpha = 0.25 + Math.sin(gameTime * 0.04 + lx) * 0.15;
    ctx.fillStyle = '#ffcc80';
    ctx.beginPath();
    ctx.arc(lx + 2, GROUND_Y - 130, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });

  // Statue in center (monument)
  drawRect(440, GROUND_Y - 80, 20, 50, '#546e7a'); // pedestal pillar
  drawRect(430, GROUND_Y - 85, 40, 8, '#607d8b'); // pedestal top
  drawRect(425, GROUND_Y - 30, 50, 10, '#607d8b'); // pedestal base
  // Figure silhouette
  drawRect(442, GROUND_Y - 115, 16, 32, '#455a64');
  drawRect(438, GROUND_Y - 105, 8, 18, '#455a64'); // arm
  drawRect(454, GROUND_Y - 100, 8, 14, '#455a64'); // arm
  drawRect(446, GROUND_Y - 122, 10, 10, '#546e7a'); // head

  // Rain effect (lightweight — rects instead of strokes)
  for (let i = 0; i < 18; i++) {
    const rx = (i * 97 + gameTime * 3) % W;
    const ry = (i * 53 + gameTime * 6) % GROUND_Y;
    ctx.globalAlpha = 0.12;
    drawRect(rx, ry, 1, 10, '#7986cb');
  }
  ctx.globalAlpha = 1;

  // Puddle reflections (flat rects on ground, drawn behind everything)
  [150, 350, 600, 800].forEach(px => {
    ctx.globalAlpha = 0.06;
    drawRect(px - 22, GROUND_Y + 12, 44, 6, '#7986cb');
    ctx.globalAlpha = 1;
  });

  // Fog at ground level (denser)
  for (let i = 0; i < 10; i++) {
    ctx.globalAlpha = 0.06 + Math.sin(gameTime * 0.02 + i) * 0.03;
    const fx = (i * 110 + gameTime * 0.3) % (W + 100) - 50;
    const fw = 80 + (i % 3) * 40;
    drawRect(fx, GROUND_Y - 15, fw, 25, '#b0bec5');
    ctx.globalAlpha = 1;
  }
}

function shadeColor(color, amt) {
  let col = color.replace('#', '');
  if (col.length === 3) col = col[0]+col[0]+col[1]+col[1]+col[2]+col[2];
  const num = parseInt(col, 16);
  let r = Math.min(255, ((num >> 16) & 0xff) + amt);
  let g = Math.min(255, ((num >> 8) & 0xff) + amt);
  let b = Math.min(255, (num & 0xff) + amt);
  return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
}

// ==========================================
// MAIN LEVEL GAMEPLAY
// ==========================================
let bossIntro = false;
let bossIntroTimer = 0;

function updateLevel() {
  if (player.dead) {
    // Game over after a delay
    if (player.invincible < -60) {
      if (difficulty !== 'easy') lives--;
      state = 'gameover';
    }
    player.invincible--;
    updateParticles();
    return;
  }

  levelTimer++;

  // Player input
  updatePlayerInput();

  // Update enemies
  updateGoons();

  // Wave spawning system
  const goonsAlive = goons.length; // already filtered in updateGoons

  // Wave breather countdown
  if (waveBreatherTimer > 0) {
    waveBreatherTimer--;
    if (waveBreatherTimer === 0) {
      // Spawn next wave
      spawnGoons(waveConfig[currentWave] || 2);
      currentWave++;
      showQuickText('WAVE ' + currentWave + '/' + waveConfig.length, '#ff9800');
    }
  }

  // Check if current wave's goons are dead
  if (goonsAlive === 0 && boss && !bossIntro && waveClearTimer === 0 && waveBreatherTimer === 0 && levelTimer > 60) {
    if (currentWave < waveConfig.length) {
      // More waves to go - breather then next wave
      waveBreatherTimer = 120; // 2 seconds
      showQuickText('WAVE CLEAR!', '#4caf50');
      playSFX('coin');
    } else {
      // All waves cleared → bring boss
      waveClearTimer = 90;
      showQuickText('ALL WAVES CLEAR!', '#4caf50');
      playSFX('coin');
    }
  }
  if (waveClearTimer > 0) {
    waveClearTimer--;
    if (waveClearTimer === 0) {
      bossIntro = true;
      // Progressive intro duration: more hype for later bosses
      bossIntroTimer = [120, 150, 180, 200, 240][currentLevel] || 150;
      // Safety: reset boss HP to full when intro starts
      if (boss) { boss.hp = boss.maxHp; boss.poise = boss.maxPoise; }
    }
  }

  // Boss intro walk-in — unique cinematic per boss
  if (bossIntro && bossIntroTimer > 0) {
    const introMax = [120, 150, 180, 200, 240][currentLevel] || 150;
    const introProgress = 1 - (bossIntroTimer / introMax); // 0 → 1
    bossIntroTimer--;

    // === Per-boss walk-in behavior ===
    if (currentLevel === 0) {
      // LaFed: cocky swagger walk, bouncing rhythm
      boss.x += (650 - boss.x) * 0.05;
      if (gameTime % 12 < 6) boss.y = 430 - 3; else boss.y = 430; // swagger bounce
      if (gameTime % 8 === 0) spawnParticles(boss.x, boss.y, '#ffd54f', 1, 1); // gold sparkles
    } else if (currentLevel === 1) {
      // Gioacchino: heavy stomps, screen darkens
      boss.x += (650 - boss.x) * 0.03; // slow menacing approach
      if (gameTime % 20 === 0) { screenShake = 6; spawnParticles(boss.x, boss.y, '#795548', 4, 3); playSFX('stomp'); }
    } else if (currentLevel === 2) {
      // Dale: acrobatic entrance — flips in fast
      if (introProgress < 0.5) {
        boss.x += (650 - boss.x) * 0.08; // fast approach
        if (gameTime % 6 === 0) boss.y = 430 - 40; else boss.y = 430; // flip animation
        if (gameTime % 4 === 0) spawnParticles(boss.x, boss.y - 20, '#90a4ae', 3, 3);
      } else {
        boss.x += (650 - boss.x) * 0.03;
        if (gameTime % 10 === 0) spawnParticles(boss.x, boss.y, '#90a4ae', 2, 2);
      }
      if (Math.random() < 0.08) screenShake = Math.max(screenShake, 4);
    } else if (currentLevel === 3) {
      // Ciccio: ground-shaking heavy walk, fire particles, forno glow
      boss.x += (650 - boss.x) * 0.025;
      if (gameTime % 15 === 0) { screenShake = 8; playSFX('stomp'); }
      if (gameTime % 4 === 0) spawnParticles(boss.x, boss.y - 20, '#ff6f00', 2 + Math.floor(introProgress * 4), 3);
      if (gameTime % 3 === 0) spawnParticles(boss.x + (Math.random()-0.5)*30, boss.y - 40, '#f44336', 1, 2); // fire
      if (Math.random() < 0.05) { screenFlash = 2; flashColor = '#ff6f00'; }
    } else if (currentLevel === 4) {
      // Pisellino: full cinematic — darkness, lightning, manic energy
      boss.x += (650 - boss.x) * 0.04;
      if (Math.random() < 0.04) { screenFlash = 3; flashColor = '#e94560'; }
      if (Math.random() < 0.15) screenShake = Math.max(screenShake, 3 + Math.floor(introProgress * 8));
      if (gameTime % 5 === 0) spawnParticles(boss.x, boss.y, '#b0bec5', 2 + Math.floor(introProgress * 5), 3);
      if (introProgress > 0.7 && gameTime % 3 === 0) spawnParticles(boss.x, boss.y - 40, '#e94560', 3, 4); // red sparks
    }

    // === Per-boss text sequences ===
    if (bossIntroTimer === Math.floor(introMax * 0.7)) {
      const preQuotes = [
        '"Ao\', chi e\' sto tipo che se crede figo?"',
        '"Attento Conte... senti quei passi pesanti..."',
        '"Sta arrivando... si muove come un\'ombra!"',
        '"L\'aria puzza di pizza bruciata... e di guai!"',
        '"Lo senti? Er boss dei boss... Pisellino!"'
      ];
      showQuickText(preQuotes[currentLevel], '#ff8a80');
    }

    // Boss name + subtitle at 40%
    if (bossIntroTimer === Math.floor(introMax * 0.4)) {
      const lvl = levels[currentLevel];
      const shakeAmounts = [8, 12, 14, 18, 22];
      screenShake = shakeAmounts[currentLevel];
      playSFX('boss_appear');
      spawnParticles(boss.x, boss.y - boss.h / 2, lvl.bossColor || '#e94560', 15 + currentLevel * 5, 6);
      // Boss-specific dramatic SFX
      if (currentLevel === 1) playSFX('stomp'); // extra stomp for Gioacchino
      if (currentLevel === 3) { screenFlash = 4; flashColor = '#ff6f00'; } // fire flash for Ciccio
    }

    // Boss-specific taunt near end
    if (bossIntroTimer === 25) {
      const introTaunts = [
        '"Yo! So\' LaFed e sto per placcatte!"',
        '"In gabbia sognavo sto momento..."',
        '"DALE! Nessuno batte er Dale!"',
        '"ER FORNO E\' APERTO! Preparate a brucia\'!"',
        '"Sup bro... ready to get DESTROYED?"'
      ];
      showQuickText(introTaunts[currentLevel], levels[currentLevel].bossColor || '#e94560');
    }

    // Final dramatic moment on arrival
    if (bossIntroTimer === 1) {
      const finalShake = [10, 14, 16, 22, 26];
      screenShake = finalShake[currentLevel];
      if (currentLevel >= 2) { screenFlash = 6; flashColor = levels[currentLevel].bossColor || '#e94560'; }
      // Boss-specific arrival effect
      if (currentLevel === 0) spawnParticles(boss.x, boss.y - 30, '#ffd54f', 20, 6); // gold explosion
      if (currentLevel === 1) { spawnParticles(boss.x, boss.y, '#795548', 25, 7); playSFX('stomp'); } // heavy landing
      if (currentLevel === 2) spawnParticles(boss.x, boss.y - 40, '#90a4ae', 20, 8); // wind burst
      if (currentLevel === 3) { spawnParticles(boss.x, boss.y - 30, '#ff6f00', 30, 8); spawnParticles(boss.x, boss.y, '#f44336', 20, 6); } // fire explosion
      if (currentLevel === 4) { spawnParticles(boss.x, boss.y - 30, '#e94560', 30, 8); spawnParticles(boss.x, boss.y - 50, '#b0bec5', 20, 6); } // chaos burst
      boss.y = 430; // ensure grounded
    }
  }

  // Boss AI runs after intro completes
  if (bossIntro && bossIntroTimer <= 0) {
    updateBossAI();
  }

  // Check boss death
  if (boss && boss.hp <= 0 && !boss.dead) {
    boss.dead = true;
    bossDefeated[currentLevel] = true;
    if (difficulty === 'medium') lives = 3; // medium: lives replenish after beating a boss
    // Boss coin drops (physical pickups) — first clear gives big bonus
    const bossCoins = isReplayLevel ? 15 + currentLevel * 10 : 50 + currentLevel * 35;
    spawnCoinPickup(boss.x, boss.y - 30, bossCoins);
    // Level clear bonus
    const clearBonus = isReplayLevel ? 5 : 15 + currentLevel * 8;
    spawnCoinPickup(boss.x, boss.y - 40, clearBonus);
    screenShake = 25;
    screenFlash = 20;
    flashColor = '#ffd700';
    spawnParticles(boss.x, boss.y - 30, '#ffd700', 40, 8);
    playSFX('victory_jingle');

    // Victory dialogue
    const totalBossCoins = bossCoins + clearBonus;
    dialogueLines = [
      levels[currentLevel].boss.toUpperCase() + ' SCONFITTO!',
      ...levels[currentLevel].defeatLines,
      'Il Conte conquista ' + levels[currentLevel].name + '!',
      '+' + totalBossCoins + ' COINS' + (isReplayLevel ? ' (replay)' : ' (prima vittoria!)')
    ];
    dialogueIndex = 0;
    dialogueCallback = () => {
      bossIntro = false;
      // If all bosses defeated, go straight to credits
      if (bossDefeated.every(b => b)) {
        victoryTimer = 0;
        state = 'victory';
      } else {
        // Calculate grade and show upgrade selection
        calculateLevelGrade();
        generateUpgradeChoices();
        state = 'upgrade';
      }
    };
    state = 'dialogue';
  }

  // Update systems
  updateProjectiles();
  checkBulletHits();
  updateParticles();
  updateCoinPickups();
  updateHazards();

  // Passive ultra charge trickle in combat
  if (!player.ultraActive && !player.ultraAvailable && goons.some(g => !g.dead)) {
    const vampPenalty = player.upgrades.some(u => u.effect === 'ultraVampire') ? 0.9 : 1;
    player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 0.06 * vampPenalty);
    if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
  }

  // Update helper cooldowns
  for (let i = 0; i < 4; i++) {
    helperCooldowns[i] = Math.max(0, helperCooldowns[i] - 1);
  }

  // Update helper visuals
  updateHelperVisuals();

  // Exhaustion timer
  if (player.exhaustedTimer > 0) player.exhaustedTimer--;
  // Reload timer for ranged weapons
  if (player.reloadTimer > 0) {
    player.reloadTimer--;
    if (player.reloadTimer <= 0) {
      const weap = weapons[player.weapon];
      if (weap.maxAmmo) {
        weap.currentAmmo = weap.maxAmmo;
        showQuickText('RICARICATO!', '#a1887f');
        playSFX('coin');
      }
    }
  }
  // Stamina regen
  if (player.staminaRegenDelay > 0) {
    player.staminaRegenDelay--;
  } else if (player.stamina < player.maxStamina) {
    const stRegenRate = player.upgrades.some(u => u.effect === 'stregen') ? 0.7 : 0.5;
    player.stamina = Math.min(player.maxStamina, player.stamina + stRegenRate);
  }

  // Same-target penalty timeout: resets after 60 frames without hitting same target
  if (player.sameTargetHits > 0) {
    player.sameTargetTimer++;
    if (player.sameTargetTimer > 60) {
      player.sameTargetHits = 0;
      player.lastHitTarget = null;
      player.sameTargetTimer = 0;
    }
  }

  // Combo hit counter decay
  if (player.comboHitCount > 0) {
    player.comboHitTimer++;
    if (player.comboHitTimer > 90) {
      player.comboHitCount = 0;
      player.comboHitTimer = 0;
      player.scoreMultiplier = 1;
    }
  }

  // War cry timer (Tommy tier 3)
  if (warCryTimer > 0) warCryTimer--;
  if (warCryCooldown > 0) warCryCooldown--;
  // Tommy tier 3 auto-trigger
  if (helpers[1].tier >= 3 && warCryCooldown <= 0 && warCryTimer <= 0) {
    warCryTimer = 240;
    warCryCooldown = 1800; // 30 seconds
    showQuickText('WAR CRY! +30% DMG!', '#ff6e40');
  }

  // Ultra timer countdown
  if (player.ultraActive) {
    player.ultraTimer--;
    // Gold particle trail while Ultra active
    if (gameTime % 3 === 0) spawnParticles(player.x + (Math.random() - 0.5) * 20, player.y - Math.random() * player.h, '#ffd700', 2, 2);
    if (player.ultraTimer <= 0) {
      player.ultraActive = false;
      player.ultraTimer = 0;
      showQuickText('ULTRA FINITO', '#ff8f00');
    }
  }

  // Speed boost timer
  if (player.speedBoost > 0) player.speedBoost--;

  // Dodge counter timer
  if (dodgeCounter > 0) dodgeCounter--;
  // Phase transition timer
  if (phaseTransitionTimer > 0) phaseTransitionTimer--;
}

const GROUND_Y = 430;
const GRAVITY = 0.55;
const FALL_GRAVITY = 0.75;
const JUMP_FORCE = -13.0;

function updatePlayerInput() {
  if (player.stunTimer > 0) { player.stunTimer--; return; }

  const baseSpeed = (player.speed + (player.speedBoost > 0 ? 2.5 : 0)) * (player.ultraActive ? 1.1 : 1);
  const hazardMult = player.hazardSlow ? 0.7 : 1;
  const speed = (player.endLagTimer > 0 ? baseSpeed * 0.5 : baseSpeed) * hazardMult;

  // Movement
  if (keys['ArrowLeft'] || keys['KeyA']) {
    player.x -= speed;
    player.facing = -1;
    player.animTimer++;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    player.x += speed;
    player.facing = 1;
    player.animTimer++;
  }

  // Jump (blocked during end-lag)
  if ((keys['ArrowUp'] || keys['KeyW']) && player.grounded && player.endLagTimer <= 0) {
    player.vy = JUMP_FORCES[0];
    player.grounded = false;
  }

  // Variable jump height: releasing jump early cuts upward velocity (short hop vs full jump)
  if (!player.grounded && player.vy < -4 && !(keys['ArrowUp'] || keys['KeyW'])) {
    player.vy = -4; // cap upward speed for short hop
  }

  // Apply variable gravity (lighter going up, heavier coming down)
  if (!player.grounded) {
    const grav = player.vy < 0 ? GRAVITY : FALL_GRAVITY;
    // Fast-fall: pressing Down while airborne adds extra gravity
    const fastFall = (keys['ArrowDown'] || keys['KeyS']) ? 0.4 : 0;
    player.vy += grav + fastFall;
    player.y += player.vy;
    if (player.y >= GROUND_Y) {
      player.y = GROUND_Y;
      player.vy = 0;
      player.grounded = true;
      // Jump attack: stun nearby enemies on landing
      const jumpTargets = goons.filter(g => !g.dead && Math.abs(g.x - player.x) < 55 && (!g.staggerTimer || g.staggerTimer <= 0));
      if (jumpTargets.length > 0) {
        jumpTargets.forEach(g => {
          g.stunTimer = 25;
          g.knockbackVx = Math.sign(g.x - player.x) * 4;
          spawnParticles(g.x, g.y - 20, '#64b5f6', 4);
        });
        spawnParticles(player.x, GROUND_Y, '#fff', 6, 3);
        screenShake = 4;
        playSFX('stomp');
      }
    }
  }

  // Dodge (blocked during end-lag)
  if ((keys['KeyX'] || keys['ShiftLeft']) && !player.dodging && player.dodgeCooldown <= 0 && player.endLagTimer <= 0) {
    player.dodging = true;
    player.dodgeTimer = 12;
    player.dodgeCooldown = DODGE_COOLDOWNS[dodgeTier];
    player.vx = player.facing * 8;
    player.stamina = Math.max(0, player.stamina - 22);
    player.staminaRegenDelay = 30;
    spawnParticles(player.x, player.y - 20, '#64b5f6', 5);
    playSFX('dodge');
    // Perfect dodge: dodge while an enemy is winding up nearby
    const nearbyWindup = goons.some(g => !g.dead && g.windupTimer > 0 && Math.abs(g.x - player.x) < 90) ||
      (boss && !boss.dead && boss.chargeTimer > 0 && Math.abs(boss.x - player.x) < 100);
    if (nearbyWindup) {
      dodgeCounter = 90;
      showQuickText('PERFECT DODGE! Danno x1.5!', '#64b5f6');
      playSFX('perfect_dodge');
      screenFlash = 4;
      flashColor = '#64b5f6';
      // Style bonus: +2 coins for perfect dodge
      spawnCoinPickup(player.x, player.y - 30, 2);
    }
  }

  if (player.dodging) {
    player.x += player.vx;
    player.dodgeTimer--;
    player.vx *= 0.9;
    if (player.dodgeTimer <= 0) {
      player.dodging = false;
    }
  }

  player.dodgeCooldown = Math.max(0, player.dodgeCooldown - 1);

  // End-lag: player can move at 50% speed but can't attack/dodge/jump
  if (player.endLagTimer > 0) {
    player.endLagTimer--;
    if (player.endLagTimer <= 0) {
      player.comboStep = 0;
      player.attacking = false;
    }
    // Override movement to 50% speed during end-lag (already applied above via speed var)
  }

  // Ultra activation — Q key, only when fully charged
  if (keysJustPressed['KeyQ'] && player.ultraAvailable && !player.ultraActive) {
    player.ultraActive = true;
    player.ultraTimer = player.ultraDuration; // 300 frames = 5 seconds
    player.ultraCharge = 0;
    player.ultraAvailable = false;
    screenShake = 12;
    screenFlash = 8;
    flashColor = '#ffd700';
    spawnParticles(player.x, player.y - 30, '#ffd700', 25, 7);
    showQuickText('ULTRA!!!', '#ffd700');
    playSFX('stomp');
  }

  // Combo chain attack system — requires keysJustPressed (no hold-to-spam)
  if (keysJustPressed['KeyZ'] || keysJustPressed['Space']) {
    const holdUp = !isTouchDevice && (keys['ArrowUp'] || keys['KeyW']);

    if (!player.grounded) {
      playerJumpAttack();
    } else if (holdUp && player.endLagTimer <= 0 && player.comboStep === 0) {
      // Up + Attack = Overhead slam (keyboard only)
      playerOverhead();
    } else {
      playerAttack();
    }
  }

  // Manage active frames → combo window → end-lag transitions
  if (player.attackActiveTimer > 0) {
    player.attackActiveTimer--;
    player.attackTimer = player.attackActiveTimer;
    if (player.attackActiveTimer <= 0) {
      const weap = weapons[player.weapon];
      const maxHits = weap.comboHits;
      if (player.comboStep < maxHits) {
        // Enter combo window (tight timing rewards skill)
        player.comboWindowTimer = weap.comboWindow;
        // Check buffer
        if (player.attackBuffered) {
          player.attackBuffered = false;
          launchComboHit(player.comboStep);
        }
      } else {
        // Last hit complete → full end-lag (50% more if low stamina)
        const lagMult = player.stamina < 35 ? 1.5 : 1;
        player.endLagTimer = Math.floor(weap.endLag * lagMult);
        player.comboChainCount++;
        // Ultra charge bonus for completing full combo chain
        if (!player.ultraActive) {
          player.ultraCharge = Math.min(player.ultraMaxCharge, player.ultraCharge + 14);
          if (player.ultraCharge >= player.ultraMaxCharge) player.ultraAvailable = true;
        }
        player.attacking = false;
      }
    }
  }

  // Combo window countdown
  if (player.comboWindowTimer > 0 && player.attackActiveTimer <= 0) {
    player.comboWindowTimer--;
    // Buffer check during window
    if (player.attackBuffered && player.comboStep < weapons[player.weapon].comboHits) {
      player.attackBuffered = false;
      launchComboHit(player.comboStep);
    }
    if (player.comboWindowTimer <= 0 && player.endLagTimer <= 0) {
      // Dropped combo → short end-lag
      player.endLagTimer = DROPPED_END_LAG;
      player.attacking = false;
    }
  }

  // Reset jump attack flag on landing
  if (player.grounded) player.jumpAttacking = false;

  // Invincibility
  if (player.invincible > 0) player.invincible--;

  // Bounds
  player.x = Math.max(25, Math.min(W - 25, player.x));

  // Helper keys
  if (keys['Digit1']) { activateHelper(0); keys['Digit1'] = false; }
  if (keys['Digit2']) { activateHelper(1); keys['Digit2'] = false; }
  if (keys['Digit3']) { activateHelper(2); keys['Digit3'] = false; }
  if (keys['Digit4']) { activateHelper(3); keys['Digit4'] = false; }
}

function drawLevel() {
  // Moves screen (TAB/P) — handled in draw phase to avoid double-toggle
  if (keysJustPressed['Tab'] || keysJustPressed['KeyP']) {
    toggleMovesScreen();
  }

  // Camera zoom
  const levelZoom = isTouchDevice ? 1.35 : 1.25;
  ctx.save();
  const camX = Math.max(W / (2 * levelZoom), Math.min(W - W / (2 * levelZoom), player.x));
  const camY = Math.max(H / (2 * levelZoom), Math.min(H - H / (2 * levelZoom), player.y - 40));
  ctx.translate(W / 2, H / 2);
  ctx.scale(levelZoom, levelZoom);
  ctx.translate(-camX, -camY);

  drawLevelBg();
  drawHazards();

  // Draw goons
  goons.forEach(g => drawGoon(g));

  // Draw boss
  if (boss && !boss.dead) drawBossChar(boss);

  // Draw Regina
  if (reginaActive) drawRegina(regina);

  // Draw Mariuso
  if (mariusoActive) drawMariuso(mariuso);

  // Draw player
  drawConte(player);

  // Draw coin pickups
  drawCoinPickups();

  // Draw projectiles
  drawProjectiles();

  // Draw helper characters
  drawHelperVisuals();

  // Draw particles
  drawParticles();

  ctx.restore();

  // HUD
  drawHUD();
  drawBossHpBar();

  // Phase transition overlay
  if (phaseTransitionTimer > 0) {
    phaseTransitionTimer--;
    const alpha = Math.min(1, phaseTransitionTimer / 30);
    ctx.globalAlpha = alpha * 0.6;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = alpha;
    drawRect(W/2 - 250, H/2 - 30, 500, 50, 'rgba(0,0,0,0.9)');
    drawRect(W/2 - 250, H/2 - 30, 500, 3, phaseTransitionColor);
    drawText(phaseTransitionText, W/2, H/2, phaseTransitionColor, 16, 'center');
    ctx.globalAlpha = 1;
  }

  // Level intro splash
  if (levelTimer < 120) {
    const fadeIn = Math.min(1, levelTimer / 20);
    const fadeOut = Math.min(1, (120 - levelTimer) / 30);
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    drawRect(0, 0, W, H, 'rgba(0,0,0,0.5)');
    drawRect(W/2 - 200, H/2 - 90, 400, 80, 'rgba(0,0,0,0.9)');
    drawRect(W/2 - 200, H/2 - 90, 400, 3, '#e94560');
    drawText(levels[currentLevel].name.toUpperCase(), W/2, H/2 - 60, '#fff', 28, 'center');
    drawText('vs ' + levels[currentLevel].boss, W/2, H/2 - 30, '#e94560', 18, 'center');
    ctx.globalAlpha = 1;
  }

  // Boss intro cinematic overlay — progressive per level
  if (bossIntro && bossIntroTimer > 0) {
    const introMax = [120, 150, 180, 200, 240][currentLevel] || 150;
    const introProgress = 1 - (bossIntroTimer / introMax);
    // Dimming: more dramatic for later bosses
    const dimBase = 0.15 + currentLevel * 0.06; // 0.15 → 0.39
    const dimAlpha = dimBase * (1 - Math.abs(introProgress - 0.5) * 2); // peaks at midpoint
    ctx.globalAlpha = dimAlpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;

    // Boss name banner at 40%-80% of intro
    if (introProgress > 0.35 && introProgress < 0.85) {
      const lvl = levels[currentLevel];
      const bannerAlpha = Math.min(1, (introProgress - 0.35) * 5);
      ctx.globalAlpha = bannerAlpha;
      // Dark banner
      drawRect(W/2 - 200, H/2 - 50, 400, 70, 'rgba(0,0,0,0.85)');
      drawRect(W/2 - 200, H/2 - 50, 400, 3, lvl.bossColor || '#e94560');
      drawRect(W/2 - 200, H/2 + 17, 400, 3, lvl.bossColor || '#e94560');
      // Boss name (big)
      drawText(lvl.boss.toUpperCase(), W/2, H/2 - 20, lvl.bossColor || '#e94560', 24, 'center');
      // Subtitle
      drawText(lvl.subtitle || '', W/2, H/2 + 5, '#ccc', 11, 'center');
      ctx.globalAlpha = 1;
    }

    // Vignette effect for level 3+
    if (currentLevel >= 3) {
      const vigGrad = ctx.createRadialGradient(W/2, H/2, 100, W/2, H/2, 500);
      vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
      vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);
    }
  }

  // Dead overlay
  if (player.dead) {
    ctx.fillStyle = 'rgba(20,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    drawRect(W/2 - 160, H/2 - 35, 320, 50, 'rgba(0,0,0,0.8)');
    drawRect(W/2 - 160, H/2 - 35, 320, 3, '#f44336');
    drawText('IL CONTE IS DOWN!', W/2, H/2, '#f44336', 24, 'center');
  }

  // Mobile touch buttons (drawn last = highest z-order)
  drawTouchButtons();
}

function drawHUD() {
  // === TOP LEFT: Player info panel ===
  drawRect(8, 8, 195, 62, 'rgba(0,0,0,0.7)');
  drawRect(8, 8, 195, 2, '#e94560');

  // HP bar — label left, bar right, value far right
  const hpW = 130;
  const barX = 38;
  const hpR = player.hp / player.maxHp;
  drawText('HP', 14, 24, '#fff', 8);
  drawRect(barX, 16, hpW, 9, '#333');
  drawRect(barX, 16, hpW * hpR, 9, hpR > 0.3 ? '#4caf50' : '#f44336');
  drawText(Math.floor(player.hp) + '/' + player.maxHp, barX + hpW + 2, 24, '#ccc', 7, 'left');

  // Stamina bar
  const stR = player.stamina / player.maxStamina;
  const exhausted = player.exhaustedTimer > 0;
  drawText('ST', 14, 34, exhausted ? '#f44336' : '#fdd835', 8);
  drawRect(barX, 28, hpW, 6, '#333');
  drawRect(barX, 28, hpW * stR, 6, exhausted ? '#f44336' : stR > 0.25 ? '#fdd835' : '#ff8f00');
  if (exhausted) {
    // Flash "!" after bar when exhausted
    const exFlash = Math.floor(gameTime / 10) % 2 === 0;
    if (exFlash) drawText('!', barX + hpW + 3, 34, '#f44336', 8);
  }

  // Weapon name row
  const curWeap = weapons[player.weapon];
  drawText(curWeap.name, 14, 45, '#ffcc80', 9);
  // Lives display — clear hearts at bottom of panel
  if (difficulty === 'easy') {
    drawRect(14, 50, 40, 18, 'rgba(0,0,0,0.5)');
    drawText('\u221E', 34, 64, '#4caf50', 14, 'center');
  } else {
    drawRect(14, 50, 60, 18, 'rgba(0,0,0,0.5)');
    for (let li = 0; li < 3; li++) {
      const alive = li < lives;
      drawRect(16 + li * 19, 52, 15, 14, alive ? '#e94560' : '#333');
      drawText(alive ? '\u2665' : '\u2661', 24 + li * 19, 64, alive ? '#fff' : '#555', 11, 'center');
    }
  }
  // Dodge & Jump indicators — right side of panel (desktop only, mobile uses touch buttons)
  if (!isTouchDevice) {
    if (player.dodgeCooldown > 0) {
      drawText('[X]' + Math.ceil(player.dodgeCooldown / 6) / 10 + 's', 130, 45, '#555', 7);
    } else {
      drawText('[X]OK', 130, 45, '#64b5f6', 7);
    }
    drawText('[W]' + (player.grounded ? 'OK' : '--'), 168, 45, player.grounded ? '#64b5f6' : '#555', 7);
  }

  // Ammo row (only for ranged weapons)
  if (curWeap.maxAmmo) {
    if (player.reloadTimer > 0) {
      const reloadFlash = Math.floor(gameTime / 8) % 2 === 0;
      drawText('RICARICA!', 14, 56, reloadFlash ? '#ff8f00' : '#ff5722', 8);
    } else {
      const ammo = curWeap.currentAmmo !== undefined ? curWeap.currentAmmo : curWeap.maxAmmo;
      drawText('AMMO: ' + ammo + '/' + curWeap.maxAmmo, 14, 56, ammo > 1 ? '#a1887f' : '#f44336', 8);
    }
  }

  // === ULTRA BAR — independent widget below player panel ===
  const ultraBarX = 8, ultraBarY = 84, ultraBarW = 195, ultraBarH = 14;
  drawRect(ultraBarX, ultraBarY, ultraBarW, ultraBarH, 'rgba(0,0,0,0.7)');
  const ultraR = player.ultraCharge / player.ultraMaxCharge;
  if (player.ultraActive) {
    const timerR = player.ultraTimer / player.ultraDuration;
    drawRect(ultraBarX + 1, ultraBarY + 1, (ultraBarW - 2) * timerR, ultraBarH - 2, '#fff');
    const ultraPulse = Math.sin(gameTime * 0.2) * 0.3 + 0.7;
    ctx.globalAlpha = ultraPulse;
    drawText('Q  ULTRA!', ultraBarX + ultraBarW / 2, ultraBarY + 11, '#ffd700', 10, 'center');
    ctx.globalAlpha = 1;
  } else if (player.ultraAvailable) {
    const ultraPulse = Math.sin(gameTime * 0.15) * 0.3 + 0.7;
    ctx.globalAlpha = ultraPulse;
    drawRect(ultraBarX + 1, ultraBarY + 1, ultraBarW - 2, ultraBarH - 2, '#ffd700');
    drawText('Q  PRONTO!', ultraBarX + ultraBarW / 2, ultraBarY + 11, '#1a1a2e', 10, 'center');
    ctx.globalAlpha = 1;
  } else {
    drawRect(ultraBarX + 1, ultraBarY + 1, (ultraBarW - 2) * ultraR, ultraBarH - 2, '#ff8f00');
    drawText('Q', ultraBarX + 6, ultraBarY + 11, '#ff8f00', 9);
  }

  // === TOP RIGHT: Coins ===
  drawRect(W - 110, 8, 102, 22, 'rgba(0,0,0,0.7)');
  drawText('COINS: ' + coins, W - 58, 24, '#ffd700', 12, 'center');

  // === Combo Chain Dots ===
  const weap = weapons[player.weapon];
  const maxHits = weap.comboHits;
  let rightY = 30; // tracks bottom of last drawn element in top-right column
  if (player.comboStep > 0 || player.endLagTimer > 0) {
    drawRect(W - 115, rightY + 4, 110, 22, 'rgba(0,0,0,0.6)');
    // Draw dots for each combo step
    const dotY = rightY + 15;
    for (let i = 0; i < maxHits; i++) {
      const dotX = W - 108 + i * 24;
      const filled = i < player.comboStep;
      const isActive = i === player.comboStep - 1 && player.attackActiveTimer > 0;
      ctx.beginPath();
      ctx.arc(dotX + 8, dotY, 6, 0, Math.PI * 2);
      if (isActive) {
        ctx.fillStyle = '#ff9800';
        ctx.fill();
        // Pulse effect
        ctx.strokeStyle = '#ffeb3b';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (filled) {
        ctx.fillStyle = '#ff9800';
        ctx.fill();
      } else {
        ctx.fillStyle = '#444';
        ctx.fill();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    rightY += 28; // past combo dots box
    // End-lag cooldown bar
    if (player.endLagTimer > 0) {
      const lagW = 100 * (player.endLagTimer / weap.endLag);
      drawRect(W - 113, rightY, lagW, 3, '#f44336');
      rightY += 5;
    }
  }

  // === Dodge counter (damage boost active) ===
  if (dodgeCounter > 0) {
    const dcW = 96 * (dodgeCounter / 90);
    drawRect(W - 110, rightY + 2, 102, 16, 'rgba(0,0,0,0.5)');
    drawRect(W - 107, rightY + 4, dcW, 12, '#64b5f6');
    drawText('COUNTER!', W - 58, rightY + 15, '#64b5f6', 9, 'center');
    rightY += 20;
  }

  // === Chain Count Multiplier ===
  if (player.comboChainCount > 0) {
    const chainMult = Math.min(2.0, 1.0 + player.comboChainCount * 0.5);
    drawRect(W - 115, rightY + 2, 110, 16, 'rgba(0,0,0,0.5)');
    drawText('CHAIN x' + chainMult.toFixed(1), W - 58, rightY + 14, '#ffd700', 10, 'center');
    rightY += 20;
  }

  // === COMBO COUNTER (center-right) ===
  if (player.comboHitCount >= 2) {
    const comboAlpha = player.comboHitTimer < 60 ? 1 : 1 - (player.comboHitTimer - 60) / 30;
    ctx.globalAlpha = Math.max(0.3, comboAlpha);
    const comboSize = Math.min(36, 20 + player.comboHitCount * 0.5);
    const comboY = rightY + 30;
    const comboX = W - 60;
    // Multiplier color
    const multColor = player.scoreMultiplier >= 3 ? '#f44336' : player.scoreMultiplier >= 2 ? '#ff9800' : player.scoreMultiplier >= 1.5 ? '#ffd700' : '#fff';
    drawText(player.comboHitCount, comboX, comboY, multColor, comboSize, 'center');
    drawText('HITS', comboX, comboY + 18, '#ccc', 10, 'center');
    if (player.scoreMultiplier > 1) {
      drawText('x' + player.scoreMultiplier, comboX, comboY + 32, multColor, 14, 'center');
    }
    ctx.globalAlpha = 1;
  }

  // === BOTTOM LEFT: Helper cooldowns ===
  const bottomBarY = isTouchDevice ? 74 : H - 38;
  const bottomBarX = isTouchDevice ? 240 : 8;
  drawRect(bottomBarX, bottomBarY, 220, 30, 'rgba(0,0,0,0.6)');
  for (let i = 0; i < 4; i++) {
    const hx = bottomBarX + 6 + i * 54;
    const hy = bottomBarY + 4;
    if (!helpers[i].unlocked) {
      // Locked helper — greyed out
      ctx.globalAlpha = 0.25;
      drawRect(hx, hy, 48, 22, 'rgba(0,0,0,0.3)');
      drawText((i+1) + ':?', hx + 4, hy + 16, '#555', 10);
      ctx.globalAlpha = 1;
      continue;
    }
    const ready = helperCooldowns[i] === 0;
    // Background
    drawRect(hx, hy, 48, 22, ready ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.3)');
    // Cooldown fill
    if (!ready) {
      drawRect(hx, hy, 48 * (1 - helperCooldowns[i] / helpers[i].cooldown), 22, helpers[i].color);
      ctx.globalAlpha = 0.3;
      drawRect(hx, hy, 48, 22, helpers[i].color);
      ctx.globalAlpha = 1;
    } else {
      drawRect(hx, hy, 48, 2, helpers[i].color);
    }
    ctx.globalAlpha = ready ? 1 : 0.4;
    drawText((i+1) + ':' + helpers[i].icon, hx + 4, hy + 16, '#fff', 10);
    ctx.globalAlpha = 1;
  }

  // === Wave indicator ===
  if (!bossIntro && waveConfig.length > 1) {
    drawRect(W/2 - 50, 8, 100, 18, 'rgba(0,0,0,0.6)');
    drawText('WAVE ' + Math.min(currentWave, waveConfig.length) + '/' + waveConfig.length, W/2, 22, '#ff9800', 11, 'center');
  }

  // (end-lag bar shown in combo dots area)

  // === Speed boost indicator (center, only when active) ===
  if (player.speedBoost > 0) {
    drawRect(W/2 - 70, 60, 140, 20, 'rgba(0,0,0,0.6)');
    drawText('SPEED! ' + Math.ceil(player.speedBoost / 60) + 's', W/2, 76, '#76ff03', 12, 'center');
  }

  // === THREAT INDICATORS (off-screen enemy arrows) ===
  const allThreats = [];
  goons.forEach(g => {
    if (g.dead) return;
    if (g.windupTimer > 0) allThreats.push({ x: g.x, y: g.y, type: 'telegraph' });
  });
  if (boss && !boss.dead) {
    if (boss.bossState === 'attack') allThreats.push({ x: boss.x, y: boss.y, type: 'attack' });
    else if (boss.bossState === 'telegraph') allThreats.push({ x: boss.x, y: boss.y, type: 'telegraph' });
  }
  allThreats.forEach(t => {
    const margin = 200;
    if (t.x >= 0 && t.x <= W) return; // on-screen, skip
    if (Math.abs(t.x - (t.x < 0 ? 0 : W)) > margin) return; // too far
    const arrowColor = t.type === 'attack' ? '#f44336' : '#ffd700';
    const arrowX = t.x < 0 ? 16 : W - 16;
    const arrowY = Math.max(80, Math.min(H - 60, t.y));
    const dir = t.x < 0 ? -1 : 1;
    ctx.fillStyle = arrowColor;
    ctx.globalAlpha = 0.6 + Math.sin(gameTime * 0.15) * 0.3;
    ctx.beginPath();
    ctx.moveTo(arrowX + dir * 10, arrowY);
    ctx.lineTo(arrowX - dir * 6, arrowY - 8);
    ctx.lineTo(arrowX - dir * 6, arrowY + 8);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}

// ==========================================
// GAME OVER
// ==========================================
function drawGameOver() {
  ctx.fillStyle = 'rgba(10,0,0,0.95)';
  ctx.fillRect(0, 0, W, H);

  if (lives <= 0 && difficulty !== 'easy') {
    if (difficulty === 'hard') {
      // HARD: 0 lives = full game over, back to menu
      drawText('GAME OVER - FINE', W/2, 100, '#e53935', 32, 'center');
      drawText('Tutte le vite perse. Nessuna pieta\'.', W/2, 135, '#888', 12, 'center');

      const hardTaunts = [
        '"Ahahah Conte, sei finito! La difficile non perdona!"',
        '"Game over totale! Valle Aurelia e\' nostra per sempre!"',
        '"Pensavi di farcela in difficile? Illuso!"',
      ];
      const taunt = hardTaunts[Math.floor(gameTime / 240) % hardTaunts.length];
      drawText(taunt, W/2, 200, '#ff8a65', 13, 'center');
      drawText('- Pisellino', W/2, 225, '#ff6e40', 11, 'center');

      const restartBtnW = 260, restartBtnH = 40;
      const restartBtnX = W/2 - restartBtnW/2, restartBtnY = 300;
      const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
      drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#e94560' : 'rgba(233,69,96,0.3)');
      drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#e94560');
      drawText('RICOMINCIA DA CAPO', W/2, restartBtnY + 27, '#fff', 14, 'center');

      if (keys['Enter'] || keys['Space'] || (restartHover && mouseClick)) {
        // Full reset
        coins = 0; weapons = [starterWeapons[0]]; weaponTier = 0;
        healthTier = 0; dodgeTier = 0; speedTier = 0;
        player.maxHp = 120; player.maxStamina = 100; player.speed = 4.0;
        player.upgrades = [];
        helpers.forEach(h => { h.tier = 0; h.unlocked = false; });
        bossDefeated = [false, false, false, false, false];
        lives = 3; firstTime = true;
        state = 'menu';
        resetPlayer();
        bossIntro = false;
      }
    } else {
      // MEDIUM: 0 lives on this boss — back to Vanni
      drawText('SCONFITTA TOTALE', W/2, 100, '#e53935', 32, 'center');
      drawText('3 vite perse contro ' + levels[currentLevel].boss + '!', W/2, 135, '#888', 12, 'center');

      const finalTaunts = [
        '"Ahahah Conte, 3 tentativi e niente! Sei scarso forte!"',
        '"Torna a Vanni a allenarti, Contino... LOL"',
        '"Bro sei morto 3 volte, maybe prova a comprare qualcosa?"',
        '"Easy clap x3, troppo facile per ' + levels[currentLevel].boss + '!"',
      ];
      const taunt = finalTaunts[Math.floor(gameTime / 240) % finalTaunts.length];
      drawText(taunt, W/2, 200, '#ff8a65', 13, 'center');
      drawText('- Pisellino', W/2, 225, '#ff6e40', 11, 'center');

      drawText('Torna da Vanni, potenziati e riprova!', W/2, 270, '#aaa', 12, 'center');

      const restartBtnW = 260, restartBtnH = 40;
      const restartBtnX = W/2 - restartBtnW/2, restartBtnY = 320;
      const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
      drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#e94560' : 'rgba(233,69,96,0.3)');
      drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#e94560');
      drawText('TORNA DA VANNI', W/2, restartBtnY + 27, '#fff', 14, 'center');

      if (keys['Enter'] || keys['Space'] || (restartHover && mouseClick)) {
        lives = 3;
        state = 'hub';
        resetPlayer();
        bossIntro = false;
      }
    }
  } else {
    // Still have lives — normal game over
    drawText('GAME OVER', W/2, 120, '#e53935', 36, 'center');

    // Lives display
    if (difficulty === 'easy') {
      drawText('\u221E', W/2, 165, '#4caf50', 24, 'center');
      drawText('Vite infinite (facile)', W/2, 185, '#4caf50', 11, 'center');
    } else {
      for (let i = 0; i < 3; i++) {
        const lx = W/2 - 40 + i * 30;
        drawRect(lx, 145, 20, 20, i < lives ? '#e94560' : '#333');
        drawText(i < lives ? '\u2665' : '\u2661', lx + 10, 161, i < lives ? '#fff' : '#555', 14, 'center');
      }
      drawText('Vite rimaste: ' + lives, W/2, 185, '#ff8a80', 11, 'center');
    }

    // Pisellino special taunts
    if (currentLevel === 4) {
      const taunt = piselloTaunts[Math.floor(gameTime / 300) % piselloTaunts.length];
      drawText(taunt, W/2, 220, '#b0bec5', 14, 'center');
      drawText('- Pisellino', W/2, 245, '#78909c', 11, 'center');
    } else {
      drawText('Il Conte cade a ' + levels[currentLevel].name, W/2, 220, '#aaa', 14, 'center');
    }

    // Retry button (tappable)
    const retryBtnW = 180, retryBtnH = 36;
    const retryBtnX = W/2 - retryBtnW/2, retryBtnY = 290;
    const retryHover = mouseX >= retryBtnX && mouseX <= retryBtnX + retryBtnW && mouseY >= retryBtnY && mouseY <= retryBtnY + retryBtnH;
    drawRect(retryBtnX, retryBtnY, retryBtnW, retryBtnH, retryHover ? '#e94560' : 'rgba(233,69,96,0.3)');
    drawRect(retryBtnX, retryBtnY, retryBtnW, 2, '#e94560');
    drawText('RIPROVA', W/2, retryBtnY + 25, '#fff', 16, 'center');

    const backBtnW = 180, backBtnH = 36;
    const backBtnX = W/2 - backBtnW/2, backBtnY = 340;
    const backHover = mouseX >= backBtnX && mouseX <= backBtnX + backBtnW && mouseY >= backBtnY && mouseY <= backBtnY + backBtnH;
    drawRect(backBtnX, backBtnY, backBtnW, backBtnH, backHover ? '#555' : 'rgba(255,255,255,0.1)');
    drawText('TORNA A VANNI', W/2, backBtnY + 25, '#aaa', 13, 'center');

    if (keys['Enter'] || keys['Space'] || (retryHover && mouseClick)) {
      startLevel(currentLevel);
    }
    if (keys['Escape'] || (backHover && mouseClick)) {
      state = 'hub';
      resetPlayer();
      bossIntro = false;
    }
  }
  mouseClick = false;
}

// ==========================================
// SABI MODE — Secret Easter Egg
// ==========================================

const sabiJokesSabi = [
  "Ciao Bobbi! Benvenuto a Sbomboland!",
  "Sei il mio Sbombolone preferito!",
  "Bobbi loves u!",
  "A Sbomboland si mangia solo carbonara e popcorn",
  "Lo Sbombo e' forte in te oggi",
  "I'm in love with the Sbombo!",
];

const sabiJokesTotti = [
  "*scodinzola furiosamente* BOBBI!",
  "Totti deve cacare!",
  "Lo Sbombolo approva!",
  "Totti: re indiscusso di Sbomboland",
  "*lecca Cicca con entusiasmo*",
  "Sbombo mode: ACTIVATED",
];

function drawCicca(x, y, facing, animTimer) {
  const bob = Math.sin(animTimer * 0.15) * 2;
  const bx = x - 12, by = y - 20 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 28, 5);
  // Body — orange tabby
  drawRect(bx, by + 6, 24, 12, '#ff8a65');
  drawRect(bx + 2, by + 8, 20, 8, '#ffab91');
  // Stripes
  drawRect(bx + 4, by + 7, 3, 10, '#e64a19');
  drawRect(bx + 10, by + 7, 3, 10, '#e64a19');
  drawRect(bx + 16, by + 7, 3, 10, '#e64a19');
  // Head
  drawRect(bx + 4, by, 16, 10, '#ff8a65');
  // Ears — pointy triangles
  drawRect(bx + 4, by - 4, 4, 5, '#ff8a65');
  drawRect(bx + 5, by - 3, 2, 3, '#ffab91');
  drawRect(bx + 16, by - 4, 4, 5, '#ff8a65');
  drawRect(bx + 17, by - 3, 2, 3, '#ffab91');
  // Eyes — big green
  drawRect(bx + 7, by + 2, 3, 3, '#4caf50');
  drawRect(bx + 8, by + 3, 1, 1, '#111');
  drawRect(bx + 14, by + 2, 3, 3, '#4caf50');
  drawRect(bx + 15, by + 3, 1, 1, '#111');
  // Pink nose
  drawRect(bx + 11, by + 5, 2, 2, '#ff80ab');
  // Whiskers
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(bx + 5, by + 5); ctx.lineTo(bx - 2, by + 3);
  ctx.moveTo(bx + 5, by + 6); ctx.lineTo(bx - 2, by + 7);
  ctx.moveTo(bx + 19, by + 5); ctx.lineTo(bx + 26, by + 3);
  ctx.moveTo(bx + 19, by + 6); ctx.lineTo(bx + 26, by + 7);
  ctx.stroke();
  // Legs
  drawRect(bx + 2, by + 16, 4, 4, '#ff8a65');
  drawRect(bx + 18, by + 16, 4, 4, '#ff8a65');
  // Tail — swaying sine wave
  const tailSway = Math.sin(animTimer * 0.1) * 6 * facing;
  drawRect(bx + (facing === 1 ? -2 : 22), by + 8, 3, 2, '#ff8a65');
  drawRect(bx + (facing === 1 ? -5 : 25) + tailSway * 0.3, by + 6, 3, 2, '#ff8a65');
  drawRect(bx + (facing === 1 ? -8 : 28) + tailSway, by + 4, 3, 2, '#e64a19');
}

function drawSabiChar(x, y, animTimer) {
  const bob = Math.sin(animTimer * 0.04) * 2;
  const bx = x - 15, by = y - 52 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 34, 6);
  // Use drawPixelChar base — pink dress, light skin
  drawPixelChar(bx, by, 30, 52, '#ff69b4', '#ffe0b2', (px, py, pw, ph) => {
    // Blonde hair — long flowing
    drawRect(px + 2, py - 4, pw - 4, 8, '#ffd54f');
    drawRect(px, py, 3, 26, '#ffd54f'); // left side hair
    drawRect(px + pw - 3, py, 3, 26, '#ffd54f'); // right side hair
    drawRect(px + 2, py, pw - 4, 4, '#ffd54f'); // top hair
    // Hair highlights
    drawRect(px + 4, py - 2, 4, 3, '#ffe082');
    drawRect(px + pw - 8, py - 2, 4, 3, '#ffe082');
    // Blue eyes — override defaults
    drawRect(px + 8, py + 8, 5, 5, '#2196f3');
    drawRect(px + pw - 13, py + 8, 5, 5, '#2196f3');
    drawRect(px + 10, py + 10, 2, 2, '#0d47a1');
    drawRect(px + pw - 11, py + 10, 2, 2, '#0d47a1');
    // Pink cheeks (blush)
    drawRect(px + 5, py + 14, 4, 2, '#ff8a80');
    drawRect(px + pw - 9, py + 14, 4, 2, '#ff8a80');
    // Smile
    drawRect(px + 11, py + 15, 8, 2, '#e57373');
    // Heart on dress
    drawRect(px + 12, py + 30, 3, 3, '#f44336');
    drawRect(px + 16, py + 30, 3, 3, '#f44336');
    drawRect(px + 11, py + 33, 9, 3, '#f44336');
    drawRect(px + 12, py + 36, 7, 2, '#f44336');
    drawRect(px + 13, py + 38, 5, 1, '#f44336');
  });
}

function drawTottiDog(x, y, animTimer, wagSpeed) {
  const bob = Math.sin(animTimer * 0.06) * 1;
  const bx = x - 18, by = y - 26 + bob;
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(bx - 2, y - 2, 40, 5);
  // Body — stocky gray brindle amstaff
  drawRect(bx, by + 6, 36, 16, '#78909c');
  drawRect(bx + 2, by + 8, 32, 12, '#546e7a');
  // Brindle pattern
  drawRect(bx + 6, by + 9, 4, 8, '#78909c');
  drawRect(bx + 14, by + 9, 4, 8, '#78909c');
  drawRect(bx + 22, by + 9, 4, 8, '#78909c');
  // Chest — lighter
  drawRect(bx + 8, by + 10, 10, 8, '#90a4ae');
  // Legs — short and muscular
  drawRect(bx + 2, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 10, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 20, by + 20, 6, 6, '#546e7a');
  drawRect(bx + 28, by + 20, 6, 6, '#546e7a');
  // Head — big and broad
  drawRect(bx + 26, by - 2, 14, 12, '#78909c');
  drawRect(bx + 28, by, 10, 8, '#90a4ae');
  // Floppy ears
  drawRect(bx + 25, by - 4, 4, 6, '#546e7a');
  drawRect(bx + 38, by - 4, 4, 6, '#546e7a');
  // Eyes
  drawRect(bx + 30, by + 1, 3, 3, '#263238');
  drawRect(bx + 36, by + 1, 3, 3, '#263238');
  // Nose
  drawRect(bx + 33, by + 5, 4, 3, '#111');
  // Tongue out
  drawRect(bx + 34, by + 8, 3, 4, '#ef5350');
  // Wagging tail
  const tailWag = Math.sin(animTimer * 0.2 * wagSpeed) * 8;
  drawRect(bx - 4, by + 4 + tailWag * 0.3, 6, 3, '#78909c');
  drawRect(bx - 8, by + 2 + tailWag, 5, 3, '#546e7a');
}

function drawSpeechBubble(x, y, text, timer) {
  if (timer > 120) return;
  const alpha = timer < 80 ? 1 : Math.max(0, 1 - (timer - 80) / 40);
  ctx.globalAlpha = alpha;
  ctx.font = '9px monospace';
  const tw = ctx.measureText(text).width + 16;
  const bx = Math.max(4, Math.min(W - tw - 4, x - tw / 2));
  drawRect(bx, y - 28, tw, 20, 'rgba(255,255,255,0.92)');
  drawRect(bx, y - 28, tw, 2, '#ff69b4');
  drawText(text, bx + tw / 2, y - 13, '#333', 9, 'center');
  // Small triangle pointer
  drawRect(x - 3, y - 8, 6, 4, 'rgba(255,255,255,0.92)');
  ctx.globalAlpha = 1;
}

function drawSabi() {
  sabiTimer++;
  if (!sabiCicca) return;

  // === Background — Sbomboland sunset sky ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#7b1fa2');
  skyGrad.addColorStop(0.3, '#e91e63');
  skyGrad.addColorStop(0.6, '#ff9800');
  skyGrad.addColorStop(1, '#ffcc02');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Zoom — camera follows Cicca
  const sabiZoom = isTouchDevice ? 1.35 : 1.25;
  {
    ctx.save();
    const camX = Math.max(W / (2 * sabiZoom), Math.min(W - W / (2 * sabiZoom), sabiCicca.x));
    const camY = 340;
    ctx.translate(W / 2, H / 2);
    ctx.scale(sabiZoom, sabiZoom);
    ctx.translate(-camX, -camY);
  }

  // Sun
  ctx.fillStyle = '#fff9c4';
  ctx.beginPath();
  ctx.arc(W - 120, 80, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff176';
  ctx.beginPath();
  ctx.arc(W - 120, 80, 32, 0, Math.PI * 2);
  ctx.fill();

  // Clouds
  for (let i = 0; i < 4; i++) {
    const cx = ((i * 230 + sabiTimer * 0.3) % (W + 100)) - 50;
    const cy = 40 + i * 25;
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(cx, cy, 18, 0, Math.PI * 2);
    ctx.arc(cx + 16, cy - 6, 14, 0, Math.PI * 2);
    ctx.arc(cx + 30, cy, 16, 0, Math.PI * 2);
    ctx.fill();
  }

  // Rolling hills (background)
  ctx.fillStyle = '#66bb6a';
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y - 40);
  for (let hx = 0; hx <= W; hx += 5) {
    ctx.lineTo(hx, GROUND_Y - 40 + Math.sin(hx * 0.008) * 25 + Math.sin(hx * 0.02) * 10);
  }
  ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();

  // Ground
  drawRect(0, GROUND_Y - 5, W, H - GROUND_Y + 5, '#4caf50');
  drawRect(0, GROUND_Y - 5, W, 3, '#388e3c');

  // Flowers on the ground
  for (let i = 0; i < 12; i++) {
    const fx = (i * 79 + 20) % W;
    const fy = GROUND_Y - 8 - Math.sin(i * 3.7) * 3;
    const fc = ['#ff69b4', '#ffeb3b', '#e040fb', '#ff5252', '#81d4fa'][i % 5];
    drawRect(fx, fy, 4, 4, fc);
    drawRect(fx + 1, fy - 3, 2, 3, '#66bb6a');
  }

  // Cozy house silhouette
  drawRect(60, GROUND_Y - 80, 70, 75, '#5d4037');
  drawRect(55, GROUND_Y - 80, 80, 5, '#4e342e');
  // Roof triangle (as rects)
  drawRect(65, GROUND_Y - 95, 60, 5, '#4e342e');
  drawRect(72, GROUND_Y - 100, 46, 5, '#4e342e');
  drawRect(80, GROUND_Y - 105, 30, 5, '#4e342e');
  drawRect(88, GROUND_Y - 108, 14, 5, '#4e342e');
  // Window glow
  drawRect(70, GROUND_Y - 60, 16, 14, '#fff9c4');
  drawRect(104, GROUND_Y - 60, 16, 14, '#fff9c4');
  // Door
  drawRect(85, GROUND_Y - 35, 20, 30, '#3e2723');
  // Heart on door
  drawRect(91, GROUND_Y - 28, 3, 3, '#f44336');
  drawRect(96, GROUND_Y - 28, 3, 3, '#f44336');
  drawRect(90, GROUND_Y - 25, 10, 3, '#f44336');
  drawRect(91, GROUND_Y - 22, 8, 2, '#f44336');
  drawRect(93, GROUND_Y - 20, 4, 1, '#f44336');

  // SBOMBOLAND sign
  drawRect(750, GROUND_Y - 50, 4, 50, '#795548');
  drawRect(720, GROUND_Y - 60, 70, 18, '#fff9c4');
  drawRect(720, GROUND_Y - 60, 70, 2, '#ff69b4');
  drawText('SBOMBOLAND', 755, GROUND_Y - 47, '#e91e63', 8, 'center');

  // Floating hearts + sparkles
  for (let i = 0; i < 6; i++) {
    const hx = (i * 150 + sabiTimer * 0.5 + i * 37) % W;
    const hy = 160 + Math.sin(sabiTimer * 0.02 + i * 2) * 40;
    const hs = 3 + Math.sin(sabiTimer * 0.03 + i) * 1;
    ctx.globalAlpha = 0.4 + Math.sin(sabiTimer * 0.04 + i) * 0.2;
    drawRect(hx, hy, hs, hs, '#ff69b4');
    drawRect(hx + hs + 1, hy, hs, hs, '#ff69b4');
    drawRect(hx - 1, hy + hs, hs * 2 + 2, hs, '#ff69b4');
    drawRect(hx, hy + hs * 2, hs * 2, hs * 0.6, '#ff69b4');
    ctx.globalAlpha = 1;
  }
  // Sparkles
  for (let i = 0; i < 5; i++) {
    const sx = (i * 190 + sabiTimer * 0.7 + i * 53) % W;
    const sy = 100 + Math.sin(sabiTimer * 0.03 + i * 1.5) * 60;
    ctx.globalAlpha = 0.3 + Math.sin(sabiTimer * 0.05 + i * 2.1) * 0.3;
    drawRect(sx, sy, 2, 2, '#fff');
    drawRect(sx - 1, sy + 1, 1, 1, '#fff9c4');
    ctx.globalAlpha = 1;
  }

  // === Draw characters ===
  drawSabiChar(sabiSabi.x, sabiSabi.y, sabiSabi.animTimer);
  drawTottiDog(sabiTotti.x, sabiTotti.y, sabiTotti.animTimer, sabiCicca && Math.abs(sabiCicca.x - sabiTotti.x) < 60 ? 3 : 1);
  drawCicca(sabiCicca.x, sabiCicca.y, sabiCicca.facing, sabiCicca.animTimer);

  // === Player movement (Cicca the cat) ===
  const speed = 2.5;
  if (keys['ArrowLeft'] || keys['KeyA']) {
    sabiCicca.vx = -speed;
    sabiCicca.facing = -1;
    sabiCicca.animTimer++;
  } else if (keys['ArrowRight'] || keys['KeyD']) {
    sabiCicca.vx = speed;
    sabiCicca.facing = 1;
    sabiCicca.animTimer++;
  } else {
    sabiCicca.vx = 0;
  }
  sabiCicca.x += sabiCicca.vx;
  sabiCicca.x = Math.max(20, Math.min(W - 20, sabiCicca.x));

  // Update character anim timers
  sabiSabi.animTimer++;
  sabiTotti.animTimer++;

  // === Interaction — speech bubbles ===
  const distToSabi = Math.abs(sabiCicca.x - sabiSabi.x);
  const distToTotti = Math.abs(sabiCicca.x - sabiTotti.x);

  // Show interaction prompts
  if (distToSabi < 60) {
    ctx.globalAlpha = 0.5 + Math.sin(sabiTimer * 0.1) * 0.3;
    drawText('[SPACE]', sabiSabi.x, sabiSabi.y - 62, '#fff', 8, 'center');
    ctx.globalAlpha = 1;
  }
  if (distToTotti < 60) {
    ctx.globalAlpha = 0.5 + Math.sin(sabiTimer * 0.1) * 0.3;
    drawText('[SPACE]', sabiTotti.x, sabiTotti.y - 36, '#fff', 8, 'center');
    ctx.globalAlpha = 1;
  }

  // Trigger joke on Space/ATK press
  if (keysJustPressed['Space'] || keysJustPressed['KeyZ']) {
    if (distToSabi < 60) {
      if (!sabiSwordUnlocked) {
        sabiDialogueCount++;
        if (sabiDialogueCount >= 10) {
          // === SBOMBO SWORD UNLOCK ===
          sabiSwordUnlocked = true;
          sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
          sabiMessages.push({ text: 'Bobbi, ti meriti questo... LA SPADA DELLO SBOMBO!', target: 'sabi', timer: 0 });
          playSFX('victory_jingle');
          screenFlash = 30;
          flashColor = '#ffd700';
          screenShake = 12;
          spawnParticles(sabiSabi.x, sabiSabi.y - 30, '#ffd700', 25, 8);
          spawnParticles(sabiSabi.x, sabiSabi.y - 30, '#ff69b4', 20, 6);
          // Replace weapon with Sbombo Sword
          weapons[0] = {
            name: 'Spada dello Sbombo',
            damage: 80,
            range: 90,
            speed: 4,
            crit: 50,
            comboHits: 6,
            poise: 30,
            activeFrames: 10,
            comboWindow: 18,
            endLag: 6,
            special: 'sbombo',
            color: '#ff69b4',
            desc: 'La leggendaria spada di Sbomboland',
            icon: '\u2665',
            glow: true
          };
          weaponTier = 3;
        } else {
          const joke = sabiJokesSabi[Math.floor(Math.random() * sabiJokesSabi.length)];
          sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
          sabiMessages.push({ text: joke, target: 'sabi', timer: 0 });
          playSFX('coin');
        }
      } else {
        // Post-unlock dialogue
        const postUnlock = ['Usa la Spada dello Sbombo, Bobbi!', 'Vai e sbomba tutti!', 'La spada e\' parte di te ora...', 'Nessuno puo\' fermarti!', 'Sbomba con amore <3'];
        const msg = postUnlock[Math.floor(Math.random() * postUnlock.length)];
        sabiMessages = sabiMessages.filter(m => m.target !== 'sabi');
        sabiMessages.push({ text: msg, target: 'sabi', timer: 0 });
        playSFX('coin');
      }
    }
    if (distToTotti < 60) {
      const joke = sabiJokesTotti[Math.floor(Math.random() * sabiJokesTotti.length)];
      sabiMessages = sabiMessages.filter(m => m.target !== 'totti');
      sabiMessages.push({ text: joke, target: 'totti', timer: 0 });
      playSFX('coin');
    }
  }

  // Draw and update speech bubbles
  sabiMessages.forEach(m => {
    m.timer++;
    if (m.target === 'sabi') {
      drawSpeechBubble(sabiSabi.x, sabiSabi.y - 60, m.text, m.timer);
    } else {
      drawSpeechBubble(sabiTotti.x, sabiTotti.y - 34, m.text, m.timer);
    }
  });
  sabiMessages = sabiMessages.filter(m => m.timer < 120);

  // Restore zoom before drawing UI
  ctx.restore();

  // === UI text ===
  // Title — floating
  const titleBob = Math.sin(sabiTimer * 0.03) * 4;
  drawText('~ SBOMBOLAND ~', W / 2, 30 + titleBob, '#ff69b4', 22, 'center');
  drawText('~ SBOMBOLAND ~', W / 2 + 1, 31 + titleBob, '#ffd54f', 22, 'center');

  // Sbombo counter
  if (!sabiSwordUnlocked) {
    drawText('Sbombi: ' + sabiDialogueCount + '/10', W - 90, 30, '#ff69b4', 11, 'center');
  } else {
    drawText('\u2665 SPADA SBLOCCATA \u2665', W - 100, 30, '#ffd700', 11, 'center');
  }

  // Bottom hints
  drawText('ESC per tornare al gioco', W / 2, H - 20, 'rgba(255,255,255,0.6)', 10, 'center');
  drawText('Dedicato a Sabina con amore <3', W / 2, H - 8, '#ff69b4', 9, 'center');

  // Arrow keys hint (fades after a few seconds)
  if (sabiTimer < 180) {
    ctx.globalAlpha = Math.max(0, 1 - sabiTimer / 180);
    drawText('Usa le frecce per muovere Cicca!', W / 2, H - 40, '#fff', 10, 'center');
    ctx.globalAlpha = 1;
  }

  // === ESC to return ===
  if (keys['Escape']) {
    state = sabiPreviousState;
  }

  drawTouchButtons();
}

// ==========================================
// VICTORY
// ==========================================
let victoryTimer = 0; // guard timer to prevent instant restart
let victorySongStarted = false;
let freestyleFadeTimer = 0; // countdown for smooth crossfade to freestyle
let freestyleNeedsTap = false; // mobile autoplay blocked — waiting for user gesture

function stopVictorySong() {
  victorySongStarted = false;
  freestyleNeedsTap = false;
  freestyleVideo.pause();
  freestyleVideo.currentTime = 0;
}

function drawVictory() {
  victoryTimer++;

  // Smooth crossfade: after sweep SFX finishes, start freestyle audio
  if (freestyleFadeTimer > 0) {
    freestyleFadeTimer--;
    if (freestyleFadeTimer === 0) {
      freestyleVideo.currentTime = 0;
      freestyleVideo.play().then(() => { freestyleNeedsTap = false; }).catch(() => { freestyleNeedsTap = true; });
    }
  }

  // Mobile autoplay blocked — tap anywhere to start freestyle
  if (freestyleNeedsTap && (mouseClick || keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'])) {
    freestyleVideo.currentTime = 0;
    freestyleVideo.play().then(() => { freestyleNeedsTap = false; }).catch(() => {});
  }

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1b5e20');
  grad.addColorStop(1, '#0d0d1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Fireworks
  if (gameTime % 20 === 0) {
    const fx = 100 + Math.random() * (W - 200);
    const fy = 50 + Math.random() * 200;
    const colors = ['#f44336','#ffeb3b','#4caf50','#2196f3','#e040fb','#ff9800'];
    spawnParticles(fx, fy, colors[Math.floor(Math.random() * colors.length)], 15, 6);
  }
  drawParticles();
  updateParticles();

  // Scrolling credits with fade-in
  const fadeIn = Math.min(1, victoryTimer / 60);
  ctx.globalAlpha = fadeIn;

  const bounce = Math.sin(gameTime * 0.05) * 5;
  drawText('VITTORIA!', W/2, 80 + bounce, '#ffd700', 42, 'center');
  drawText('Il Conte ha conquistato Valle Aurelia!', W/2, 130, '#fff', 16, 'center');
  drawText('La gang e\' stata sconfitta. Prati e\' salvo.', W/2, 155, '#aaa', 14, 'center');

  drawText('Daniele "il Conte" - EROE DI PRATI', W/2, 200, '#ffcc80', 20, 'center');

  // Boss defeated list
  drawText('Boss sconfitti:', W/2, 245, '#e94560', 14, 'center');
  levels.forEach((l, i) => {
    const bossAlpha = Math.min(1, Math.max(0, (victoryTimer - 60 - i * 30) / 30));
    ctx.globalAlpha = bossAlpha * fadeIn;
    drawText(l.boss + ' (' + l.name + ')', W/2, 268 + i * 22, '#4caf50', 12, 'center');
  });
  ctx.globalAlpha = fadeIn;

  // Credits section
  const creditsY = 385;
  drawText('- CREDITS -', W/2, creditsY, '#ffd700', 14, 'center');
  drawText('Un gioco da conti...anzi, del Conte!', W/2, creditsY + 18, '#ccc', 11, 'center');
  drawText('Sviluppatore: Cicca', W/2, creditsY + 36, '#aaa', 11, 'center');
  drawText('Musica: Cicca & Daniele', W/2, creditsY + 50, '#aaa', 11, 'center');
  drawText('Ambientato a Prati, Roma', W/2, creditsY + 64, '#aaa', 11, 'center');
  drawText('Grazie per aver giocato!', W/2, creditsY + 84, '#ffcc80', 13, 'center');

  drawText('Coins raccolti: ' + coins, W/2, creditsY + 104, '#ffd700', 12, 'center');

  // Tap-to-play prompt for mobile (autoplay blocked)
  if (freestyleNeedsTap) {
    const tapPulse = 0.5 + Math.sin(gameTime * 0.08) * 0.5;
    ctx.globalAlpha = tapPulse;
    drawText('TOCCA PER LA MUSICA', W/2, creditsY + 120, '#ffd700', 14, 'center');
    ctx.globalAlpha = fadeIn;
  }

  ctx.globalAlpha = 1;

  // Only show restart prompt after 3 seconds
  if (victoryTimer > 180) {
    const restartBtnW = 260, restartBtnH = 36;
    const restartBtnX = W/2 - restartBtnW/2, restartBtnY = H - 50;
    const restartHover = mouseX >= restartBtnX && mouseX <= restartBtnX + restartBtnW && mouseY >= restartBtnY && mouseY <= restartBtnY + restartBtnH;
    drawRect(restartBtnX, restartBtnY, restartBtnW, restartBtnH, restartHover ? '#ffd700' : 'rgba(255,215,0,0.2)');
    drawRect(restartBtnX, restartBtnY, restartBtnW, 2, '#ffd700');
    drawText('RICOMINCIA', W/2, restartBtnY + 25, restartHover ? '#1a1a2e' : '#ffd700', 16, 'center');

    if (keysJustPressed['Enter'] || keysJustPressed['Space'] || keysJustPressed['KeyZ'] || (restartHover && mouseClick)) {
      // Reset everything
      coins = 0;
      player.weapon = 0;
      weapons = [starterWeapons[0]];
      weaponTier = 0;
      healthTier = 0; dodgeTier = 0; speedTier = 0;
      player.maxHp = 120;
      player.maxStamina = 100;
      player.speed = 4.0;
      player.upgrades = [];
      helpers.forEach(h => { h.tier = 0; h.unlocked = false; });
      bossDefeated = [false, false, false, false, false];
      lives = 3;
      firstTime = true;
      victoryTimer = 0;
      freestyleFadeTimer = 0;
      hasSunglasses = false;
      micheleVisited = false;
      micheleArgueIntroDone = false;
      micheleArgueFirstSeen = false;
      lampHit = false;
      hubCatPetted = false;
      drinkTaken = false;
      drinkBuff = 0;
      hubVisitInited = false;
      stopVictorySong();
      state = 'menu';
    }
  }
}

// ==========================================
// MAIN GAME LOOP
// ==========================================
function update() {
  // Skip game updates while freestyle video is playing
  if (freestylePlaying) return;

  gameTime++;

  // Music management per state
  switch(state) {
    case 'menu': playTrack('menu'); break;
    case 'difficultySelect': case 'weaponSelect': case 'helperSelect': playTrack('menu'); break;
    case 'tutorial': playTrack('menu'); break;
    case 'hub': case 'shop': case 'upgrade': case 'backroom': playTrack('hub'); break;
    case 'moves': break; // keep whatever music was playing
    case 'dialogue':
      // During dialogue, keep appropriate music playing (don't let it die)
      if (currentTrackName) playTrack(currentTrackName);
      break;
    case 'level':
      if (bossIntro && bossIntroTimer <= 0) {
        const bossTrackMap = ['boss_lafed', 'boss_gioacchino', 'boss_dale', 'boss_ciccio', 'boss_pisellino'];
        playTrack(bossTrackMap[currentLevel] || 'boss_lafed');
      } else if (bossIntro && bossIntroTimer > 0) {
        const buildupMap = ['boss_buildup_0', 'boss_buildup_1', 'boss_buildup_2', 'boss_buildup_3', 'boss_buildup_4'];
        playTrack(buildupMap[currentLevel] || 'boss_buildup_4');
      } else {
        playTrack('level');
      }
      break;
    case 'gameover': playTrack('gameover'); break;
    case 'victory': if (!victorySongStarted) { stopMusic(); playSFX('victory_sweep'); victorySongStarted = true; freestyleFadeTimer = 45; } break;
    case 'sabi': playTrack('sabi'); break;
    case 'casino': playTrack('casino'); break;
  }

  switch(state) {
    case 'menu': break;
    case 'difficultySelect': break;
    case 'weaponSelect': break;
    case 'helperSelect': break;
    case 'moves': break;
    case 'tutorial': updateTutorial(); break;
    case 'hub': break;
    case 'shop': break;
    case 'upgrade': break;
    case 'dialogue': break;
    case 'level': updateLevel(); break;
    case 'gameover': break;
    case 'victory': break;
    case 'sabi': break;
    case 'casino': break;
    case 'backroom': break;
  }

  // Screen shake
  if (screenShake > 0) screenShake--;
  if (screenFlash > 0) screenFlash--;

}

function draw() {
  ctx.save();

  // Screen shake
  if (screenShake > 0) {
    const sx = (Math.random() - 0.5) * screenShake;
    const sy = (Math.random() - 0.5) * screenShake;
    ctx.translate(sx, sy);
  }

  // Drink wobble effect
  if (drinkWobble > 0) {
    ctx.rotate(Math.sin(gameTime * 0.15) * 0.01 * (drinkWobble / 180));
  }

  switch(state) {
    case 'menu': drawMenu(); break;
    case 'difficultySelect': drawDifficultySelect(); break;
    case 'weaponSelect': drawWeaponSelect(); break;
    case 'helperSelect': drawHelperSelect(); break;
    case 'moves': drawMovesScreen(); break;
    case 'tutorial': drawTutorial(); break;
    case 'hub': drawHub(); break;
    case 'shop': drawShop(); break;
    case 'upgrade': drawUpgradeScreen(); break;
    case 'dialogue': drawDialogue(); break;
    case 'level': drawLevel(); break;
    case 'gameover': drawGameOver(); break;
    case 'victory': drawVictory(); break;
    case 'sabi': drawSabi(); break;
    case 'casino': drawCasino(); break;
    case 'backroom': drawBackroom(); break;
  }

  // Screen flash
  if (screenFlash > 0) {
    ctx.globalAlpha = screenFlash / 20;
    ctx.fillStyle = flashColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  // Quick text overlay (global — works in hub, shop, backroom, level, etc.)
  if (quickTextTimer > 0) {
    const qtY = (state === 'level' && isTouchDevice) ? 108 : H - 65;
    ctx.globalAlpha = Math.min(1, quickTextTimer / 20);
    drawRect(W/2 - 260, qtY, 520, 24, 'rgba(0,0,0,0.85)');
    drawRect(W/2 - 260, qtY, 520, 2, quickTextColor);
    drawText(quickText, W/2, qtY + 17, quickTextColor, 12, 'center');
    ctx.globalAlpha = 1;
    quickTextTimer--;
  }

  ctx.restore();
}

function gameLoop() {
  if (hitstopFrames > 0) {
    hitstopFrames--;
    draw(); // Still draw, but freeze gameplay for impact feel
  } else {
    update();
    draw();
  }
  // Clear just-pressed keys AFTER both update() and draw() so draw-phase code (hub) can read them
  Object.keys(keysJustPressed).forEach(k => delete keysJustPressed[k]);
  mouseClick = false;
  requestAnimationFrame(gameLoop);
}

// Start
gameLoop();

</script>
</body>
</html>
